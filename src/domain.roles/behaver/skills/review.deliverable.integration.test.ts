import { execSync, spawnSync } from 'child_process';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { given, then, useBeforeAll, when } from 'test-fns';

import { genTestGitRepo } from '../../../../accept.blackbox/.test/infra';

const SKILL_PATH = path.join(__dirname, 'review.deliverable.sh');
const FIXTURES_PATH = path.join(__dirname, '.test/assets/example.repo');

/**
 * .what = finds feedback file matching pattern with timestamp
 * .why = feedback files now have dynamic timestamps in filename
 */
const findFeedbackFile = (input: {
  dir: string;
  pattern: string;
}): string | undefined => {
  const files = fs.readdirSync(input.dir);
  return files.find((f) => f.startsWith(input.pattern) && f.endsWith('.md'));
};

/**
 * .what = creates a temp copy of fixture with real git history
 * .why = avoids git-within-git issues by isolating in /tmp
 */
const prepareFixtureWithGit = (input: { fixturePath: string }): string => {
  // fail fast if fixture doesn't exist
  if (!fs.existsSync(input.fixturePath)) {
    throw new Error(
      `prepareFixtureWithGit: fixture not found at ${input.fixturePath}`,
    );
  }

  // create base git repo from fixture
  const { repoDir } = genTestGitRepo({
    prefix: 'review-test-',
    copyFrom: input.fixturePath,
    commitGlob: '.behavior/',
  });

  // if src/ exists, create feature branch with deliverable
  if (fs.existsSync(path.join(repoDir, 'src'))) {
    execSync('git checkout -b feat/implementation', { cwd: repoDir });
    execSync('git add src/', { cwd: repoDir });
    execSync('git commit -m "feat: add implementation"', { cwd: repoDir });
  }

  return repoDir;
};

describe('review.deliverable', () => {
  given('[case1] valid behavior with complete deliverable', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'valid-behavior');
      const gitRepo = prepareFixtureWithGit({ fixturePath: fixture });
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] --against blueprint', () => {
      then('creates feedback file with review output', () => {
        const result = spawnSync(
          'bash',
          [
            SKILL_PATH,
            '--for.behavior',
            'get-weather-emoji',
            '--against',
            'blueprint',
            '--dir',
            scene.gitRepo,
          ],
          { timeout: 180000 },
        ); // 2 min timeout for claude

        expect(result.status).toBe(0);

        const behaviorDir = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
        );
        const feedbackFile = findFeedbackFile({
          dir: behaviorDir,
          pattern:
            '7.1.review.behavior.per_blueprint.[feedback].[given].by_robot.v',
        });
        expect(feedbackFile).toBeDefined();

        const content = fs.readFileSync(
          path.join(behaviorDir, feedbackFile!),
          'utf-8',
        );
        expect(content).toContain('generated by: review.deliverable');

        // verify latest major version was selected (v2 over v1)
        const logDir = fs.readdirSync(
          path.join(scene.gitRepo, '.log/bhuild/review.deliverable'),
        )[0];
        const promptContent = fs.readFileSync(
          path.join(
            scene.gitRepo,
            '.log/bhuild/review.deliverable',
            logDir!,
            'input.prompt.md',
          ),
          'utf-8',
        );
        expect(promptContent).toContain('3.3.blueprint.v2.i1.md');
        expect(promptContent).not.toContain('3.3.blueprint.v1.i1.md');
      });
    });

    when('[t1] --against wish,vision,criteria', () => {
      then('creates feedback file with combined target slug', () => {
        const result = spawnSync(
          'bash',
          [
            SKILL_PATH,
            '--for.behavior',
            'get-weather-emoji',
            '--against',
            'wish,vision,criteria',
            '--dir',
            scene.gitRepo,
          ],
          { timeout: 180000 },
        );

        expect(result.status).toBe(0);

        const behaviorDir = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
        );
        const feedbackFile = findFeedbackFile({
          dir: behaviorDir,
          pattern:
            '7.1.review.behavior.per_wish_vision_criteria.[feedback].[given].by_robot.v',
        });
        expect(feedbackFile).toBeDefined();
      });
    });

    when('[t2] --against roadmap', () => {
      then('creates feedback file for roadmap review', () => {
        const result = spawnSync(
          'bash',
          [
            SKILL_PATH,
            '--for.behavior',
            'get-weather-emoji',
            '--against',
            'roadmap',
            '--dir',
            scene.gitRepo,
          ],
          { timeout: 180000 },
        );

        expect(result.status).toBe(0);

        const behaviorDir = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
        );
        const feedbackFile = findFeedbackFile({
          dir: behaviorDir,
          pattern:
            '7.1.review.behavior.per_roadmap.[feedback].[given].by_robot.v',
        });
        expect(feedbackFile).toBeDefined();
      });
    });
  });

  given('[case2] behavior with declaration file not found', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'missing-criteria');
      const gitRepo = prepareFixtureWithGit({ fixturePath: fixture });
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] --against criteria', () => {
      then('fails fast with clear error', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior',
          'foo',
          '--against',
          'criteria',
          '--dir',
          scene.gitRepo,
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain(
          'declaration file not found',
        );
      });
    });

    when('[t1] --against roadmap', () => {
      then('fails fast when no roadmap exists', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior',
          'foo',
          '--against',
          'roadmap',
          '--dir',
          scene.gitRepo,
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain(
          'declaration file not found',
        );
      });
    });

    when('[t2] --against wish,vision,criteria (one not found)', () => {
      then('fails fast on the target not found', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior',
          'foo',
          '--against',
          'wish,vision,criteria',
          '--dir',
          scene.gitRepo,
        ]);

        expect(result.status).not.toBe(0);
        const stdout = result.stdout.toString();
        expect(stdout).toContain('declaration file not found');
        expect(stdout).toContain('vision');
      });
    });
  });

  given('[case3] ambiguous behavior name', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'ambiguous-behavior');
      const gitRepo = prepareFixtureWithGit({ fixturePath: fixture });
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] --for.behavior weather', () => {
      then('fails fast listing matches', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior',
          'weather',
          '--against',
          'wish',
          '--dir',
          scene.gitRepo,
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('multiple behaviors match');
      });
    });
  });

  given('[case4] required arguments not provided', () => {
    when('[t0] --for.behavior not provided', () => {
      then('fails fast with usage guidance', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--against',
          'blueprint',
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain(
          '--for.behavior is required',
        );
      });
    });

    when('[t1] --against not provided', () => {
      then('fails fast with usage guidance', () => {
        const result = spawnSync('bash', [SKILL_PATH, '--for.behavior', 'foo']);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('--against is required');
      });
    });
  });

  given('[case5] no .behavior directory', () => {
    when('[t0] skill invoked in dir without .behavior/', () => {
      then('fails fast with clear error', () => {
        const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'no-behavior-'));

        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior',
          'anything',
          '--against',
          'wish',
          '--dir',
          tempDir,
        ]);

        fs.rmSync(tempDir, { recursive: true, force: true });

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain(
          '.behavior/ directory not found',
        );
      });
    });
  });

  given('[case6] deliverable with intentional blocker', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'valid-behavior-with-blocker');
      const gitRepo = prepareFixtureWithGit({ fixturePath: fixture });
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] review executes against criteria', () => {
      then('feedback file contains blocker', () => {
        const result = spawnSync(
          'bash',
          [
            SKILL_PATH,
            '--for.behavior',
            'get-weather-emoji',
            '--against',
            'criteria',
            '--dir',
            scene.gitRepo,
          ],
          { timeout: 180000 },
        );

        expect(result.status).toBe(0);

        const behaviorDir = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
        );
        const feedbackFile = findFeedbackFile({
          dir: behaviorDir,
          pattern:
            '7.1.review.behavior.per_criteria.[feedback].[given].by_robot.v',
        });
        expect(feedbackFile).toBeDefined();

        const content = fs.readFileSync(
          path.join(behaviorDir, feedbackFile!),
          'utf-8',
        );
        expect(content.toLowerCase()).toContain('blocker');
      });
    });
  });
});
