# usecase.1 = bind branch to behavior

given('a repo with .behavior/ directory containing behavior declarations')
  when('bind flag file exists at .behavior/{behavior}/.bind/{flatBranchName}.flag')
    then('branch is considered bound to that behavior')
      sothat('hook can discover which behavior applies to current work')

given('multiple branches bound to the same behavior')
  when('hook searches for bind flags')
    then('each branch resolves to the same behavior independently')
      sothat('teams can collaborate on a single behavior from different branches')

given('a branch with bind flags in multiple different behaviors')
  when('hook searches for bind flag matching current branch')
    then('hook fails fast with clear error listing the conflicting bindings')
      sothat('user knows only one behavior can be bound per branch')

given('a branch with no bind flag in any behavior')
  when('hook searches for bind flag matching current branch')
    then('hook exits silently without injecting context')
      sothat('unbound branches work normally without behavior overhead')


# usecase.1b = bind.behavior skill

given('bhuild role with bind.behavior skill')
  when('skill is invoked with --set --behavior {behaviorName}')
    then('bind flag is created at .behavior/{behavior}/.bind/{flatBranchName}.flag')
    then('skill outputs confirmation of binding')
      sothat('user can explicitly bind current branch to a behavior')

given('bind.behavior skill invoked with --set')
  when('current branch is already bound to a different behavior')
    then('skill fails fast with clear error')
    then('error message suggests using --del first or using a new worktree')
      sothat('user cannot accidentally create conflicting bindings')

given('bind.behavior skill invoked with --set')
  when('current branch is already bound to the same behavior')
    then('skill succeeds idempotently')
    then('skill outputs that binding already exists')
      sothat('repeated invocations are safe')

given('bind.behavior skill invoked with --del')
  when('current branch is bound to a behavior')
    then('bind flag is removed')
    then('skill outputs confirmation of unbinding')
      sothat('user can explicitly unbind current branch')

given('bind.behavior skill invoked with --del')
  when('current branch is not bound to any behavior')
    then('skill succeeds idempotently')
    then('skill outputs that no binding existed')
      sothat('repeated invocations are safe')

given('bind.behavior skill invoked with --get')
  when('skill runs')
    then('skill outputs current binding status')
    then('if bound, shows which behavior')
    then('if unbound, shows "not bound"')
      sothat('user can query binding state')

given('bind.behavior skill invoked without --set, --del, or --get')
  when('skill runs')
    then('skill fails fast with usage guidance')
      sothat('user knows to specify an action')

given('bind.behavior skill invoked with --behavior that does not exist')
  when('--set is specified')
    then('skill fails fast with clear error listing available behaviors')
      sothat('user knows to check behavior name')


# usecase.1c = init.behavior auto-binds branch

given('init.behavior skill creates a new behavior')
  when('behavior directory is created successfully')
    then('skill automatically creates bind flag for current branch')
      sothat('branch is immediately bound to the newly created behavior')

given('init.behavior skill invoked')
  when('current branch is already bound to an existing behavior')
    then('skill fails fast with clear error')
    then('error explains that branch is already bound to {existingBehavior}')
    then('error suggests using git worktree to create a new branch for the new behavior')
      sothat('user maintains one-behavior-per-branch discipline')

given('init.behavior skill invoked')
  when('current branch is not bound to any behavior')
    then('skill proceeds to create behavior and bind branch')
      sothat('new behaviors are immediately associated with their working branch')


# usecase.2 = dispatch context on session start

given('a branch bound to a behavior')
  when('claude code session starts')
    then('hook runs automatically')
    then('hook injects behavior context into session')
      sothat('agent starts with full awareness of current behavior')

given('hook runs on session start')
  when('behavior has 0.wish.md')
    then('wish content is injected into context')
      sothat('agent knows what is being wished for')

given('hook runs on session start')
  when('behavior has 1.vision.md')
    then('vision content is injected into context')
      sothat('agent knows the envisioned solution')
  when('behavior lacks 1.vision.md')
    then('hook continues without vision injection')
      sothat('optional files do not block dispatch')

given('hook runs on session start')
  when('behavior has 2.criteria.md')
    then('criteria content is injected into context')
      sothat('agent knows the acceptance criteria')
  when('behavior lacks 2.criteria.md')
    then('hook continues without criteria injection')
      sothat('optional files do not block dispatch')

given('hook runs on session start')
  when('behavior has blueprint files (e.g., 3.3.blueprint.v1.i1.md, 3.3.blueprint.v2.i2.md)')
    then('latest major version blueprint is selected')
    then('blueprint content is injected into context')
      sothat('agent knows the latest implementation design')
  when('behavior lacks any blueprint files')
    then('hook continues without blueprint injection')
      sothat('optional files do not block dispatch')


# usecase.3 = dispatch context on compaction

given('a branch bound to a behavior')
  when('context compaction occurs during session')
    then('hook runs automatically')
    then('hook re-injects behavior context')
      sothat('agent retains behavior awareness after context is summarized')

given('hook runs on compaction')
  when('behavior files exist')
    then('all existing behavior files are re-injected (wish, vision, criteria, blueprint)')
      sothat('compacted context is re-enriched with full behavior reference')


# usecase.4 = flatten branch name for bind lookup

given('branch name with forward slashes (e.g., vlad/dispatch-behavior-hooks)')
  when('hook constructs bind flag path')
    then('slashes are replaced with dots (e.g., vlad.dispatch-behavior-hooks)')
      sothat('bind flag filename is filesystem-safe')

given('branch name with special characters')
  when('hook constructs bind flag path')
    then('special characters are normalized to safe equivalents')
      sothat('lookup succeeds regardless of branch naming convention')


# usecase.5 = resolve latest blueprint version

given('behavior directory with multiple blueprint versions')
  when('hook resolves which blueprint to inject')
    then('latest major version is selected (v3.i2 over v2.i3)')
      sothat('agent sees the most evolved design')

given('behavior directory with single blueprint version')
  when('hook resolves which blueprint to inject')
    then('that version is selected')

given('behavior directory with blueprint iterations (v1.i1, v1.i2, v1.i3)')
  when('hook resolves which blueprint to inject')
    then('latest iteration of latest major version is selected (v1.i3)')
      sothat('agent sees the most refined iteration')


# usecase.6 = hook registration following mechanic pattern

given('bhuild role with inits/ directory')
  when('rhachet boots the role')
    then('session-start hook is registered via claude hooks mechanism')
    then('compaction hook is registered via claude hooks mechanism')
      sothat('dispatch behavior hooks follow established patterns')

given('existing mechanic inits pattern')
  when('bhuild inits are implemented')
    then('implementation reuses or mirrors mechanic hook registration approach')
      sothat('consistency is maintained across roles')


# usecase.7 = context injection format

given('hook injects behavior files')
  when('content is rendered')
    then('each file is wrapped with clear header indicating file path')
    then('content is rendered as markdown')
      sothat('agent can reference specific files in its work')

given('hook injects multiple files')
  when('content is rendered')
    then('files appear in logical order: wish, vision, criteria, blueprint')
      sothat('agent reads context in natural progression')


# usecase.8 = error handling and observability

given('hook encounters error during bind lookup')
  when('error is filesystem-related')
    then('error is logged with context (branch name, expected path)')
    then('session continues without behavior injection')
      sothat('transient errors do not block work')

given('hook encounters error during file read')
  when('bind was found but file cannot be read')
    then('error is logged clearly')
    then('session continues with partial injection')
      sothat('one bad file does not block all context')


# usecase.9 = integration with existing rhachet infrastructure

given('rhachet-roles-bhuild package')
  when('dispatch-behavior-hooks feature is implemented')
    then('hooks are declared in bhuild role inits/ directory')
    then('hook scripts are executable and shell-based')
      sothat('integration follows established rhachet conventions')

given('hook logic that selects latest blueprint')
  when('logic is implemented')
    then('logic is extracted to reusable utility')
      sothat('review.deliverable skill and hooks share same resolution logic')
