# blueprint.v1 = dispatch-behavior-hooks

## overview

implement behavior context dispatch via claude hooks, following the mechanic role pattern.

when a branch is bound to a behavior, session start and compaction events will inject
the behavior's wish, vision, criteria, and latest blueprint into the agent's context.

---

## components

### 1. reusable domain operations (TypeScript)

all reusable operations are TypeScript modules in `src/domain.operations/behavior/bind/`.
shell skill wrappers dispatch to them via `npx tsx`.

#### 1.1 `src/domain.operations/behavior/bind/flattenBranchName.ts`

```
.what = flatten branch name to filesystem-safe format
.why  = bind flag filenames cannot contain forward slashes

.how  = replace `/` with `.`, normalize other special characters

.signature:
  input: { branchName: string }
  output: string (flattened name)

.example:
  flattenBranchName({ branchName: "vlad/dispatch-behavior-hooks" })
  // => "vlad.dispatch-behavior-hooks"
```

#### 1.2 `src/domain.operations/behavior/bind/getBoundBehaviorByBranch.ts`

```
.what = find which behavior (if any) current branch is bound to
.why  = both hooks and skills need to discover bindings

.how  = search .behavior/*/.bind/${flatBranchName}.flag

.signature:
  input: { branchName?: string } (defaults to current branch via git)
  output: { behaviorDir: string | null, bindings: string[] }

.behaviors:
  - if zero bindings found: return { behaviorDir: null, bindings: [] }
  - if one binding found: return { behaviorDir: path, bindings: [path] }
  - if multiple bindings found: return { behaviorDir: null, bindings: [...paths] }
    (caller decides whether to throw)
```

#### 1.3 `src/domain.operations/behavior/bind/getLatestBlueprintByBehavior.ts`

```
.what = resolve the latest blueprint version from a behavior directory
.why  = both hooks and review.deliverable need this logic

.how  = find 3.3.blueprint.v*.i*.md files, sort by version, return latest

.signature:
  input: { behaviorDir: string }
  output: string | null (path to latest blueprint, or null if none)

.version-precedence:
  - v3.i2 > v2.i3 (major version wins)
  - v2.i3 > v2.i1 (latest iteration within major)
```

note: extract existing logic from review.deliverable.sh `get_target_file` function

#### 1.4 shell skill wrappers

each domain operation has a corresponding `.sh` wrapper in `src/domain.roles/behaver/skills/`:

```bash
# example: flattenBranchName.sh
#!/usr/bin/env bash
npx tsx src/domain.operations/behavior/bind/flattenBranchName.ts "$@"
```

---

### 2. bind.behavior skill

#### 2.1 `src/domain.roles/behaver/skills/bind.behavior.sh`

```
.what = bind, unbind, or query branch-to-behavior binding
.why  = explicit user control over which behavior applies to current branch

.usage:
  bind.behavior.sh --set --behavior <name>   # bind current branch
  bind.behavior.sh --del                      # unbind current branch
  bind.behavior.sh --get                      # query current binding

.behaviors:

  --set --behavior <name>:
    1. resolve behavior directory from name (fail if not found, fail if ambiguous)
    2. check if branch already bound via getBoundBehaviorByBranch
       - if bound to different behavior: fail fast, suggest --del or worktree
       - if bound to same behavior: succeed idempotently
    3. create .behavior/{behavior}/.bind/{flatBranchName}.flag
    4. output confirmation

  --del:
    1. check if branch bound via getBoundBehaviorByBranch
       - if not bound: succeed idempotently, output "no binding existed"
    2. remove the bind flag file
    3. output confirmation

  --get:
    1. check if branch bound via getBoundBehaviorByBranch
    2. output bound behavior name, or "not bound"

  no action flag:
    - fail fast with usage guidance

.bind-flag-content:
  the .flag file should contain metadata for observability:
  ```
  branch: vlad/dispatch-behavior-hooks
  bound_by: bind.behavior skill
  ```
```

---

### 3. init.behavior updates

#### 3.1 update `src/domain.roles/behaver/skills/init.behavior.sh`

```
.changes:

  1. add binding check at start:
     - call getBoundBehaviorByBranch for current branch
     - if already bound: fail fast with error explaining:
       - "branch already bound to {existingBehavior}"
       - "use git worktree to create new branch for new behavior"

  2. after behavior directory created:
     - create bind flag at .behavior/{newBehavior}/.bind/{flatBranchName}.flag
     - output confirmation that branch was bound

.why:
  - enforces one-behavior-per-branch discipline
  - new behaviors are immediately associated with their working branch
```

---

### 4. behaver inits (hook registration)

#### 4.1 `src/domain.roles/behaver/inits/init.claude.hooks.sh`

```
.what = register behaver hooks to claude settings
.why  = hooks must be bound to trigger on session start and compaction

.pattern = mirrors mechanic's init.claude.hooks.sh

.hooks-to-register:

  1. SessionStart hook:
     - matcher: "*"
     - command: behaver inits/claude.hooks/sessionstart.dispatch-behavior.sh
     - name: "sessionstart.dispatch-behavior"
     - timeout: 10
     - author: "repo=bhuild/role=behaver"

.note:
  - SessionStart hooks run on both session start AND compaction
  - reuse mechanic's findsert utility via symlink or copy
```

#### 4.2 `src/domain.roles/behaver/inits/init.claude.hooks.findsert.sh`

```
.option-a = symlink to mechanic's findsert (if cross-role imports allowed)
.option-b = copy mechanic's findsert with author param set to bhuild

prefer option-a for DRY, fallback to option-b if role isolation required
```

---

### 5. dispatch-behavior hooks

#### 5.1 `src/domain.roles/behaver/inits/claude.hooks/sessionstart.dispatch-behavior.sh`

```
.what = inject bound behavior context on session start
.why  = agent starts with full awareness of current behavior

.flow:
  1. get current branch name
  2. call getBoundBehaviorByBranch
     - if not bound: exit 0 silently (unbound branches work normally)
     - if multiple bindings: log warning, exit 0 (don't block session)
  3. resolve behavior directory from binding
  4. collect behavior files:
     - 0.wish.md (required if bound)
     - 1.vision.md (optional)
     - 2.criteria.md (optional)
     - 3.3.blueprint.v*.i*.md (latest, via getLatestBlueprintByBehavior, optional)
  5. output formatted context:
     ```
     ==================================================
     BOUND BEHAVIOR: v2025_12_24.dispatch-behavior-hooks
     ==================================================

     <behavior-wish path=".behavior/v.../0.wish.md">
     {content}
     </behavior-wish>

     <behavior-vision path=".behavior/v.../1.vision.md">
     {content}
     </behavior-vision>

     <behavior-criteria path=".behavior/v.../2.criteria.md">
     {content}
     </behavior-criteria>

     <behavior-blueprint path=".behavior/v.../3.3.blueprint.v1.i1.md">
     {content}
     </behavior-blueprint>

     ==================================================
     ```

.error-handling:
  - filesystem errors: log warning, continue with available files
  - never block session start (exit 0 always)
```

---

### 6. test fixtures

#### 6.1 update existing fixtures

add `.bind/` directories to test fixtures for bind/unbind testing:

```
src/domain.roles/behaver/skills/.test/assets/example.repo/
  valid-behavior/
    .behavior/
      v2025_01_01.get-weather-emoji/
        .bind/
          test-branch.flag   # for testing bound branch scenarios
```

#### 6.2 new fixture scenarios

```
bound-branch/           # branch with valid binding
unbound-branch/         # branch with no binding
multi-bound-branch/     # branch with conflicting bindings (error case)
```

---

### 7. integration tests

#### 7.1 `src/domain.roles/behaver/skills/bind.behavior.integration.test.ts`

```
test cases:
  - [case1] --set creates bind flag in correct location
  - [case2] --set when already bound to same behavior succeeds idempotently
  - [case3] --set when bound to different behavior fails fast
  - [case4] --del removes bind flag
  - [case5] --del when not bound succeeds idempotently
  - [case6] --get returns bound behavior name
  - [case7] --get when not bound returns "not bound"
  - [case8] no action flag fails fast with usage
```

#### 7.2 update `init.behavior.integration.test.ts` (if exists)

```
additional test cases:
  - [caseN] init.behavior fails fast when branch already bound
  - [caseN+1] init.behavior creates bind flag after creating behavior
```

---

## file structure (after implementation)

```
src/domain.operations/behavior/bind/
├── flattenBranchName.ts                   # new
├── getBoundBehaviorByBranch.ts            # new
└── getLatestBlueprintByBehavior.ts        # new (extracted from review.deliverable)

src/domain.roles/behaver/
├── inits/
│   ├── init.claude.hooks.sh              # hook registration
│   ├── init.claude.hooks.findsert.sh     # findsert utility
│   └── claude.hooks/
│       └── sessionstart.dispatch-behavior.sh
└── skills/
    ├── bind.behavior.sh                   # new
    ├── init.behavior.sh                   # updated
    ├── review.deliverable.sh              # existing
    └── .test/assets/example.repo/         # updated fixtures
```

---

## implementation order

1. **phase 0**: create domain operations in `src/domain.operations/behavior/bind/`
   - `flattenBranchName.ts`
   - `getBoundBehaviorByBranch.ts`
   - `getLatestBlueprintByBehavior.ts`
2. **phase 1**: create bind.behavior.sh skill
3. **phase 2**: update init.behavior.sh with binding check and auto-bind
4. **phase 3**: create behaver inits structure and hook registration
5. **phase 4**: create dispatch-behavior hooks
6. **phase 5**: update test fixtures and add integration tests
7. **phase 6**: verify end-to-end via manual testing

---

## dependencies

- requires `jq` for json manipulation (already required by mechanic)
- requires `git` for branch name detection
- reuses mechanic's findsert pattern for hook registration

---

## risk mitigation

- hooks exit 0 on any error to never block session start
- unbound branches silently skip behavior injection
- binding conflicts are detected early (in skill and init.behavior)
- all operations are idempotent
