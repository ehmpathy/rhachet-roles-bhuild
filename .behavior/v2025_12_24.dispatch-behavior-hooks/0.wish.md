wish =

that whenever a session was started OR a compaction occurred (especially compaction)

then a hook ran to inform the agent of the behavior that is currently being worked on in this branch

&&

also, so that the behavior src files were updated toe nsure that

each step of the roadmap output reminded the agent to review the behavior refs

each update to the execution output reminded the agent to review the behavior refs

---

maybe we can persist the behavior that is being worked on in a branch within the .behavior itself

e.g., a detemrinistic filename that can be found per branch

e.g.,


.behavior/*/.bind/${flattenBranchName(thisBranch)}.flag

e.g.,

.behavior/v2025_12_24.dispatch-behavior-hooks/.bind/vlad.dispatch-behavior-hooks.flag

would exist

and its existence would be used as a flag that this branch is bound to that behavior

---

then, when the hook runs, it could search for

.behavior/*/.bind/${flattenBranchName(thisBranch)}.flag

then find which behavior this branch is bound to

---

then, the hook can (on compaction + session start)

force inject into context
1. wish
2. vision (if present)
3. criteria (if present)
4. blueprint (latest version, just like the review.deliverable skill finds... we should generalize that logic and reuse it!)

that way, the builder will always has the latest contet about this behavior injected into their session

----

follow the pattern established by the ehmpathy/mechanic role for how to manage session hooks

see .agent/repo=ehmpathy/role=mechanic/inits


----


add criteria that includes a skill to bind a branch to a behavior (allow it to --set and --del the binding for the
  current branch); ensure its clear that multiple branches can be bound to the same behavior, thats not a problem. but only
  one behavior can be bound per branch; also, update the criteria to ensure that when `init.behavior` skill is run, that
  it binds teh branch that it ran from to the behavior; and also update it to failfast if the current branch is already
  bound to a behavior, as its VERY easy for a user to run `git tree set` and add a new worktree to house their new behavior
  (and is what we mandate)
