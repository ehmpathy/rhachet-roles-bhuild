# research: bhrain self-review test pattern

## critical: slugs must use dashes

**bhrain does NOT support dots in slug names.** use dashes:
- `behavior-declaration-coverage` ✓
- `behavior.declaration.coverage` ✗

dots in slugs cause bhrain to fail to recognize promises as valid.

## source

`rhachet-roles-bhrain/blackbox/driver.route.self-review.acceptance.test.ts`

fetched via: `gh api --method GET repos/ehmpathy/rhachet-roles-bhrain/contents/blackbox/driver.route.self-review.acceptance.test.ts`

## the exact pattern from bhrain

```typescript
when('[t0] pass attempted without promises', () => {
  // calls --as passed → triggers FIRST review → blocked
  const result = useThen(async () =>
    invokeRouteSkill({ as: 'passed' })  // triggers review 1
  );
});

when('[t1] first review is promised', () => {
  const result = useThen(async () => {
    // NO pass call - t0 already triggered review 1
    await backdateTriggeredReport({ slug: 'all-done' });
    return invokeRouteSkill({ as: 'promised', that: 'all-done' });
  });
});

when('[t2] second review is promised', () => {
  const result = useThen(async () => {
    // CALL --as passed to trigger review 2
    await invokeRouteSkill({ as: 'passed' });
    await backdateTriggeredReport({ slug: 'tests-pass' });
    return invokeRouteSkill({ as: 'promised', that: 'tests-pass' });
  });
});
```

## the key insight

- **t0** calls `--as passed` → creates triggered file for review 1
- **t1** does NOT call pass (review 1 already triggered) → backdate → promise
- **t2** calls `--as passed` (creates triggered file for review 2) → backdate → promise
- **tN** for N > 1: call pass → backdate → promise

## the backdateTriggeredReport helper

```typescript
const backdateTriggeredReport = async (input: {
  tempDir: string;
  stone: string;
  slug: string;
}): Promise<void> => {
  // find triggered report file
  const routeDir = path.join(input.tempDir, '.route');
  const files = await fs.readdir(routeDir).catch(() => []);
  const triggeredFile = files.find(
    (f) =>
      f.includes(`${input.stone}.guard.selfreview.${input.slug}`) &&
      f.endsWith('.triggered'),
  );
  if (triggeredFile) {
    const filepath = path.join(routeDir, triggeredFile);
    const mtimePast = new Date(Date.now() - 91 * 1000);
    await fs.utimes(filepath, mtimePast, mtimePast);
  }
};
```

## application to our test

for 4 reviews: `[coverage, adherance, standards.adherance, standards.coverage]`

1. `checkpoints.blueprintPassWithoutPromises` already calls `--as passed` → triggers review 1
2. **review 1**: backdate `coverage` → promise `coverage` (NO pass call)
3. **review 2**: pass → backdate `adherance` → promise `adherance`
4. **review 3**: pass → backdate `standards.adherance` → promise
5. **review 4**: pass → backdate `standards.coverage` → promise

## fix applied

```typescript
for (let i = 0; i < slugs.length; i++) {
  const slug = slugs[i];

  // trigger NEXT review via pass (skip for first - already triggered)
  if (i > 0) {
    try { execSync('--as passed'); } catch {}
  }

  backdateTriggeredFile({ slug });
  execSync('--as promised --that ' + slug);
}
```

## why the original loop failed

the original loop called `--as passed` on EVERY iteration, i=0 included. but for i=0, the review was already triggered by `checkpoints.blueprintPassWithoutPromises` before the loop started. a redundant pass call on i=0 did not create a new triggered file because bhrain saw the extant triggered file.

after review 1 was promised, the pass call in i=1 DOES create review 2's triggered file — but my original loop called pass BEFORE it searched for unpromised triggered files, and in i=0 this was redundant.

the fix: skip the pass call for i=0 since the first review was already triggered by the caller.
