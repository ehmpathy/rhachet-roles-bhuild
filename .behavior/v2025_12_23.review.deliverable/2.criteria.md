# usecase.1 = discover behavior by name

given('a repo with .behavior/ directory')
  when('--behavior flag matches exactly one behavior directory')
    then('behavior directory path is resolved')
      sothat('downstream operations know where to find declaration files')

given('a repo with .behavior/ directory')
  when('--behavior flag matches zero behavior directories')
    then('skill fails fast with clear error')
      sothat('user knows to check their behavior name')

given('a repo with .behavior/ directory')
  when('--behavior flag matches multiple behavior directories')
    then('skill fails fast listing the ambiguous matches')
      sothat('user can disambiguate by providing a more specific name')

given('a repo without .behavior/ directory')
  when('skill is invoked')
    then('skill fails fast with clear error')
      sothat('user knows the repo lacks behavior declarations')


# usecase.2 = resolve declaration file for review target

given('--against criteria')
  when('2.criteria.md exists in behavior directory')
    then('2.criteria.md path is resolved')
  when('2.criteria.md does not exist')
    then('skill fails fast with clear error')
      sothat('user knows to declare criteria first')

given('--against wish')
  when('0.wish.md exists in behavior directory')
    then('0.wish.md path is resolved')
  when('0.wish.md does not exist')
    then('skill fails fast with clear error')

given('--against vision')
  when('1.vision.md exists in behavior directory')
    then('1.vision.md path is resolved')
  when('1.vision.md does not exist')
    then('skill fails fast with clear error')

given('--against blueprint')
  when('multiple blueprint versions exist (e.g., v1.i1, v2.i3, v3.i2)')
    then('latest major version is selected (v3.i2 over v2.i3)')
      sothat('review uses the most evolved blueprint')
  when('single blueprint version exists')
    then('that version path is resolved')
  when('no blueprint exists')
    then('skill fails fast with clear error')

given('--against roadmap')
  when('multiple roadmap versions exist')
    then('latest major version is selected')
  when('no roadmap exists')
    then('skill fails fast with clear error')

given('--against with multiple targets (e.g., wish,vision,criteria)')
  when('all specified targets exist')
    then('all target paths are resolved')
      sothat('review can evaluate against combined context')
  when('any specified target does not exist')
    then('skill fails fast identifying the missing target')


# usecase.3 = invoke review via claude code

given('resolved behavior directory and declaration file')
  when('skill invokes claude code')
    then('prompt includes path to declaration file')
    then('prompt includes instruction to review implementation against declaration')
    then('prompt includes instruction to emit BLOCKERs and NITPICKs')
    then('prompt includes reference to feedback template format')
      sothat('robot output follows consistent structure')

given('review invoked in default mode')
  when('claude code completes')
    then('review runs non-interactively')
      sothat('skill can be automated in ci/cd pipelines')

given('review invoked with --interactive flag')
  when('claude code is spawned')
    then('claude code shell opens for user interaction')
      sothat('user can observe progress and provide guidance')


# usecase.4 = emit review feedback

given('claude code completes review')
  when('--against is a single target (e.g., blueprint)')
    then('feedback emits to 7.1.review.behavior.per_{target}.[feedback].v1.[given].by_robot.v1.md')
      sothat('output path is predictable and traceable')

given('claude code completes review')
  when('--against has multiple targets (e.g., wish,vision,criteria)')
    then('feedback emits to 7.1.review.behavior.per_{target1}_{target2}_{targetN}.[feedback].v1.[given].by_robot.v1.md')
      sothat('combined reviews have distinct output files')

given('feedback output file')
  when('file is written')
    then('file includes which skill was run to produce it')
    then('file follows .ref.[feedback].v1.[given].by_human template structure')
    then('file contains list of BLOCKERs with clear descriptions')
    then('file contains list of NITPICKs with clear descriptions')
      sothat('feedback is actionable and traceable')


# usecase.5 = skill invocation interface

given('rhachet cli')
  when('npx rhachet run --repo bhuild --skill review.deliverable --for.behavior {name} --against {target}')
    then('skill executes with provided arguments')
      sothat('invocation is consistent with rhachet conventions')

given('missing required flag --for.behavior')
  when('skill is invoked')
    then('skill fails fast with usage guidance')

given('missing required flag --against')
  when('skill is invoked')
    then('skill fails fast with usage guidance')


# usecase.6 = testability via integration test suite

given('src/domain.roles/behaver/skills/review.deliverable.integration.test.ts')
  when('test suite runs')
    then('tests invoke skill via subshell')
      sothat('skill is tested as users would invoke it')

given('test suite with example.repo fixtures')
  when('fixture has valid behavior with all declaration files')
    then('test proves skill resolves paths correctly')
    then('test proves skill invokes claude code with correct prompt')
    then('test proves skill emits feedback to correct output path')

given('test suite with example.repo fixtures')
  when('fixture has behavior with missing declaration file')
    then('test proves skill fails fast with clear error')

given('test suite with example.repo fixtures')
  when('fixture has behavior with multiple blueprint versions')
    then('test proves skill selects latest major version')

given('test suite with example.repo fixtures')
  when('fixture has ambiguous behavior name')
    then('test proves skill fails fast listing matches')
