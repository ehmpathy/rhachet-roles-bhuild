# blueprint: review.deliverable skill

## overview

implement a `review.deliverable` skill for the behaver role that invokes claude code to review implementation against behavior declarations.

follows existing patterns in:
- `src/domain.roles/behaver/skills/init.behavior.sh` - skill structure, argument parsing, fail-fast
- `src/domain.roles/behaver/getBehaverRole.ts` - role skill registration


---

## file structure

```
src/domain.roles/behaver/skills/
â”œâ”€â”€ init.behavior.sh                           # existing
â”œâ”€â”€ review.deliverable.sh                      # new: main skill entry
â”œâ”€â”€ review.deliverable.integration.test.ts     # new: integration tests
â””â”€â”€ .test/
    â””â”€â”€ assets/
        â””â”€â”€ example.repo/
            â”‚
            â”œâ”€â”€ valid-behavior/                # fixture: happy path
            â”‚   â”œâ”€â”€ .behavior/
            â”‚   â”‚   â””â”€â”€ v2025_01_01.get-weather-emoji/
            â”‚   â”‚       â”œâ”€â”€ 0.wish.md
            â”‚   â”‚       â”œâ”€â”€ 1.vision.md
            â”‚   â”‚       â”œâ”€â”€ 2.criteria.md
            â”‚   â”‚       â”œâ”€â”€ 3.3.blueprint.v1.i1.md
            â”‚   â”‚       â”œâ”€â”€ 3.3.blueprint.v2.i1.md    # version selection test
            â”‚   â”‚       â”œâ”€â”€ 4.1.roadmap.v1.i1.md
            â”‚   â”‚       â””â”€â”€ .ref.[feedback].v1.[given].by_human.md
            â”‚   â””â”€â”€ src/                       # â† deliverable implementation
            â”‚       â””â”€â”€ domain.operations/
            â”‚           â””â”€â”€ getWeatherEmoji/
            â”‚               â”œâ”€â”€ getWeatherEmoji.ts
            â”‚               â””â”€â”€ getWeatherEmoji.test.ts
            â”‚
            â”œâ”€â”€ valid-behavior-with-blocker/   # fixture: deliverable with defect
            â”‚   â”œâ”€â”€ .behavior/
            â”‚   â”‚   â””â”€â”€ v2025_01_01.get-weather-emoji/
            â”‚   â”‚       â””â”€â”€ ...                # same declarations
            â”‚   â””â”€â”€ src/
            â”‚       â””â”€â”€ domain.operations/
            â”‚           â””â”€â”€ getWeatherEmoji/
            â”‚               â””â”€â”€ getWeatherEmoji.ts  # missing snowy condition
            â”‚
            â”œâ”€â”€ missing-criteria/              # fixture: missing declaration file
            â”‚   â”œâ”€â”€ .behavior/
            â”‚   â”‚   â””â”€â”€ v2025_01_01.foo/
            â”‚   â”‚       â””â”€â”€ 0.wish.md
            â”‚   â””â”€â”€ src/
            â”‚       â””â”€â”€ foo.ts
            â”‚
            â””â”€â”€ ambiguous-behavior/            # fixture: multiple matches
                â”œâ”€â”€ .behavior/
                â”‚   â”œâ”€â”€ v2025_01_01.weather/
                â”‚   â”‚   â””â”€â”€ 0.wish.md
                â”‚   â””â”€â”€ v2025_01_02.weather/
                â”‚       â””â”€â”€ 0.wish.md
                â””â”€â”€ src/
                    â””â”€â”€ weather.ts
```


---

## skill implementation: review.deliverable.sh

### header

```sh
#!/usr/bin/env bash
######################################################################
# .what = review deliverable against behavior declarations
#
# .why  = enables automated and interactive review of implementation
#         against wish, vision, criteria, blueprint, or roadmap
#         declarations, producing structured feedback via claude code
#
# .how  = 1. resolve behavior directory from --for.behavior
#         2. resolve declaration file(s) from --against
#         3. build prompt with declaration path(s)
#         4. invoke claude code (interactive or non-interactive)
#         5. feedback emits to 7.1.review.behavior.per_{targets}.[feedback].v1.[given].by_robot.v1.md
#
# usage:
#   review.deliverable.sh --for.behavior <name> --against <target> [--interactive]
#
# examples:
#   review.deliverable.sh --for.behavior get-weather-emoji --against blueprint
#   review.deliverable.sh --for.behavior get-weather-emoji --against wish,vision,criteria
#   review.deliverable.sh --for.behavior get-weather-emoji --against blueprint --interactive
#
# guarantee:
#   - fail-fast if behavior not found or ambiguous
#   - fail-fast if declaration file(s) missing
#   - latest major version selected for versioned files (v3.i2 > v2.i3)
#   - idempotent: safe to rerun
######################################################################
```

### argument parsing

```sh
set -euo pipefail

trap 'echo "âŒ review.deliverable.sh failed at line $LINENO"' ERR

BEHAVIOR_NAME=""
AGAINST=""
INTERACTIVE=false
TARGET_DIR="$PWD"

while [[ $# -gt 0 ]]; do
  case $1 in
    --for.behavior)
      BEHAVIOR_NAME="$2"
      shift 2
      ;;
    --against)
      AGAINST="$2"
      shift 2
      ;;
    --interactive)
      INTERACTIVE=true
      shift
      ;;
    --dir)
      TARGET_DIR="$2"
      shift 2
      ;;
    --skill|--repo|--role|-s)
      # ignore rhachet passthrough args
      shift 2
      ;;
    *)
      echo "error: unknown argument '$1'"
      echo "usage: review.deliverable.sh --for.behavior <name> --against <target> [--interactive]"
      exit 1
      ;;
  esac
done

# validate required arguments
if [[ -z "$BEHAVIOR_NAME" ]]; then
  echo "error: --for.behavior is required"
  exit 1
fi
if [[ -z "$AGAINST" ]]; then
  echo "error: --against is required (wish|vision|criteria|blueprint|roadmap or comma-separated)"
  exit 1
fi
```

### behavior directory resolution

```sh
# find behavior directory matching name
BEHAVIOR_ROOT="$TARGET_DIR/.behavior"
if [[ ! -d "$BEHAVIOR_ROOT" ]]; then
  echo "error: .behavior/ directory not found in $TARGET_DIR"
  exit 1
fi

# find matching behavior directories
MATCHES=()
while IFS= read -r -d '' dir; do
  MATCHES+=("$dir")
done < <(find "$BEHAVIOR_ROOT" -maxdepth 1 -type d -name "*${BEHAVIOR_NAME}*" -print0 2>/dev/null)

if [[ ${#MATCHES[@]} -eq 0 ]]; then
  echo "error: no behavior found matching '$BEHAVIOR_NAME'"
  echo "available behaviors:"
  ls -1 "$BEHAVIOR_ROOT" 2>/dev/null | sed 's/^/  /'
  exit 1
fi

if [[ ${#MATCHES[@]} -gt 1 ]]; then
  echo "error: multiple behaviors match '$BEHAVIOR_NAME'"
  echo "matches:"
  printf '  %s\n' "${MATCHES[@]}"
  echo "please provide a more specific name"
  exit 1
fi

BEHAVIOR_DIR="${MATCHES[0]}"
BEHAVIOR_DIR_REL=$(realpath --relative-to="$PWD" "$BEHAVIOR_DIR")
```

### declaration file resolution

```sh
# map target to filename pattern
get_target_file() {
  local target="$1"
  local behavior_dir="$2"

  case "$target" in
    wish)
      echo "$behavior_dir/0.wish.md"
      ;;
    vision)
      echo "$behavior_dir/1.vision.md"
      ;;
    criteria)
      echo "$behavior_dir/2.criteria.md"
      ;;
    blueprint)
      # find latest major version: 3.3.blueprint.vN.iM.md
      find "$behavior_dir" -maxdepth 1 -name "3.3.blueprint.v*.i*.md" -print0 2>/dev/null \
        | sort -zV -t'v' -k2 \
        | tail -z -n1 \
        | tr -d '\0'
      ;;
    roadmap)
      # find latest major version: 4.1.roadmap.vN.iM.md
      find "$behavior_dir" -maxdepth 1 -name "4.1.roadmap.v*.i*.md" -print0 2>/dev/null \
        | sort -zV -t'v' -k2 \
        | tail -z -n1 \
        | tr -d '\0'
      ;;
    *)
      echo ""
      ;;
  esac
}

# resolve all targets
IFS=',' read -ra TARGETS <<< "$AGAINST"
DECLARATION_FILES=()
TARGETS_SLUG=""

for target in "${TARGETS[@]}"; do
  target=$(echo "$target" | tr -d ' ')  # trim whitespace
  file=$(get_target_file "$target" "$BEHAVIOR_DIR")

  if [[ -z "$file" ]]; then
    echo "error: unknown target '$target'"
    echo "valid targets: wish, vision, criteria, blueprint, roadmap"
    exit 1
  fi

  if [[ ! -f "$file" ]]; then
    echo "error: declaration file not found for target '$target'"
    echo "expected: $file"
    exit 1
  fi

  DECLARATION_FILES+=("$file")

  # build slug for output filename
  if [[ -n "$TARGETS_SLUG" ]]; then
    TARGETS_SLUG="${TARGETS_SLUG}_${target}"
  else
    TARGETS_SLUG="$target"
  fi
done
```

### claude code prompt construction

```sh
# build declaration paths for prompt
DECLARATION_PATHS=""
for file in "${DECLARATION_FILES[@]}"; do
  rel_path=$(realpath --relative-to="$PWD" "$file")
  DECLARATION_PATHS="${DECLARATION_PATHS}- ${rel_path}\n"
done

# output file path
OUTPUT_FILE="$BEHAVIOR_DIR/7.1.review.behavior.per_${TARGETS_SLUG}.[feedback].v1.[given].by_robot.v1.md"
OUTPUT_FILE_REL=$(realpath --relative-to="$PWD" "$OUTPUT_FILE")

# feedback template path
TEMPLATE_FILE="$BEHAVIOR_DIR/.ref.[feedback].v1.[given].by_human.md"
TEMPLATE_FILE_REL=$(realpath --relative-to="$PWD" "$TEMPLATE_FILE")

# build prompt
PROMPT=$(cat <<EOF
# review.deliverable

you are reviewing the implementation deliverable against the following behavior declaration(s):

$(echo -e "$DECLARATION_PATHS")

## instructions

1. read each declaration file listed above
2. examine the implementation (git diff from main, staged changes, unstaged changes)
3. compare implementation against the declared behaviors
4. identify BLOCKERs (must fix before merge) and NITPICKs (suggestions, non-blocking)

## output

emit your review feedback to:
- $OUTPUT_FILE_REL

follow the template structure in:
- $TEMPLATE_FILE_REL

include at the top of the output:
\`\`\`
# generated by: review.deliverable --for.behavior $BEHAVIOR_NAME --against $AGAINST
\`\`\`

then list your findings as:
- # blocker.N = description
- # nitpick.N = description

with clear explanations for each finding.

## begin review

read the declaration files now and review the implementation.
EOF
)
```

### claude code invocation

```sh
# invoke claude code
if [[ "$INTERACTIVE" == "true" ]]; then
  echo "ğŸ”­ starting interactive review..."
  echo "   behavior: $BEHAVIOR_DIR_REL"
  echo "   against: $AGAINST"
  echo "   output: $OUTPUT_FILE_REL"
  echo ""

  # interactive mode: open claude code shell
  claude --print "$PROMPT"
else
  echo "ğŸ”­ starting non-interactive review..."
  echo "   behavior: $BEHAVIOR_DIR_REL"
  echo "   against: $AGAINST"
  echo "   output: $OUTPUT_FILE_REL"

  # non-interactive mode: run to completion
  claude --print --no-input "$PROMPT"

  echo ""
  echo "âœ¨ review complete!"
  echo "   output: $OUTPUT_FILE_REL"
fi
```


---

## integration tests: review.deliverable.integration.test.ts

### test strategy

tests verify skill behavior by:
1. copying fixtures to /tmp to avoid git-within-git issues
2. initializing real git history in temp copies
3. actually invoking claude code (non-interactive mode)
4. verifying feedback output file is created with expected content

```typescript
import { execSync, spawnSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { given, when, then, useBeforeAll } from 'test-fns';

const SKILL_PATH = path.join(__dirname, 'review.deliverable.sh');
const FIXTURES_PATH = path.join(__dirname, '.test/assets/example.repo');

/**
 * .what = creates a temp copy of fixture with real git history
 * .why = avoids git-within-git issues by isolating in /tmp
 */
const prepareFixtureWithGit = (fixturePath: string): string => {
  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'review-test-'));
  execSync(`cp -r ${fixturePath}/* ${tempDir}/`);

  execSync('git init', { cwd: tempDir });
  execSync('git config user.email "test@test.com"', { cwd: tempDir });
  execSync('git config user.name "Test"', { cwd: tempDir });

  execSync('git add .behavior/', { cwd: tempDir });
  execSync('git commit -m "initial: add behavior declarations"', { cwd: tempDir });

  if (fs.existsSync(path.join(tempDir, 'src'))) {
    execSync('git checkout -b feat/implementation', { cwd: tempDir });
    execSync('git add src/', { cwd: tempDir });
    execSync('git commit -m "feat: add implementation"', { cwd: tempDir });
  }

  return tempDir;
};

describe('review.deliverable', () => {

  given('[case1] valid behavior with complete deliverable', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'valid-behavior');
      const gitRepo = prepareFixtureWithGit(fixture);
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] --against blueprint', () => {
      then('creates feedback file with review output', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'get-weather-emoji',
          '--against', 'blueprint',
          '--dir', scene.gitRepo
        ], { timeout: 120000 });  // 2 min timeout for claude

        expect(result.status).toBe(0);

        const feedbackPath = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
          '7.1.review.behavior.per_blueprint.[feedback].v1.[given].by_robot.v1.md'
        );
        expect(fs.existsSync(feedbackPath)).toBe(true);

        const content = fs.readFileSync(feedbackPath, 'utf-8');
        expect(content).toContain('generated by: review.deliverable');
      });
    });

    when('[t1] --against wish,vision,criteria', () => {
      then('creates feedback file with combined target slug', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'get-weather-emoji',
          '--against', 'wish,vision,criteria',
          '--dir', scene.gitRepo
        ], { timeout: 120000 });

        expect(result.status).toBe(0);

        const feedbackPath = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
          '7.1.review.behavior.per_wish_vision_criteria.[feedback].v1.[given].by_robot.v1.md'
        );
        expect(fs.existsSync(feedbackPath)).toBe(true);
      });
    });
  });

  given('[case2] behavior with missing declaration file', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'missing-criteria');
      const gitRepo = prepareFixtureWithGit(fixture);
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] --against criteria', () => {
      then('fails fast with clear error', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'foo',
          '--against', 'criteria',
          '--dir', scene.gitRepo
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('declaration file not found');
      });
    });
  });

  given('[case3] ambiguous behavior name', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'ambiguous-behavior');
      const gitRepo = prepareFixtureWithGit(fixture);
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] --for.behavior weather', () => {
      then('fails fast listing matches', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'weather',
          '--against', 'wish',
          '--dir', scene.gitRepo
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('multiple behaviors match');
      });
    });
  });

  given('[case4] missing required arguments', () => {
    when('[t0] missing --for.behavior', () => {
      then('fails fast with usage guidance', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--against', 'blueprint'
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('--for.behavior is required');
      });
    });

    when('[t1] missing --against', () => {
      then('fails fast with usage guidance', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'foo'
        ]);

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('--against is required');
      });
    });
  });

  given('[case5] no .behavior directory', () => {
    when('[t0] skill invoked in dir without .behavior/', () => {
      then('fails fast with clear error', () => {
        const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'no-behavior-'));

        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'anything',
          '--against', 'wish',
          '--dir', tempDir
        ]);

        fs.rmSync(tempDir, { recursive: true, force: true });

        expect(result.status).not.toBe(0);
        expect(result.stdout.toString()).toContain('.behavior/ directory not found');
      });
    });
  });

  given('[case6] deliverable with intentional blocker', () => {
    const scene = useBeforeAll(async () => {
      const fixture = path.join(FIXTURES_PATH, 'valid-behavior-with-blocker');
      const gitRepo = prepareFixtureWithGit(fixture);
      return { gitRepo };
    });

    afterAll(() => {
      fs.rmSync(scene.gitRepo, { recursive: true, force: true });
    });

    when('[t0] review executes against criteria', () => {
      then('feedback file contains blocker', () => {
        const result = spawnSync('bash', [
          SKILL_PATH,
          '--for.behavior', 'get-weather-emoji',
          '--against', 'criteria',
          '--dir', scene.gitRepo
        ], { timeout: 120000 });

        expect(result.status).toBe(0);

        const feedbackPath = path.join(
          scene.gitRepo,
          '.behavior/v2025_01_01.get-weather-emoji',
          '7.1.review.behavior.per_criteria.[feedback].v1.[given].by_robot.v1.md'
        );
        const content = fs.readFileSync(feedbackPath, 'utf-8');
        expect(content).toContain('blocker');
      });
    });
  });
});
```


---

## test fixtures

each fixture is a **complete mini git repo** with:
1. behavior declarations (the spec to review against)
2. implementation deliverables (the code being reviewed)
3. git history (main branch + feature branch with changes)

### fixture setup pattern

```sh
# each fixture is initialized as a git repo during test setup
# this enables realistic "git diff from main" behavior

setup_fixture() {
  local fixture_dir="$1"
  cd "$fixture_dir"

  # init repo with main branch containing declarations
  git init
  git add .behavior/
  git commit -m "initial: add behavior declarations"

  # create feature branch with deliverable implementation
  git checkout -b feat/get-weather-emoji
  git add src/
  git commit -m "feat: implement get-weather-emoji"
}
```

### valid-behavior fixture

```
.test/assets/example.repo/valid-behavior/
â”œâ”€â”€ .behavior/
â”‚   â””â”€â”€ v2025_01_01.get-weather-emoji/
â”‚       â”œâ”€â”€ 0.wish.md                           # "wish we had weather emoji fetcher"
â”‚       â”œâ”€â”€ 1.vision.md                         # vision statement
â”‚       â”œâ”€â”€ 2.criteria.md                       # bdd criteria
â”‚       â”œâ”€â”€ 3.3.blueprint.v1.i1.md              # older version
â”‚       â”œâ”€â”€ 3.3.blueprint.v2.i1.md              # latest version (should be selected)
â”‚       â”œâ”€â”€ 4.1.roadmap.v1.i1.md                # roadmap
â”‚       â””â”€â”€ .ref.[feedback].v1.[given].by_human.md
â”‚
â””â”€â”€ src/                                        # â† THE DELIVERABLE
    â””â”€â”€ domain.operations/
        â””â”€â”€ getWeatherEmoji/
            â”œâ”€â”€ getWeatherEmoji.ts              # implementation
            â””â”€â”€ getWeatherEmoji.test.ts         # tests
```

**deliverable contents:**

`src/domain.operations/getWeatherEmoji/getWeatherEmoji.ts`:
```ts
/**
 * .what = fetches an emoji that represents the current weather
 * .why = provides visual weather indicator for UI
 */
export const getWeatherEmoji = async (
  input: { location: string },
  context: { weatherApi: WeatherApi }
): Promise<{ emoji: string }> => {
  // fetch weather data
  const weather = await context.weatherApi.getCurrent({ location: input.location });

  // map condition to emoji
  const emoji = mapConditionToEmoji({ condition: weather.condition });

  return { emoji };
};

const mapConditionToEmoji = ({ condition }: { condition: string }): string => {
  const map: Record<string, string> = {
    sunny: 'â˜€ï¸',
    cloudy: 'â˜ï¸',
    rainy: 'ğŸŒ§ï¸',
    snowy: 'â„ï¸',
    stormy: 'â›ˆï¸',
  };
  return map[condition] ?? 'ğŸŒ¡ï¸';
};
```

**what the review validates:**
- does the deliverable match the wish (weather emoji fetcher)?
- does it follow the blueprint (input/context pattern, emoji mapping)?
- are there blockers (missing behaviors) or nitpicks (style issues)?


### valid-behavior-with-blocker fixture

same structure as `valid-behavior`, but the deliverable has an **intentional defect**:

```ts
// missing: no handling for "stormy" condition per criteria
const mapConditionToEmoji = ({ condition }: { condition: string }): string => {
  const map: Record<string, string> = {
    sunny: 'â˜€ï¸',
    cloudy: 'â˜ï¸',
    rainy: 'ğŸŒ§ï¸',
    // snowy: 'â„ï¸',  â† MISSING per blueprint
  };
  return map[condition] ?? 'ğŸŒ¡ï¸';
};
```

**expected review output:**
```md
# blocker.1

missing snow condition handling per blueprint section 3.2:
> "must support sunny, cloudy, rainy, snowy, stormy conditions"

the implementation only handles sunny, cloudy, rainy. snowy is missing.
```


### missing-criteria fixture

```
.test/assets/example.repo/missing-criteria/
â”œâ”€â”€ .behavior/
â”‚   â””â”€â”€ v2025_01_01.foo/
â”‚       â””â”€â”€ 0.wish.md                  # only wish exists, no criteria
â””â”€â”€ src/
    â””â”€â”€ foo.ts                         # deliverable exists but can't be reviewed against criteria
```


### ambiguous-behavior fixture

```
.test/assets/example.repo/ambiguous-behavior/
â”œâ”€â”€ .behavior/
â”‚   â”œâ”€â”€ v2025_01_01.weather/
â”‚   â”‚   â””â”€â”€ 0.wish.md
â”‚   â””â”€â”€ v2025_01_02.weather/
â”‚       â””â”€â”€ 0.wish.md
â””â”€â”€ src/
    â””â”€â”€ weather.ts
```


---

## version selection algorithm

for versioned files like `3.3.blueprint.vN.iM.md`:

1. find all matching files: `3.3.blueprint.v*.i*.md`
2. sort by major version (N) descending using version sort
3. select the first result (highest major version)

example: given files `v1.i1`, `v2.i3`, `v3.i2`
- sort: `v3.i2`, `v2.i3`, `v1.i1`
- select: `v3.i2`

implementation uses `sort -V` for natural version sorting.


---

## extension points

### future: brain abstraction

per wish, current implementation uses `replic:claude-code` directly.

future versions can abstract brain invocation:
```sh
BRAIN="${BRAIN:-replic:claude-code}"

case "$BRAIN" in
  replic:claude-code)
    claude --print "$PROMPT"
    ;;
  atomic:*)
    # future: direct llm invocation
    ;;
esac
```

### future: custom feedback templates

allow `--template <path>` to override default `.ref.[feedback].v1.[given].by_human.md` template.
