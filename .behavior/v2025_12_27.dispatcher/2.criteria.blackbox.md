# dispatcher role: blackbox criteria

this document describes the dispatcher role from the user's perspective: what they provide, what they receive, when they use each skill, and how the skills fulfill the core wishes.


---


## core desires

from the wish, the user wants to solve these pains:

1. **too many parallel workstreams** - hard to track what is active
2. **which is most important?** - if three are ready for review, which to prioritize first
3. **which unblocks the most?** - transitive impact via dependencies, not just direct impact
4. **what is even active?** - forget threads exist when many are open
5. **where to start?** - backlog of behaviors, unclear which to begin and in what order


---


## user inputs

### rhachet.dispatch.yml

the user provides a configuration file that declares:

```yaml
# output directory for dispatcher artifacts
output: ./.dispatch

# sources to gather behaviors from
sources:
  local:
    repos:
      - ~/code/myorg/api       # local git repo
      - ~/code/myorg/web       # another local git repo

  remote:
    repos:
      - url: github.com/myorg/myrepo
        pr_labels: [behavior]           # optional: include PRs with label
        issue_labels: [behavior.wish]   # optional: include issues as wishes

# measurement criteria
criteria:
  gain:
    yieldage:
      weights:
        direct: 1.0
        transitive: 0.5
    leverage:
      weights:
        maintenance: 1.0
        velocity: 0.8
  cost:
    weights:
      time: 1.0
      money: 0.5
      attention: 0.8

# constraints
constraints:
  maxConcurrency: 3   # how many behaviors can be "now" at once
```

### behavior directories

each behavior is a directory under `.behavior/{behaviorName}/` containing:

```
.behavior/v2025_01_01.feature-x/
  0.wish.md           # what we want
  1.vision.md         # how we see it
  2.criteria.md       # acceptance criteria
  ...
```


---


## user outputs

### prioritization output

after prioritize skill runs:

```
.dispatch/
  .gathered/          # raw behavior directories, organized by org/repo
  .deptraced/         # dependency traces per behavior
  .measured/          # scores per behavior
  .triaged/           # urgency assignments per behavior
  .archive/           # prior outputs, archived on change

  readme.md           # explains output structure and cache behavior
  prioritization.md   # human-readable summary (tables by urgency)
  prioritization.json # machine-readable data
  dependencies.md     # dependency tree per behavior
```

**readme.md contents:**

```markdown
# .dispatch output

this directory contains dispatcher skill outputs.

## cache behavior

the .* directories (.gathered/, .deptraced/, .measured/, .triaged/) are caches.
they are reused in subsequent invocations to maximize efficiency:

- only behaviors with changed contentHash are reprocessed
- unchanged behaviors reuse cached results
- delete a .* directory to force recomputation of that stage

## archive behavior

when outputs change, prior versions are archived to .archive/:

- files are named {filename}.{isoTimestamp}.bak.md
- unchanged runs do not create archives
- archives are sorted by timestamp (ls shows history)

## files

- prioritization.md: human-readable summary of triaged behaviors
- prioritization.json: machine-readable data for downstream tools
- dependencies.md: dependency tree per behavior
- coordination.md: workstream map (after coordinate skill)
- coordination.json: machine-readable workstream data
```

**prioritization.md example:**

```markdown
# prioritization

## now (3 behaviors)

| behavior                   | repo      | priority | gain | cost | decision | readiness | bandwidth |
| -------------------------- | --------- | -------- | ---- | ---- | -------- | --------- | --------- |
| v2025_01_01.auth-flow      | myorg/api | p0       | 102  | 25   | 4.08     | now       | now       |
| v2025_01_01.cache-layer    | myorg/api | p1       | 108  | 27   | 4.00     | now       | now       |
| v2025_01_01.error-handling | myorg/api | p1       | 66   | 22   | 3.00     | now       | now       |

## soon (5 behaviors)

| behavior            | repo      | priority | gain | cost | decision | readiness | bandwidth |
| ------------------- | --------- | -------- | ---- | ---- | -------- | --------- | --------- |
| v2025_01_01.metrics | myorg/api | p3       | 72   | 20   | 3.60     | now       | soon      |
| v2025_01_01.logging | myorg/api | p3       | 63   | 17   | 3.71     | soon      | soon      |
...

## later (12 behaviors)

...
```

**dependencies.md example:**

```markdown
# dependencies

## v2025_01_01.auth-flow
depends on: (none)

## v2025_01_01.session-mgmt
depends on:
  - v2025_01_01.auth-flow (now)

## v2025_01_01.oauth-integration
depends on:
  - v2025_01_01.session-mgmt (blocked)
    - v2025_01_01.auth-flow (now)

## v2025_01_01.cache-layer
depends on:
  - v2025_01_01.auth-flow (now)

## v2025_01_01.query-optimization
depends on:
  - v2025_01_01.cache-layer (now)
    - v2025_01_01.auth-flow (now)
  - v2025_01_01.session-mgmt (blocked)
    - v2025_01_01.auth-flow (now)

## v2025_01_01.alerting
depends on:
  - v2025_01_01.metrics (soon)
    - v2025_01_01.error-handling (now)
  - v2025_01_01.logging (soon)

## v2025_01_01.logging
depends on: (none)
```

### coordination output

after coordinate skill runs:

```
.dispatch/
  coordination.md     # human-readable workstream map
  coordination.json   # machine-readable data
```

**coordination.md example:**

```markdown
# coordination

## rank 1: auth foundation
priority: p0 (critical)

1. [now] v2025_01_01.auth-flow (myorg/api)
2. [blocked by #1] v2025_01_01.session-mgmt (myorg/api)
3. [blocked by #2] v2025_01_01.oauth-integration (myorg/api)

## rank 2: performance
priority: p1 (important)

1. [now] v2025_01_01.cache-layer (myorg/api)
2. [blocked by #1] v2025_01_01.query-optimization (myorg/api)

## rank 3: observability
priority: p3 (desired)

1. [now] v2025_01_01.error-handling (myorg/api)
2. [soon] v2025_01_01.metrics (myorg/api)
3. [blocked by #2] v2025_01_01.alerting (myorg/api)

## bottlenecks

- rank 2 blocked on rank 1 at step 2 (cache-layer depends on auth-flow)

## review order

if multiple workstreams blocked on human review, review in rank order:
1. rank 1 (p0 = critical)
2. rank 2 (p1 = important)
3. rank 3 (p3 = desired)
```


---


## skill invocations

### prioritize (composite)

runs the full pipeline: gather â†’ deptrace â†’ measure â†’ triage

```bash
npx rhachet run --repo bhuild --skill prioritize
```

(uses `./rhachet.dispatch.yml` by default; override with `--per-config ./other.yml`)

**when to use:**
- start of a new plan session
- backlog has changed (new behaviors added, behaviors completed)
- want fresh prioritization of all work

**fulfills wishes:**
- "where to start?" â†’ triaged output shows now/soon/later
- "which is most important?" â†’ decision = gain.composite / cost.composite ranks behaviors
- "which unblocks the most?" â†’ gain.yieldage includes transitive impact


### coordinate

groups triaged behaviors into parallel workstreams

```bash
npx rhachet run --repo bhuild --skill coordinate
```

**when to use:**
- after prioritize, to see how work can run in parallel
- to assign work to multiple agents/people
- when blocked and need to decide which workstream to unblock first

**fulfills wishes:**
- "too many parallel workstreams" â†’ workstreams are enumerated and labeled
- "what is even active?" â†’ workstream map shows all active work
- "if three are ready for review, which first?" â†’ review priority section answers this


### individual skills (atomic)

for incremental updates or debug:

```bash
# just gather
npx rhachet run --repo bhuild --skill gather

# just deptrace (requires gathered output)
npx rhachet run --repo bhuild --skill deptrace

# just measure (requires gathered + deptraced output)
npx rhachet run --repo bhuild --skill measure

# just triage (requires measured output)
npx rhachet run --repo bhuild --skill triage
```

**when to use:**
- debug: run individual stages to inspect intermediate outputs
- incremental: only re-run stages that need update


---


## use case flows

### usecase: "i have a backlog, where do i start?"

1. create `rhachet.dispatch.yml` with sources
2. run `prioritize` skill
3. read `prioritization.md` â†’ behaviors sorted by urgency (now/soon/later)
4. start with first "now" behavior

**wish fulfilled:** "when we have a backlog of behaviors to buildout, hard to remember which ones to even start! and in what order!"


### usecase: "three behaviors ready for review, which first?"

1. run `coordinate` skill (or check existing `coordination.md`)
2. check workstream ranks
3. review workstream with lowest rank number (rank 1 before rank 2 before rank 3)

**wish fulfilled:** "if three are ready for review, which one to prioritize first?"


### usecase: "which behavior unblocks the most work?"

1. run `prioritize` skill
2. check `prioritization.md` â†’ behaviors with highest yieldage include transitive impact
3. alternatively, check `coordination.md` â†’ bottleneck section shows blocker relationships

**wish fulfilled:** "which ones block others? which one will unblock the most leverage?"


### usecase: "what workstreams are active?"

1. run `coordinate` skill
2. read `coordination.md` â†’ all workstreams enumerated with status

**wish fulfilled:** "which ones are even active and should be checked on?"


### usecase: "a behavior was completed, update priorities"

1. mark behavior as done (add status=delivered to behavior docs)
2. run `prioritize` skill â†’ idempotent, only recomputes changed behaviors
3. completed behavior moves to "delivered" status, no longer in now/soon/later

**wish fulfilled:** cache artifacts along the way; only recompute what changed


### usecase: "run repeatedly, see progress"

**first run (no prior state):**
```bash
$ npx rhachet run --repo bhuild --skill prioritize

ğŸ¦« lets prioritize!
â”‚
â”œâ”€ ğŸŒ² gather behaviors
â”‚  â”œâ”€ âœ“ done in 1.2s
â”‚  â”œâ”€ 3 repos scanned
â”‚  â”œâ”€ 12 behaviors found
â”‚  â””â”€ 12 behaviors changed
â”‚     â”œâ”€ + v2025_01_01.auth-flow
â”‚     â”œâ”€ + v2025_01_01.cache-layer
â”‚     â”œâ”€ + v2025_01_01.error-handling
â”‚     â””â”€ ... (9 more)
â”‚
â”œâ”€ ğŸŒ² deptrace dependencies
â”‚  â”œâ”€ âœ“ done in 3.4s
â”‚  â”œâ”€ 12 behaviors traced
â”‚  â””â”€ 12 new, 0 cached
â”‚
â”œâ”€ ğŸŒ² measure behaviors
â”‚  â”œâ”€ âœ“ done in 2.1s
â”‚  â”œâ”€ 12 behaviors measured
â”‚  â””â”€ 12 new, 0 cached
â”‚
â”œâ”€ ğŸŒ² triage behaviors
â”‚  â”œâ”€ âœ“ done in 0.3s
â”‚  â”œâ”€ 12 behaviors triaged
â”‚  â””â”€ 3 now, 5 soon, 4 later
â”‚
â””â”€ ğŸŒŠ output
   â”œâ”€ .dispatch/prioritization.md
   â”œâ”€ .dispatch/prioritization.json
   â””â”€ .dispatch/dependencies.md
```

note: while running, âœ“ shows as a spinner until complete
note: + = created, ~ = updated

**second run (no changes):**
```bash
$ npx rhachet run --repo bhuild --skill prioritize

ğŸ¦« lets prioritize!
â”‚
â”œâ”€ ğŸŒ² gather behaviors
â”‚  â”œâ”€ âœ“ done in 0.8s
â”‚  â”œâ”€ 3 repos scanned
â”‚  â”œâ”€ 12 behaviors found
â”‚  â””â”€ 0 behaviors changed
â”‚
â”œâ”€ ğŸŒ² deptrace dependencies
â”‚  â”œâ”€ âœ“ done in 0.1s
â”‚  â”œâ”€ 12 behaviors traced
â”‚  â””â”€ 0 new, 12 cached
â”‚
â”œâ”€ ğŸŒ² measure behaviors
â”‚  â”œâ”€ âœ“ done in 0.1s
â”‚  â”œâ”€ 12 behaviors measured
â”‚  â””â”€ 0 new, 12 cached
â”‚
â”œâ”€ ğŸŒ² triage behaviors
â”‚  â”œâ”€ âœ“ done in 0.1s
â”‚  â”œâ”€ 12 behaviors triaged
â”‚  â””â”€ 3 now, 5 soon, 4 later (unchanged)
â”‚
â””â”€ ğŸŒŠ output (unchanged)
   â”œâ”€ .dispatch/prioritization.md
   â”œâ”€ .dispatch/prioritization.json
   â””â”€ .dispatch/dependencies.md
```

**third run (2 behaviors changed):**
```bash
$ npx rhachet run --repo bhuild --skill prioritize

ğŸ¦« lets prioritize!
â”‚
â”œâ”€ ğŸŒ² gather behaviors
â”‚  â”œâ”€ âœ“ done in 0.9s
â”‚  â”œâ”€ 3 repos scanned
â”‚  â”œâ”€ 12 behaviors found
â”‚  â””â”€ 2 behaviors changed
â”‚     â”œâ”€ ~ v2025_01_01.auth-flow (.content.hash = 3azd7... â†’ 12931x...)
â”‚     â””â”€ ~ v2025_01_01.metrics (.status = active â†’ delivered)
â”‚
â”œâ”€ ğŸŒ² deptrace dependencies
â”‚  â”œâ”€ âœ“ done in 0.6s
â”‚  â”œâ”€ 12 behaviors traced
â”‚  â””â”€ 2 new, 10 cached
â”‚
â”œâ”€ ğŸŒ² measure behaviors
â”‚  â”œâ”€ âœ“ done in 0.4s
â”‚  â”œâ”€ 12 behaviors measured
â”‚  â””â”€ 2 new, 10 cached
â”‚
â”œâ”€ ğŸŒ² triage behaviors
â”‚  â”œâ”€ âœ“ done in 0.2s
â”‚  â”œâ”€ 11 behaviors triaged
â”‚  â”œâ”€ 3 now, 4 soon, 4 later
â”‚  â””â”€ 2 behaviors changed
â”‚     â”œâ”€ ~ v2025_01_01.metrics (.status = active â†’ delivered)
â”‚     â””â”€ ~ v2025_01_01.session-mgmt (.urgency = soon â†’ now)
â”‚
â”œâ”€ ğŸ•ï¸ archived
â”‚  â”œâ”€ .dispatch/.archive/prioritization.2025-01-15T14:32:01Z.bak.md
â”‚  â””â”€ .dispatch/.archive/dependencies.2025-01-15T14:32:01Z.bak.md
â”‚
â””â”€ ğŸŒŠ output
   â”œâ”€ .dispatch/prioritization.md
   â”œâ”€ .dispatch/prioritization.json
   â””â”€ .dispatch/dependencies.md
```

**coordinate after prioritize:**
```bash
$ npx rhachet run --repo bhuild --skill coordinate

ğŸ¦« lets coordinate!
â”‚
â”œâ”€ ğŸŒ² coordinate workstreams
â”‚  â”œâ”€ âœ“ done in 0.5s
â”‚  â”œâ”€ 7 behaviors grouped into 3 workstreams
â”‚  â””â”€ 1 bottleneck detected
â”‚
â”œâ”€ ğŸ•ï¸ archived
â”‚  â””â”€ .dispatch/.archive/coordination.2025-01-15T14:32:05Z.bak.md
â”‚
â””â”€ ğŸŒŠ output
   â”œâ”€ .dispatch/coordination.md
   â””â”€ .dispatch/coordination.json
```


---


## how skills fulfill wishes

| wish                       | skill      | how                                                     |
| -------------------------- | ---------- | ------------------------------------------------------- |
| "where to start?"          | prioritize | triage assigns now/soon/later urgency                   |
| "which is most important?" | prioritize | decision = gain.composite / cost.composite              |
| "which unblocks the most?" | prioritize | gain.yieldage includes transitive dependent impact      |
| "too many workstreams"     | coordinate | workstreams enumerated and labeled with priority        |
| "what is even active?"     | coordinate | workstream map shows all active behaviors               |
| "which to review first?"   | coordinate | workstreams ranked; review in rank order                |
| "cache artifacts"          | all skills | idempotent; only recompute if contentHash changed       |
| "parallelize work"         | coordinate | independent behaviors grouped into parallel workstreams |


---


## what's NOT in scope (future wishes)

per the wish, these are declared for future reference but not in scope:

1. **orchestration** - dispatcher drives behavior construction (invokes builder, then reviewer)
2. **notification** - watch progress and notify user when ready for next step
3. **remote execution** - reviews done entirely via github.ui + slack.ui without local clone
