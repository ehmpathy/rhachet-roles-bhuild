wish =

we had a skill that helped us prioritize & paralellize & drive work forward

---

pain.before =

- too many parallel workstreams
- difficult to remember
  - which ones are most important (i.e., if three are ready for review, which one to prioritize first?)
  - which ones block others? (i.e., if three are ready for review, which one will unblock the most leverage? similar to prioritization, except includes dependent impact - not just direct impact)
  - which ones are even running and should be checked on? (i.e., if 7 threads are open, forget that there's a thread at the top)

also,

when we have a backlog of behaviors to buildout, hard to remember which ones to even start! and in what order!

---

ideally, we'd have a dispatcher role which could


### skill1 = <prioritize>

1. gather the desired behaviors;
  - e.g., look at all of the behaviors in a dir of git repos (and eventually, from remote repos too; maybe also from issues or prs labeled with 'behavior')
  - e.g.,
    - from local dir sources (dir[] that has many git.repos per dir)
    - from remote git sources (eg. org or repo url)
      - direct in the .behavior folder per remote repo
      - OR
      - via prs labeled with 'behavior', in their '.behavior' forlder
      - OR
      - via issues labeled with 'behavior.wish', where the content of the issue = the wish
  - and filter out the ones that were already completed
    - if there's a flag that says "done" on the behavior, then its done
  - e.g., input.sources

2. measure the behaviors
   1. against explicitly declared values or criteria (todo: decide on term), prioritize the behaviors
   2. which are most important... directly? via depdnencies? via leverage? etc
   3. which are most expensive... time? money? thought? repute? etc

3. triage the behaviors
   1. which ones are "later"
   2. which ones are "soon"
   3. which ones are "now"

return a clearly readable md (and machine usable json) of the prioritization of the tasks

ideally, this would be decomposed into a maximally rigid thoughtroute
- rigid =
  - maximally leverages determinisim along the way; minimizes need to callout to probabalistic brains
  - does leverage them at key boundaries (e.g., brain.repl=claude-code)
  - but leverages them from a deterministic wrapper; determinsitic skill _invokes_ a brain in order to execute subtasks

however, enables interactive mode to be invoked when needed
- so that if user decides they want to hand-tune some outputs, can
- 1. bootup the same briefs that the invoked brain.repl used (reuires the briefs that the role is invoked with to be clearly declared and the role to be bootable via rhachet)
- 2. talk to the brain.repl directly

e.g.,
1. gather sources = deterministic
2. measure behaviors = probabilistic (but given the deterministic inputs of source.behaviors && criteria)
3. triage behaviors = deterministic (given the measurements, should be able to compute which ones are done when algorithmically; no need for creatively via brain.repl + language)

---


### skill2 = <coordinate>

coordinate the behaviors
1. out of the "now" and "soon" trigaged behaviors
2. what concurent streams can they be done in? => maximally parallelize them
3. label them with clear highlevel priority levels against which we can rapidly assess "which one is most important"
   1. p0 = critical; life or death; nothing else matters if this isn't done
   2. p1 = important; this is required to do
   3. p3 = desired; we want to do this, but things can launch without it
   4. p5 = bonus; it'd be nice to have, but no complaints if not there

(note, we prefer ODD numbers exclusively)


the goal output here is to get a clear breakdown of

1. what work can be done in independent streams?
2. when do the streams intersect due to dependencies? (i.e., when will stream 3 be blocked on stream 2?)


and!

easily answer

if streams 3 and 2 are both ready for review (blocked on human), then which one to look at first?


----

later, we'll want to support

1. orchestration =>
  - e.g. the dispatcher actually driving the behavior construction (e.g., robot:actor:builder said they were done, invoke robot:actor:reviewer against it)
    - ref: actor = synonym for brain.repl, as defined in rhachet-roles-bhrain
  - that way the human is only notified of a blocker when all robot actions have completed maximally
  - &&
  - the human can be sure that all reviews were explicitly executed before they are called (no chanceof the robot:actor:builder saying they were done and not invoking review)

  - && ideally orchestration against remote machines, so that reviews can be done entirely via github.ui && slack.ui
    - with need to clone repo locally = only in rare circumstance


2. notification
   1. e.g., the dispatcher will watch progress of execution and actually notify the user when ready for the next step
      1. e.g. poll every minute across all configured sources && notify when the robot:actor:builder (brain.repl) has halted


where notification will probably come before orchestration


however, notification and orchestration skills are not in scope for this wish. this is just a declaration for future reference


-------


also,  add criteria that clarifies its important to cache the artifacst that are produced
along the way. e.g., if already fetched info about a repo, no need to do it again - just
check the cache about whether the repo had any changes since we last evaluated; same for
measurement. if we decompose the measurement of each behavior independently, then we can
cache whether we need to recompute the measurement or reuse it - and we can also
parallelize it (e.g., run X measuremements concurrently; each one of them
with-simple-cache against simple-on-disk-cache which only remeasures if content hash has
changed on the input files for the behavior)
