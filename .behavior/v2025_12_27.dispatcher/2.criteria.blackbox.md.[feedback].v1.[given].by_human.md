show how prioritize and coordinate can be run repeatedly
and - if no changes, produces same result idempotently - but
when has changes, shows progress. also, add criteria that we
.archive the old results as we invalidate them (i.e., move to
 .archive dir w/ .$timestamp.bak.md)


----

also, update the 2.criteria.md to declare dimensions of cost,
  like it declares dimensions of gain; cost can probably best
  be measured in terms of - how complicated is it, how testable
  the feedback loop is (i.e., human required? needs new test
  framework? reuses existing?)

what are the best dimensions to measure cost against?


---

review workstream with highest (priority × yieldage) ;
priority should have already considered yieldage and leverage
 before being written; we should simply be able to look a t
priority label



---

also, the measure skill should label that priorty already
too - and the coordinate skill should be able to just
leverage that; priority is not relative, its absolute;
multiple things can be at the same priority level

---

 we should separately have a _rank_ which specifies which
priorities are most important. that should be assigned at the
 workstream level. the rank declares the relative order of
importance



----


update .behavior/v2025_12_27.dispatcher/2.criteria.blackbox.md

to conform to the domain research outcomes in .behavior/v2025_12_27.dispatcher/3.1.research.domain.leverage.v9.i1.md

---

> update gain to decompose into gain.time (via leverage) and
cash (via yieldage) ; no composite across leverage and
yieldage ; also, decomopse cost against time and cash too


---

 ensure that prioritize is coherently cited as considering
  both leverage and yieldage in prioritization; and that we
  should be able to update the config.yml to convert time into
  money to enable absolute comparison

equate time is money

----


> is the rest of the doc coherent with that? that everything
is aboslutely comparable? in prioritization via measure
operation, which distills everything into an absolute metric
of gain($$$) via leverage or yieldage  - cost($$$) via attend
 and expend ?

 (attend - time cost, expend - cash cost)


----


gain($)** = leverage (time saved) + yieldage (value produced) → converted to $$$

=>

leverage (time gained) (time can only be saved)

yieldage (cash gained) (cash can both be saved or earned)


---

 why is there a weight on cost.attend.weight and
  cost.expend.weight?

---


| behavior                   | repo      | priority | gain($) | cost($) | value($) | readiness | bandwidth |
| -------------------------- | --------- | -------- | ------- | ------- | -------- | --------- | --------- |
| v2025_01_01.auth-flow      | myorg/api | p0       | 6360    | 1813    | +4547    | now       | now       |
| v2025_01_01.cache-layer    | myorg/api | p1       | 7260    | 2113    | +5147    | now       | now       |
| v2025_01_01.error-handling | myorg/api | p1       | 4536    | 1661    | +2875    | now       | now       |

## soon (5 behaviors)

| behavior            | repo      | priority | gain($) | cost($) | value($) | readiness | bandwidth |
| ------------------- | --------- | -------- | ------- | ------- | -------- | --------- | --------- |
| v2025_01_01.metrics | myorg/api | p3       | 4840    | 1510    | +3330    | now       | soon      |
| v2025_01_01.logging | myorg/api | p3       | 4235    | 1209    | +3026    | soon      | soon      |
...


what is value? call it effect($)

also, in the table, each number should have $ and be formatted for ease to read

---

- "which unblocks the most?" → gain($) includes yieldage (transitive impact)

should consider both gains. yieldage AND leverage; direct AND transitive

behaviors can unblock levers; levers can unblock levers; not only yield is transitive
