# domain distillation: dispatcher role v2

this document declares the domain model for the dispatcher role, enabling prioritization and coordination of behaviors across repositories.

---

## 1. usecases and contracts

### 1.1 usecase: prioritize backlog

**user story**: as a developer with many behaviors to build, i want to see which ones to work on first, so i can maximize impact.

**contract**:
```ts
// input: rhachet.dispatch.yml config
// output: prioritization.md, prioritization.json, dependencies.md

const result = await prioritizeBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorPrioritizeResult {
  behaviors: BehaviorTriaged[];
  outputs: {
    prioritizationMd: string;   // .dispatch/prioritization.md
    prioritizationJson: string; // .dispatch/prioritization.json
    dependenciesMd: string;     // .dispatch/dependencies.md
  };
}
```

### 1.2 usecase: coordinate workstreams

**user story**: as a team lead with multiple parallel workstreams, i want to see how work can be organized and which workstreams to prioritize for review.

**contract**:
```ts
// input: triaged behaviors (from prioritize)
// output: coordination.md, coordination.json

const result = await coordinateBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorCoordinateResult {
  workstreams: BehaviorWorkstream[];
  outputs: {
    coordinationMd: string;   // .dispatch/coordination.md
    coordinationJson: string; // .dispatch/coordination.json
  };
}
```

### 1.3 usecase: gather behaviors

**user story**: as a dispatcher skill, i need to collect all behaviors from configured sources to analyze them.

**contract**:
```ts
// input: sources from config
// output: .gathered/*.gathered.json per behavior

const result = await gatherBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorGatherResult {
  behaviors: BehaviorGathered[];
  stats: {
    reposScanned: number;
    behaviorsFound: number;
    behaviorsChanged: number;
  };
}
```

### 1.4 usecase: trace dependencies

**user story**: as a dispatcher skill, i need to trace which behaviors depend on which others to compute transitive impact.

**contract**:
```ts
// input: gathered behaviors
// output: .deptraced/*.deptraced.json per behavior, dependencies.md

const result = await deptraceBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorGathered[],
}, context);

// result shape
interface BehaviorDeptraceResult {
  behaviors: BehaviorDeptraced[];
  outputs: {
    dependenciesMd: string; // .dispatch/dependencies.md
  };
  stats: {
    all: number;
  };
}
```

### 1.5 usecase: measure behaviors

**user story**: as a dispatcher skill, i need to score behaviors by yieldage, leverage, and cost to determine priority.

**contract**:
```ts
// input: deptraced behaviors
// output: .measured/*.measured.json per behavior

const result = await measureBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorDeptraced[],
}, context);

// result shape
interface BehaviorMeasureResult {
  behaviors: BehaviorMeasured[];
  stats: {
    all: number;
  };
}
```

### 1.6 usecase: triage behaviors

**user story**: as a dispatcher skill, i need to assign urgency (now/soon/later) based on readiness and bandwidth constraints.

**contract**:
```ts
// input: measured behaviors
// output: .triaged/*.triaged.json per behavior

const result = await triageBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorMeasured[],
}, context);

// result shape
interface BehaviorTriageResult {
  behaviors: BehaviorTriaged[];
  stats: {
    all: number;
    now: number;
    soon: number;
    later: number;
  };
}
```

---

## 2. domain.objects

### 2.1 entities

#### Behavior

the root domain entity representing a behavior being tracked.

```ts
interface Behavior {
  /**
   * organization or owner of the repo
   */
  org: string;

  /**
   * repository name
   */
  repo: string;

  /**
   * behavior directory name (e.g., "v2025_01_01.auth-flow")
   */
  name: string;
}

class Behavior extends DomainEntity<Behavior> {
  public static unique = ['org', 'repo', 'name'] as const;
}
```

#### BehaviorGathered

represents a behavior after collection from source repositories.

```ts
interface BehaviorGathered {
  /**
   * reference to the behavior being gathered
   */
  behavior: RefByUnique<typeof Behavior>;

  /**
   * sha256 hash of behavior directory contents
   * computed at gather time, reused downstream for cache invalidation
   */
  contentHash: string;

  /**
   * current status of the behavior
   */
  status: BehaviorGatheredStatus;

  /**
   * files within the behavior directory
   */
  files: BehaviorFile[];

  /**
   * parsed wish document content (0.wish.md)
   */
  wish: string | null;

  /**
   * parsed vision document content (1.vision.md)
   */
  vision: string | null;

  /**
   * parsed criteria document content (2.criteria.md)
   */
  criteria: string | null;

  /**
   * timestamp when gathered
   */
  gatheredAt: string;
}

class BehaviorGathered extends DomainEntity<BehaviorGathered> {
  public static unique = ['behavior'] as const;
}
```

#### BehaviorDeptraced

represents a behavior after dependency analysis.

```ts
interface BehaviorDeptraced {
  /**
   * reference to the behavior being deptraced
   */
  behavior: RefByUnique<typeof Behavior>;

  /**
   * content hash from gathered behavior (for cache key)
   */
  contentHash: string;

  /**
   * behaviors this one directly depends on
   */
  dependsOnDirect: RefByUnique<typeof Behavior>[];

  /**
   * all behaviors this one depends on (transitive closure)
   */
  dependsOnTransitive: RefByUnique<typeof Behavior>[];

  /**
   * timestamp when deptraced
   */
  deptracedAt: string;
}

class BehaviorDeptraced extends DomainEntity<BehaviorDeptraced> {
  public static unique = ['behavior'] as const;
}
```

#### BehaviorMeasured

represents a behavior after measurement scoring.

```ts
interface BehaviorMeasured {
  /**
   * reference to the behavior being measured
   */
  behavior: RefByUnique<typeof Behavior>;

  /**
   * content hash from gathered behavior (for cache key)
   */
  contentHash: string;

  /**
   * gain: value gained by completing this behavior
   * gain(+$) = leverage + yieldage → converted to $$
   */
  gain: {
    dimensions: {
      /**
       * leverage = time gained (time can only be saved)
       * includes transitive impact from unblocked behaviors
       * see: 3.1.research.domain.leverage.v9.i1.md
       */
      leverage: BehaviorMeasuredGainLeverage;
      /**
       * yieldage = cash gained (cash can be saved or earned)
       * includes transitive impact from unblocked behaviors
       */
      yieldage: BehaviorMeasuredGainYieldage;
    };
    /**
     * composite gain in $$ (leverage + yieldage converted via convert.equate)
     */
    composite: number;
  };

  /**
   * cost: resources required to complete this behavior
   * cost(-$) = attend + expend → converted to $$
   */
  cost: {
    dimensions: {
      /**
       * attend = time cost (attention)
       */
      attend: BehaviorMeasuredCostAttend;
      /**
       * expend = cash cost (expenditure)
       */
      expend: BehaviorMeasuredCostExpend;
    };
    /**
     * composite cost in $$ (attend + expend converted via convert.equate)
     */
    composite: number;
  };

  /**
   * effect(~$) = gain.composite - cost.composite
   * absolute comparable metric; higher = more net value
   */
  effect: number;

  /**
   * assigned priority level: p0, p1, p3, p5
   */
  priority: BehaviorMeasuredPriorityLevel;

  /**
   * timestamp when measured
   */
  measuredAt: string;
}

class BehaviorMeasured extends DomainEntity<BehaviorMeasured> {
  public static unique = ['behavior'] as const;
}
```

#### BehaviorTriaged

represents a behavior after urgency assignment.

```ts
interface BehaviorTriaged {
  /**
   * reference to the behavior being triaged
   */
  behavior: RefByUnique<typeof Behavior>;

  /**
   * content hash from gathered behavior (for cache key)
   */
  contentHash: string;

  /**
   * triage dimensions
   */
  dimensions: {
    /**
     * readiness level: now | soon | later | blocked
     * based on dependency status
     */
    readiness: BehaviorTriagedReadinessLevel;
    /**
     * bandwidth level: now | soon | later
     * based on concurrency constraints
     */
    bandwidth: BehaviorTriagedBandwidthLevel;
  };

  /**
   * decision = min(readiness, bandwidth)
   * determines urgency bucket
   */
  decision: BehaviorTriagedUrgencyLevel;

  /**
   * priority from measurement (carried forward)
   */
  priority: BehaviorMeasuredPriorityLevel;

  /**
   * timestamp when triaged
   */
  triagedAt: string;
}

class BehaviorTriaged extends DomainEntity<BehaviorTriaged> {
  public static unique = ['behavior'] as const;
}
```

#### BehaviorWorkstream

represents a grouping of related behaviors into a parallelizable workstream.

```ts
interface BehaviorWorkstream {
  /**
   * workstream identifier
   */
  id: string;

  /**
   * human-readable name (e.g., "auth foundation")
   */
  name: string;

  /**
   * rank for prioritization (1 = highest)
   */
  rank: number;

  /**
   * aggregate priority of behaviors in workstream
   */
  priority: BehaviorMeasuredPriorityLevel;

  /**
   * ordered behaviors in this workstream
   * order reflects dependency chain
   */
  behaviors: BehaviorWorkstreamEntry[];

  /**
   * bottlenecks affecting this workstream
   */
  bottlenecks: BehaviorWorkstreamBottleneck[];
}

class BehaviorWorkstream extends DomainEntity<BehaviorWorkstream> {
  public static primary = ['id'] as const;
  public static unique = ['name'] as const;
}
```

### 2.2 literals

#### BehaviorFile

a file within a behavior directory.

```ts
interface BehaviorFile {
  /**
   * relative path within behavior directory
   */
  path: string;

  /**
   * file content (for relevant files like 0.wish.md)
   */
  content: string | null;
}

class BehaviorFile extends DomainLiteral<BehaviorFile> {}
```

#### BehaviorMeasuredGainLeverage

leverage measurement capturing time saved (per 3.1.research.domain.leverage.v9.i1.md).

```ts
interface BehaviorMeasuredGainLeverage {
  /**
   * author leverage = time saved to create ("add behavior")
   * measured in minutes saved per use
   */
  author: number;

  /**
   * support leverage = time saved to operate ("fix behavior")
   * measured in minutes saved per failure
   */
  support: number;

  /**
   * composite leverage in minutes/week
   * = (author × freq) + (support × fail.rate)
   */
  composite: number;

  /**
   * transitive leverage from unblocked behaviors
   * = sum of leverage.composite from behaviors this one unblocks
   */
  transitive: number;
}

class BehaviorMeasuredGainLeverage extends DomainLiteral<BehaviorMeasuredGainLeverage> {}
```

#### BehaviorMeasuredGainYieldage

probabilistic yield model capturing cash gained (can be saved or earned).

```ts
interface BehaviorMeasuredGainYieldage {
  /**
   * possible yield outcomes with probabilities
   * each chance represents a possible outcome
   * failure is captured as { yieldage: 0, probability: P }
   */
  chances: BehaviorMeasuredGainYieldageChance[];

  /**
   * expected value = sum(yieldage * probability)
   * weighted sum of chances
   */
  expected: number;

  /**
   * transitive yieldage from unblocked behaviors
   * = sum of yieldage.expected from behaviors this one unblocks
   */
  transitive: number;
}

interface BehaviorMeasuredGainYieldageChance {
  /**
   * yield value in $$
   * 0 = failure/no value delivered
   */
  yieldage: number;

  /**
   * probability of this outcome (0-1)
   */
  probability: number;
}

class BehaviorMeasuredGainYieldage extends DomainLiteral<BehaviorMeasuredGainYieldage> {
  public static nested = { chances: DomainLiteral };
}
```

#### BehaviorMeasuredCostAttend

time cost measurement (attention required).

```ts
interface BehaviorMeasuredCostAttend {
  /**
   * estimated hours to complete this behavior
   */
  hours: number;

  /**
   * complexity factor (1.0 = normal, >1 = more complex)
   */
  complexity: number;

  /**
   * composite time cost in hours
   * = hours × complexity
   */
  composite: number;
}

class BehaviorMeasuredCostAttend extends DomainLiteral<BehaviorMeasuredCostAttend> {}
```

#### BehaviorMeasuredCostExpend

cash cost measurement (expenditure required).

```ts
interface BehaviorMeasuredCostExpend {
  /**
   * direct cash costs (tools, services, etc.)
   */
  direct: number;

  /**
   * indirect cash costs (overhead, opportunity cost)
   */
  indirect: number;

  /**
   * composite cash cost in $$
   * = direct + indirect
   */
  composite: number;
}

class BehaviorMeasuredCostExpend extends DomainLiteral<BehaviorMeasuredCostExpend> {}
```

#### BehaviorWorkstreamEntry

a behavior's position within a workstream.

```ts
interface BehaviorWorkstreamEntry {
  /**
   * reference to the behavior
   */
  behavior: RefByUnique<typeof Behavior>;

  /**
   * position in workstream (1-indexed)
   */
  position: number;

  /**
   * current urgency level
   */
  urgency: BehaviorTriagedUrgencyLevel;

  /**
   * blocking behaviors (if blocked)
   */
  blockedBy: RefByUnique<typeof Behavior>[] | null;
}

class BehaviorWorkstreamEntry extends DomainLiteral<BehaviorWorkstreamEntry> {}
```

#### BehaviorWorkstreamBottleneck

cross-workstream blocking relationship.

```ts
interface BehaviorWorkstreamBottleneck {
  /**
   * workstream being blocked
   */
  blockedWorkstream: RefByUnique<typeof BehaviorWorkstream>;

  /**
   * workstream causing the block
   */
  blockingWorkstream: RefByUnique<typeof BehaviorWorkstream>;

  /**
   * specific behavior causing the block
   */
  blockingBehavior: RefByUnique<typeof Behavior>;

  /**
   * position in blocked workstream where block occurs
   */
  atPosition: number;
}

class BehaviorWorkstreamBottleneck extends DomainLiteral<BehaviorWorkstreamBottleneck> {}
```

#### BehaviorDispatchConfig

configuration for dispatcher skills.

```ts
interface BehaviorDispatchConfig {
  /**
   * output directory path (default: .dispatch)
   */
  output: string;

  /**
   * sources to gather behaviors from
   */
  sources: {
    local: {
      repos: string[];
    };
    remote: {
      repos: BehaviorRemoteRepoConfig[];
    } | null;
  };

  /**
   * measurement criteria
   */
  criteria: {
    gain: {
      /**
       * leverage = time gained (see 3.1.research.domain.leverage.v9.i1.md)
       */
      leverage: {
        weights: {
          /**
           * "add behavior" — time saved to create
           */
          author: number;
          /**
           * "fix behavior" — time saved to operate
           */
          support: number;
        };
      };
    };

    /**
     * time is money — conversion for absolute comparison
     */
    convert: {
      equate: {
        cash: {
          dollars: number;  // e.g., 150
        };
        time: {
          hours: number;    // e.g., 1
        };
      };
    };
  };

  /**
   * constraints for triage
   */
  constraints: {
    maxConcurrency: number;
  };
}

interface BehaviorRemoteRepoConfig {
  url: string;
  prLabels: string[] | null;
  issueLabels: string[] | null;
}

class BehaviorDispatchConfig extends DomainLiteral<BehaviorDispatchConfig> {}
```

### 2.3 enums

```ts
type BehaviorGatheredStatus =
  | 'wish'      // only wish defined
  | 'vision'    // wish + vision defined
  | 'criteria'  // wish + vision + criteria defined
  | 'active'    // being worked on
  | 'review'    // in review
  | 'delivered' // complete
  ;

type BehaviorMeasuredPriorityLevel =
  | 'p0'  // critical - must do now
  | 'p1'  // important - should do soon
  | 'p3'  // desired - would be nice
  | 'p5'  // bonus - if time permits
  ;

type BehaviorTriagedReadinessLevel =
  | 'now'     // no blockers, ready to start
  | 'soon'    // minor blockers, ready soon
  | 'later'   // significant blockers
  | 'blocked' // hard blocked by dependency
  ;

type BehaviorTriagedBandwidthLevel =
  | 'now'   // within concurrency limit
  | 'soon'  // next in queue
  | 'later' // beyond current capacity
  ;

type BehaviorTriagedUrgencyLevel =
  | 'now'   // work on immediately
  | 'soon'  // queue for next
  | 'later' // backlog
  ;
```

---

## 3. domain.operations

### 3.1 gather skill operations

```
src/domain.operations/behavior/
  gatherBehavior.ts                      // main entry point
  enumBehaviorDirs.ts                    // find .behavior/*/ directories
  parseBehaviorDir.ts                    // parse a single behavior directory
  computeBehaviorGatheredContentHash.ts  // sha256 hash of directory contents
  loadBehaviorDispatchConfig.ts          // parse rhachet.dispatch.yml
```

#### gatherBehavior

```ts
/**
 * .what = gathers all behaviors from configured sources
 * .why = provides input for downstream deptrace/measure/triage skills
 */
export const gatherBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorGatherResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  // enumerate behavior directories from all sources
  const behaviorDirs = await enumBehaviorDirs({ sources: input.config.sources }, context);

  // parse each behavior directory
  const behaviors: BehaviorGathered[] = [];
  for (const dir of behaviorDirs) {
    const behavior = await parseBehaviorDir({ dir }, context);
    behaviors.push(behavior);
  }

  // save gathered behaviors to cache
  for (const gathered of behaviors) {
    await daoBehaviorGathered.set.upsert({ gathered }, context);
  }

  return { behaviors, stats: { ... } };
};
```

#### computeBehaviorGatheredContentHash

```ts
/**
 * .what = computes sha256 hash of behavior directory contents
 * .why = enables cache invalidation when behavior changes
 * .note = computed ONLY at gather time, reused downstream
 */
export const computeBehaviorGatheredContentHash = async (
  input: {
    dir: string;
  },
  context: BehaviorDispatchContext,
): Promise<string> => {
  // enumerate all files in directory
  const files = await enumFilesRecursive({ dir: input.dir }, context);

  // sort files for deterministic ordering
  const sortedFiles = files.sort();

  // concatenate file contents
  const contents = await Promise.all(
    sortedFiles.map(async (file) => {
      const content = await readFile({ path: file }, context);
      return `${file}:${content}`;
    }),
  );

  // compute sha256 hash
  return sha256(contents.join('\n'));
};
```

### 3.2 deptrace skill operations

```
src/domain.operations/behavior/
  deptraceBehavior.ts                        // main entry point
  parseBehaviorDeptracedDependencies.ts      // extract depends_on from criteria
  computeBehaviorDeptracedTransitiveDeps.ts  // compute transitive closure
  renderBehaviorDeptracedDependenciesMd.ts   // generate dependencies.md output
```

#### deptraceBehavior

```ts
/**
 * .what = traces dependencies for all gathered behaviors
 * .why = enables yieldage calculation with transitive impact
 */
export const deptraceBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
    behaviors: BehaviorGathered[];
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorDeptraceResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  const deptraced: BehaviorDeptraced[] = [];

  for (const gathered of input.behaviors) {
    // check cache by contentHash
    const cached = await daoBehaviorDeptraced.get.byContentHash(
      { behavior: gathered.behavior, contentHash: gathered.contentHash },
      context,
    );
    if (cached) {
      deptraced.push(cached);
      continue;
    }

    // parse direct dependencies from criteria
    const dependsOnDirect = await parseBehaviorDeptracedDependencies(
      { criteria: gathered.criteria },
      context,
    );

    // compute transitive closure
    const dependsOnTransitive = await computeBehaviorDeptracedTransitiveDeps(
      { behavior: gathered.behavior, direct: dependsOnDirect, allBehaviors: input.behaviors },
      context,
    );

    const result: BehaviorDeptraced = {
      behavior: gathered.behavior,
      contentHash: gathered.contentHash,
      dependsOnDirect,
      dependsOnTransitive,
      deptracedAt: new Date().toISOString(),
    };

    await daoBehaviorDeptraced.set.upsert({ deptraced: result }, context);
    deptraced.push(result);
  }

  // render dependencies.md
  const dependenciesMd = await renderBehaviorDeptracedDependenciesMd(
    { behaviors: deptraced },
    context,
  );

  return { behaviors: deptraced, outputs: { dependenciesMd }, stats: { ... } };
};
```

#### renderBehaviorDeptracedDependenciesMd

```ts
/**
 * .what = renders dependency tree as markdown
 * .why = provides human-readable dependency visualization
 */
export const renderBehaviorDeptracedDependenciesMd = async (
  input: {
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Promise<string> => {
  const lines: string[] = ['# dependencies', ''];

  for (const behavior of input.behaviors) {
    lines.push(`## ${behavior.behavior.org}/${behavior.behavior.repo}/${behavior.behavior.name}`);
    if (behavior.dependsOnDirect.length === 0) {
      lines.push('depends on: (none)');
    } else {
      lines.push('depends on:');
      // render as tree with urgency annotations
      for (const dep of behavior.dependsOnDirect) {
        lines.push(`  - ${dep.org}/${dep.repo}/${dep.name}`);
        // include transitive deps as nested tree
      }
    }
    lines.push('');
  }

  return lines.join('\n');
};
```

### 3.3 measure skill operations

```
src/domain.operations/behavior/
  measureBehavior.ts                          // main entry point
  computeBehaviorMeasuredGainLeverage.ts      // leverage = time gained (author + support)
  computeBehaviorMeasuredGainYieldage.ts      // yieldage = cash gained (probabilistic)
  computeBehaviorMeasuredGainComposite.ts     // gain(+$) = leverage + yieldage → $$
  computeBehaviorMeasuredCostAttend.ts        // attend = time cost
  computeBehaviorMeasuredCostExpend.ts        // expend = cash cost
  computeBehaviorMeasuredCostComposite.ts     // cost(-$) = attend + expend → $$
  computeBehaviorMeasuredReverseDeps.ts       // invert dependency graph for transitive impact
  assignBehaviorMeasuredPriority.ts           // map effect(~$) to priority level
```

#### measureBehavior

```ts
/**
 * .what = measures all deptraced behaviors
 * .why = provides scoring for prioritization decisions
 */
export const measureBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasureResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  // compute reverse dependency map for transitive impact calculation
  const reverseDeps = computeBehaviorMeasuredReverseDeps({ behaviors: input.behaviors }, context);

  const measured: BehaviorMeasured[] = [];

  for (const deptraced of input.behaviors) {
    // check cache by contentHash
    const cached = await daoBehaviorMeasured.get.byContentHash(
      { behavior: deptraced.behavior, contentHash: deptraced.contentHash },
      context,
    );
    if (cached) {
      measured.push(cached);
      continue;
    }

    // compute gain dimensions (leverage = time gained, yieldage = cash gained)
    const leverage = await computeBehaviorMeasuredGainLeverage(
      { deptraced, reverseDeps, config: input.config },
      context,
    );
    const yieldage = await computeBehaviorMeasuredGainYieldage(
      { deptraced, reverseDeps, config: input.config },
      context,
    );
    const gainComposite = computeBehaviorMeasuredGainComposite(
      { leverage, yieldage, config: input.config },
      context,
    );

    // compute cost dimensions (attend = time cost, expend = cash cost)
    const attend = await computeBehaviorMeasuredCostAttend(
      { deptraced, config: input.config },
      context,
    );
    const expend = await computeBehaviorMeasuredCostExpend(
      { deptraced, config: input.config },
      context,
    );
    const costComposite = computeBehaviorMeasuredCostComposite(
      { attend, expend, config: input.config },
      context,
    );

    // compute effect(~$) = gain - cost
    const effect = gainComposite - costComposite;

    // assign priority based on effect
    const priority = assignBehaviorMeasuredPriority({ effect }, context);

    const result: BehaviorMeasured = {
      behavior: deptraced.behavior,
      contentHash: deptraced.contentHash,
      gain: {
        dimensions: { leverage, yieldage },
        composite: gainComposite,
      },
      cost: {
        dimensions: { attend, expend },
        composite: costComposite,
      },
      effect,
      priority,
      measuredAt: new Date().toISOString(),
    };

    await daoBehaviorMeasured.set.upsert({ measured: result }, context);
    measured.push(result);
  }

  return { behaviors: measured, stats: { ... } };
};
```

#### computeBehaviorMeasuredGainLeverage

```ts
/**
 * .what = computes leverage for a behavior
 * .why = leverage = time gained (time can only be saved)
 * .note = includes transitive impact via blockee calculation
 * .ref = 3.1.research.domain.leverage.v9.i1.md
 */
export const computeBehaviorMeasuredGainLeverage = async (
  input: {
    deptraced: BehaviorDeptraced;
    reverseDeps: Map<string, string[]>;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredGainLeverage> => {
  // author leverage from brain.repl analysis
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const authorAnalysis = await context.brain.repl({
    prompt: `analyze author leverage for behavior: ${behaviorPath}
    - how much time saved to create (mins/use)?
    - what code blocks, paths, khues avoided?`,
    schema: authorLeverageSchema,
  });

  // support leverage from brain.repl analysis
  const supportAnalysis = await context.brain.repl({
    prompt: `analyze support leverage for behavior: ${behaviorPath}
    - how much time saved to fix (mins/fail)?
    - what signals and defences added?`,
    schema: supportLeverageSchema,
  });

  // compute composite with author/support weights
  const { author, support } = input.config.criteria.gain.leverage.weights;
  const composite = (authorAnalysis.time * author) + (supportAnalysis.time * support);

  // compute transitive leverage from unblocked behaviors
  const behaviorKey = serialize(input.deptraced.behavior);
  const blockees = input.reverseDeps.get(behaviorKey) || [];
  const transitive = await computeTransitiveLeverage({ blockees }, context);

  return {
    author: authorAnalysis.time,
    support: supportAnalysis.time,
    composite,
    transitive,
  };
};
```

#### computeBehaviorMeasuredGainYieldage

```ts
/**
 * .what = computes yieldage for a behavior
 * .why = yieldage = cash gained (cash can be saved or earned)
 * .note = includes transitive impact via blockee calculation
 */
export const computeBehaviorMeasuredGainYieldage = async (
  input: {
    deptraced: BehaviorDeptraced;
    reverseDeps: Map<string, string[]>;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredGainYieldage> => {
  // base yield from brain.repl analysis
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const baseYield = await context.brain.repl({
    prompt: `analyze yieldage for behavior: ${behaviorPath}
    - what cash value does this deliver (revenue or savings)?
    - what are the possible outcomes and their probabilities?`,
    schema: yieldageSchema,
  });

  // compute transitive yieldage from unblocked behaviors
  const behaviorKey = serialize(input.deptraced.behavior);
  const blockees = input.reverseDeps.get(behaviorKey) || [];
  const transitive = await computeTransitiveYieldage({ blockees }, context);

  // build chances array
  const chances: BehaviorMeasuredGainYieldageChance[] = [
    { yieldage: 0, probability: baseYield.failureProbability },
    { yieldage: baseYield.successYield, probability: 1 - baseYield.failureProbability },
  ];

  // compute expected value
  const expected = chances.reduce(
    (sum, chance) => sum + chance.yieldage * chance.probability,
    0,
  );

  return { chances, expected, transitive };
};
```

#### computeBehaviorMeasuredGainComposite

```ts
/**
 * .what = computes gain(+$) = leverage + yieldage → converted to $$
 * .why = combines time and cash gains into absolute value
 */
export const computeBehaviorMeasuredGainComposite = (
  input: {
    leverage: BehaviorMeasuredGainLeverage;
    yieldage: BehaviorMeasuredGainYieldage;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): number => {
  const { dollars, hours } = input.config.criteria.convert.equate;
  const ratePerMinute = (dollars / hours) / 60;

  // convert leverage (time in mins) to $$
  const leverageDollars = (input.leverage.composite + input.leverage.transitive) * ratePerMinute;

  // yieldage is already in $$
  const yieldageDollars = input.yieldage.expected + input.yieldage.transitive;

  return leverageDollars + yieldageDollars;
};
```

#### computeBehaviorMeasuredCostAttend

```ts
/**
 * .what = computes attend (time cost) for a behavior
 * .why = attend = time cost (attention required to complete)
 */
export const computeBehaviorMeasuredCostAttend = async (
  input: {
    deptraced: BehaviorDeptraced;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredCostAttend> => {
  // analyze time cost from brain.repl
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const analysis = await context.brain.repl({
    prompt: `analyze time cost for behavior: ${behaviorPath}
    - how many hours to complete?
    - what is the complexity factor (1.0 = normal)?`,
    schema: attendSchema,
  });

  // compute composite
  const composite = analysis.hours * analysis.complexity;

  return {
    hours: analysis.hours,
    complexity: analysis.complexity,
    composite,
  };
};
```

#### computeBehaviorMeasuredCostExpend

```ts
/**
 * .what = computes expend (cash cost) for a behavior
 * .why = expend = cash cost (expenditure required to complete)
 */
export const computeBehaviorMeasuredCostExpend = async (
  input: {
    deptraced: BehaviorDeptraced;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredCostExpend> => {
  // analyze cash cost from brain.repl
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const analysis = await context.brain.repl({
    prompt: `analyze cash cost for behavior: ${behaviorPath}
    - what direct costs (tools, services)?
    - what indirect costs (overhead)?`,
    schema: expendSchema,
  });

  // compute composite
  const composite = analysis.direct + analysis.indirect;

  return {
    direct: analysis.direct,
    indirect: analysis.indirect,
    composite,
  };
};
```

#### computeBehaviorMeasuredCostComposite

```ts
/**
 * .what = computes cost(-$) = attend + expend → converted to $$
 * .why = combines time and cash costs into absolute value
 */
export const computeBehaviorMeasuredCostComposite = (
  input: {
    attend: BehaviorMeasuredCostAttend;
    expend: BehaviorMeasuredCostExpend;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): number => {
  const { dollars, hours } = input.config.criteria.convert.equate;
  const ratePerHour = dollars / hours;

  // convert attend (time in hours) to $$
  const attendDollars = input.attend.composite * ratePerHour;

  // expend is already in $$
  const expendDollars = input.expend.composite;

  return attendDollars + expendDollars;
};
```

#### computeBehaviorMeasuredReverseDeps

```ts
/**
 * .what = inverts dependency graph to find blockees
 * .why = enables transitive impact calculation for both leverage and yieldage
 * .note = deptrace only tracks dependsOn*; this computes dependedBy*
 */
export const computeBehaviorMeasuredReverseDeps = (
  input: {
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Map<string, string[]> => {
  const reverseDeps = new Map<string, string[]>();

  // initialize all behaviors with empty arrays
  for (const behavior of input.behaviors) {
    const key = serialize(behavior.behavior);
    reverseDeps.set(key, []);
  }

  // invert the graph
  for (const behavior of input.behaviors) {
    const behaviorKey = serialize(behavior.behavior);
    for (const dep of behavior.dependsOnTransitive) {
      const depKey = serialize(dep);
      const blockees = reverseDeps.get(depKey) || [];
      blockees.push(behaviorKey);
      reverseDeps.set(depKey, blockees);
    }
  }

  return reverseDeps;
};
```

### 3.4 triage skill operations

```
src/domain.operations/behavior/
  triageBehavior.ts                       // main entry point
  computeBehaviorTriagedReadiness.ts      // determine readiness from deps
  computeBehaviorTriagedBandwidth.ts      // determine bandwidth from constraints
  renderBehaviorTriagedPrioritizationMd.ts   // generate prioritization.md
  renderBehaviorTriagedPrioritizationJson.ts // generate prioritization.json
```

#### triageBehavior

```ts
/**
 * .what = triages all measured behaviors into urgency buckets
 * .why = provides actionable prioritization for users
 * .note = fully deterministic (no brain.repl)
 */
export const triageBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
    behaviors: BehaviorMeasured[];
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorTriageResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  // sort by priority then effect score
  const sorted = [...input.behaviors].sort((a, b) => {
    const priorityOrder = { p0: 0, p1: 1, p3: 2, p5: 3 };
    if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    }
    return b.effect - a.effect; // higher effect first
  });

  const triaged: BehaviorTriaged[] = [];
  let nowCount = 0;

  for (const measured of sorted) {
    // compute readiness from dependency status
    const readiness = computeBehaviorTriagedReadiness(
      { measured, allBehaviors: sorted },
      context,
    );

    // compute bandwidth from constraints
    const bandwidth: BehaviorTriagedBandwidthLevel =
      nowCount < input.config.constraints.maxConcurrency
        ? 'now'
        : nowCount < input.config.constraints.maxConcurrency * 2
          ? 'soon'
          : 'later';

    // decision = min(readiness, bandwidth)
    const decision = minUrgency(readiness, bandwidth);

    if (decision === 'now') nowCount++;

    const result: BehaviorTriaged = {
      behavior: measured.behavior,
      contentHash: measured.contentHash,
      dimensions: { readiness, bandwidth },
      decision,
      priority: measured.priority,
      triagedAt: new Date().toISOString(),
    };

    await daoBehaviorTriaged.set.upsert({ triaged: result }, context);
    triaged.push(result);
  }

  return {
    behaviors: triaged,
    stats: {
      all: triaged.length,
      now: triaged.filter((b) => b.decision === 'now').length,
      soon: triaged.filter((b) => b.decision === 'soon').length,
      later: triaged.filter((b) => b.decision === 'later').length,
    },
  };
};
```

### 3.5 prioritize composite skill operations

```
src/domain.operations/behavior/
  prioritizeBehavior.ts        // main entry point (orchestrates atomic skills)
```

#### prioritizeBehavior

```ts
/**
 * .what = runs full prioritization pipeline: gather → deptrace → measure → triage
 * .why = provides one-command prioritization for users
 */
export const prioritizeBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorPrioritizeResult> => {
  // gather
  const gatherResult = await gatherBehavior({ config: input.config }, context);

  // deptrace
  const deptraceResult = await deptraceBehavior(
    { config: input.config, behaviors: gatherResult.behaviors },
    context,
  );

  // measure
  const measureResult = await measureBehavior(
    { config: input.config, behaviors: deptraceResult.behaviors },
    context,
  );

  // triage
  const triageResult = await triageBehavior(
    { config: input.config, behaviors: measureResult.behaviors },
    context,
  );

  // render outputs
  const prioritizationMd = await renderBehaviorTriagedPrioritizationMd(
    { behaviors: triageResult.behaviors },
    context,
  );
  const prioritizationJson = JSON.stringify(triageResult.behaviors, null, 2);

  // archive previous outputs if changed
  await archiveBehaviorIfChanged(
    { path: `${input.config.output}/prioritization.md`, content: prioritizationMd },
    context,
  );

  // write outputs
  await writeFile({ path: `${input.config.output}/prioritization.md`, content: prioritizationMd }, context);
  await writeFile({ path: `${input.config.output}/prioritization.json`, content: prioritizationJson }, context);
  await writeFile({ path: `${input.config.output}/dependencies.md`, content: deptraceResult.outputs.dependenciesMd }, context);

  return {
    behaviors: triageResult.behaviors,
    outputs: {
      prioritizationMd,
      prioritizationJson,
      dependenciesMd: deptraceResult.outputs.dependenciesMd,
    },
  };
};
```

### 3.6 coordinate skill operations

```
src/domain.operations/behavior/
  coordinateBehavior.ts                     // main entry point
  groupBehaviorWorkstreams.ts               // cluster behaviors into workstreams
  rankBehaviorWorkstreams.ts                // assign ranks based on priority
  detectBehaviorWorkstreamBottlenecks.ts    // find cross-workstream blocks
  renderBehaviorWorkstreamCoordinationMd.ts // generate coordination.md
```

#### coordinateBehavior

```ts
/**
 * .what = groups triaged behaviors into parallel workstreams
 * .why = enables team coordination and bottleneck detection
 */
export const coordinateBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorCoordinateResult> => {
  // load triaged behaviors
  const triaged = await daoBehaviorTriaged.get.all({}, context);

  // group into workstreams
  const workstreams = await groupBehaviorWorkstreams({ behaviors: triaged }, context);

  // rank workstreams
  const ranked = await rankBehaviorWorkstreams({ workstreams }, context);

  // detect bottlenecks
  for (const workstream of ranked) {
    workstream.bottlenecks = await detectBehaviorWorkstreamBottlenecks(
      { workstream, allWorkstreams: ranked },
      context,
    );
  }

  // render outputs
  const coordinationMd = await renderBehaviorWorkstreamCoordinationMd({ workstreams: ranked }, context);
  const coordinationJson = JSON.stringify(ranked, null, 2);

  // archive if changed
  await archiveBehaviorIfChanged(
    { path: `${input.config.output}/coordination.md`, content: coordinationMd },
    context,
  );

  // write outputs
  await writeFile({ path: `${input.config.output}/coordination.md`, content: coordinationMd }, context);
  await writeFile({ path: `${input.config.output}/coordination.json`, content: coordinationJson }, context);

  return {
    workstreams: ranked,
    outputs: { coordinationMd, coordinationJson },
  };
};
```

### 3.7 shared operations

```
src/domain.operations/behavior/
  findsertBehaviorDispatchDir.ts   // idempotent output dir initialization
  archiveBehaviorIfChanged.ts      // archive prior outputs
  loadBehaviorGathered.ts          // load from cache
```

#### findsertBehaviorDispatchDir

```ts
/**
 * .what = creates output directory with readme if not exists
 * .why = ensures consistent output structure across skills
 * .note = idempotent - safe to call multiple times
 */
export const findsertBehaviorDispatchDir = async (
  input: {
    path: string;
  },
  context: BehaviorDispatchContext,
): Promise<void> => {
  // check if directory exists
  const exists = await directoryExists({ path: input.path }, context);
  if (exists) return;

  // create directory structure
  await mkdir({ path: input.path }, context);
  await mkdir({ path: `${input.path}/.gathered` }, context);
  await mkdir({ path: `${input.path}/.deptraced` }, context);
  await mkdir({ path: `${input.path}/.measured` }, context);
  await mkdir({ path: `${input.path}/.triaged` }, context);
  await mkdir({ path: `${input.path}/.archive` }, context);

  // write readme
  const readme = `# .dispatch output

this directory contains dispatcher skill outputs.

## cache behavior

the .* directories (.gathered/, .deptraced/, .measured/, .triaged/) are caches.
they are reused in subsequent invocations to maximize efficiency:

- only behaviors with changed contentHash are reprocessed
- unchanged behaviors reuse cached results
- delete a .* directory to force recomputation of that stage

## archive behavior

when outputs change, prior versions are archived to .archive/:

- files are named {filename}.{isoTimestamp}.bak.md
- unchanged runs do not create archives
- archives are sorted by timestamp (ls shows history)

## files

- prioritization.md: human-readable summary of triaged behaviors
- prioritization.json: machine-readable data for downstream tools
- dependencies.md: dependency tree per behavior
- coordination.md: workstream map (after coordinate skill)
- coordination.json: machine-readable workstream data
`;

  await writeFile({ path: `${input.path}/readme.md`, content: readme }, context);
};
```

---

## 4. access.daos

### 4.1 daoBehaviorGathered

```
src/access/daos/daoBehaviorGathered/
  index.ts
  get/
    byUnique.ts
    byContentHash.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorGathered entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorGathered = {
  get: {
    /**
     * .what = get gathered behavior by unique key (behavior ref)
     */
    byUnique: async (
      input: { behavior: RefByUnique<typeof Behavior> },
      context: DispatchContext,
    ): Promise<BehaviorGathered | null> => {
      const cacheKey = `${input.behavior.org}/${input.behavior.repo}/${input.behavior.name}`;
      const cachePath = `${context.config.output}/.gathered/${slugify(cacheKey)}.gathered.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    /**
     * .what = get gathered behavior by unique key + contentHash
     * .why = cache invalidation check
     */
    byContentHash: async (
      input: { behavior: RefByUnique<typeof Behavior>; contentHash: string },
      context: DispatchContext,
    ): Promise<BehaviorGathered | null> => {
      const found = await daoBehaviorGathered.get.byUnique(input, context);
      if (found && found.contentHash === input.contentHash) {
        return found;
      }
      return null;
    },

    /**
     * .what = get all gathered behaviors
     */
    all: async (
      input: {},
      context: DispatchContext,
    ): Promise<BehaviorGathered[]> => {
      const files = await glob({ pattern: `${context.config.output}/.gathered/*.gathered.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    /**
     * .what = upsert gathered behavior to cache
     */
    upsert: async (
      input: { gathered: BehaviorGathered },
      context: DispatchContext,
    ): Promise<BehaviorGathered> => {
      const cacheKey = `${input.gathered.behavior.org}/${input.gathered.behavior.repo}/${input.gathered.behavior.name}`;
      const cachePath = `${context.config.output}/.gathered/${slugify(cacheKey)}.gathered.json`;
      await writeJson({ path: cachePath, data: input.gathered }, context);
      return input.gathered;
    },
  },
};
```

### 4.2 daoBehaviorDeptraced

```
src/access/daos/daoBehaviorDeptraced/
  index.ts
  get/
    byUnique.ts
    byContentHash.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorDeptraced entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorDeptraced = {
  get: {
    byUnique: async (input: { behavior: RefByUnique<typeof Behavior> }, context: DispatchContext): Promise<BehaviorDeptraced | null> => {
      const cacheKey = `${input.behavior.org}/${input.behavior.repo}/${input.behavior.name}`;
      const cachePath = `${context.config.output}/.deptraced/${slugify(cacheKey)}.deptraced.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    byContentHash: async (
      input: { behavior: RefByUnique<typeof Behavior>; contentHash: string },
      context: DispatchContext,
    ): Promise<BehaviorDeptraced | null> => {
      const found = await daoBehaviorDeptraced.get.byUnique(input, context);
      if (found && found.contentHash === input.contentHash) {
        return found;
      }
      return null;
    },

    all: async (input: {}, context: DispatchContext): Promise<BehaviorDeptraced[]> => {
      const files = await glob({ pattern: `${context.config.output}/.deptraced/*.deptraced.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    upsert: async (
      input: { deptraced: BehaviorDeptraced },
      context: DispatchContext,
    ): Promise<BehaviorDeptraced> => {
      const cacheKey = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
      const cachePath = `${context.config.output}/.deptraced/${slugify(cacheKey)}.deptraced.json`;
      await writeJson({ path: cachePath, data: input.deptraced }, context);
      return input.deptraced;
    },
  },
};
```

### 4.3 daoBehaviorMeasured

```
src/access/daos/daoBehaviorMeasured/
  index.ts
  get/
    byUnique.ts
    byContentHash.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorMeasured entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorMeasured = {
  get: {
    byUnique: async (input: { behavior: RefByUnique<typeof Behavior> }, context: DispatchContext): Promise<BehaviorMeasured | null> => {
      const cacheKey = `${input.behavior.org}/${input.behavior.repo}/${input.behavior.name}`;
      const cachePath = `${context.config.output}/.measured/${slugify(cacheKey)}.measured.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    byContentHash: async (
      input: { behavior: RefByUnique<typeof Behavior>; contentHash: string },
      context: DispatchContext,
    ): Promise<BehaviorMeasured | null> => {
      const found = await daoBehaviorMeasured.get.byUnique(input, context);
      if (found && found.contentHash === input.contentHash) {
        return found;
      }
      return null;
    },

    all: async (input: {}, context: DispatchContext): Promise<BehaviorMeasured[]> => {
      const files = await glob({ pattern: `${context.config.output}/.measured/*.measured.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    upsert: async (
      input: { measured: BehaviorMeasured },
      context: DispatchContext,
    ): Promise<BehaviorMeasured> => {
      const cacheKey = `${input.measured.behavior.org}/${input.measured.behavior.repo}/${input.measured.behavior.name}`;
      const cachePath = `${context.config.output}/.measured/${slugify(cacheKey)}.measured.json`;
      await writeJson({ path: cachePath, data: input.measured }, context);
      return input.measured;
    },
  },
};
```

### 4.4 daoBehaviorTriaged

```
src/access/daos/daoBehaviorTriaged/
  index.ts
  get/
    byUnique.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorTriaged entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorTriaged = {
  get: {
    byUnique: async (input: { behavior: RefByUnique<typeof Behavior> }, context: DispatchContext): Promise<BehaviorTriaged | null> => {
      const cacheKey = `${input.behavior.org}/${input.behavior.repo}/${input.behavior.name}`;
      const cachePath = `${context.config.output}/.triaged/${slugify(cacheKey)}.triaged.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    all: async (input: {}, context: DispatchContext): Promise<BehaviorTriaged[]> => {
      const files = await glob({ pattern: `${context.config.output}/.triaged/*.triaged.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    upsert: async (
      input: { triaged: BehaviorTriaged },
      context: DispatchContext,
    ): Promise<BehaviorTriaged> => {
      const cacheKey = `${input.triaged.behavior.org}/${input.triaged.behavior.repo}/${input.triaged.behavior.name}`;
      const cachePath = `${context.config.output}/.triaged/${slugify(cacheKey)}.triaged.json`;
      await writeJson({ path: cachePath, data: input.triaged }, context);
      return input.triaged;
    },
  },
};
```

---

## 5. directory structure

```
src/
  contract/
    cmd/
      gatherBehavior.ts         // npx rhachet run --skill gather
      deptraceBehavior.ts       // npx rhachet run --skill deptrace
      measureBehavior.ts        // npx rhachet run --skill measure
      triageBehavior.ts         // npx rhachet run --skill triage
      prioritizeBehavior.ts     // npx rhachet run --skill prioritize
      coordinateBehavior.ts     // npx rhachet run --skill coordinate

  domain.objects/
    Behavior.ts
    BehaviorGathered.ts
    BehaviorDeptraced.ts
    BehaviorMeasured.ts
    BehaviorTriaged.ts
    BehaviorWorkstream.ts
    BehaviorFile.ts
    BehaviorMeasuredGainLeverage.ts
    BehaviorMeasuredGainYieldage.ts
    BehaviorMeasuredGainYieldageChance.ts
    BehaviorMeasuredCostAttend.ts
    BehaviorMeasuredCostExpend.ts
    BehaviorWorkstreamEntry.ts
    BehaviorWorkstreamBottleneck.ts
    BehaviorDispatchConfig.ts
    BehaviorGatheredStatus.ts
    BehaviorMeasuredPriorityLevel.ts
    BehaviorTriagedReadinessLevel.ts
    BehaviorTriagedBandwidthLevel.ts
    BehaviorTriagedUrgencyLevel.ts

  domain.operations/
    behavior/
      gatherBehavior.ts
      enumBehaviorDirs.ts
      parseBehaviorDir.ts
      computeBehaviorGatheredContentHash.ts
      loadBehaviorDispatchConfig.ts
      deptraceBehavior.ts
      parseBehaviorDeptracedDependencies.ts
      computeBehaviorDeptracedTransitiveDeps.ts
      renderBehaviorDeptracedDependenciesMd.ts
      measureBehavior.ts
      computeBehaviorMeasuredGainYieldage.ts
      computeBehaviorMeasuredGainLeverage.ts
      computeBehaviorMeasuredGainComposite.ts
      computeBehaviorMeasuredCostAttend.ts
      computeBehaviorMeasuredCostExpend.ts
      computeBehaviorMeasuredCostComposite.ts
      computeBehaviorMeasuredReverseDeps.ts
      assignBehaviorMeasuredPriority.ts
      triageBehavior.ts
      computeBehaviorTriagedReadiness.ts
      computeBehaviorTriagedBandwidth.ts
      renderBehaviorTriagedPrioritizationMd.ts
      renderBehaviorTriagedPrioritizationJson.ts
      prioritizeBehavior.ts
      coordinateBehavior.ts
      groupBehaviorWorkstreams.ts
      rankBehaviorWorkstreams.ts
      detectBehaviorWorkstreamBottlenecks.ts
      renderBehaviorWorkstreamCoordinationMd.ts
      findsertBehaviorDispatchDir.ts
      archiveBehaviorIfChanged.ts
      loadBehaviorGathered.ts

  access/
    daos/
      daoBehaviorGathered/
        index.ts
        get/
          byUnique.ts       // by behavior ref
          byContentHash.ts
          all.ts
        set/
          upsert.ts         // input: { gathered }
      daoBehaviorDeptraced/
        index.ts
        get/
          byUnique.ts       // by behavior ref
          byContentHash.ts
          all.ts
        set/
          upsert.ts         // input: { deptraced }
      daoBehaviorMeasured/
        index.ts
        get/
          byUnique.ts       // by behavior ref
          byContentHash.ts
          all.ts
        set/
          upsert.ts         // input: { measured }
      daoBehaviorTriaged/
        index.ts
        get/
          byUnique.ts       // by behavior ref
          all.ts
        set/
          upsert.ts         // input: { triaged }
```

---

## 6. design decisions

### 6.1 contentHash computed at gather time only

**decision**: contentHash is computed once during gather and stored in BehaviorGathered. downstream skills (deptrace, measure, triage) read contentHash from gathered output rather than recomputing.

**rationale**:
- ensures consistent cache key across all stages
- avoids redundant computation
- single source of truth for "behavior changed"

### 6.2 deptrace only tracks dependsOn* (not dependedBy*)

**decision**: BehaviorDeptraced only contains dependsOnDirect and dependsOnTransitive. reverse dependencies (dependedBy*) are computed at measure time via graph inversion.

**rationale**:
- keeps deptrace output minimal and focused
- avoids dual-storage of same relationship
- blockee calculation is only needed for yieldage scoring

### 6.3 probabilistic yieldage chances

**decision**: yieldage is modeled as an array of chances { yieldage, probability }[] rather than a single number.

**rationale**:
- captures uncertainty in value delivery
- failure probability (yieldage: 0) is explicit
- expected value computed as weighted sum
- enables risk-aware prioritization

### 6.4 dimensions/decision structure

**decision**: both BehaviorMeasured and BehaviorTriaged use a dimensions/decision structure.

**rationale**:
- dimensions capture the inputs to decision
- decision is the computed output
- makes reasoning transparent and auditable
- enables debugging ("why is this behavior p1?")

### 6.5 triage is deterministic (no brain.repl)

**decision**: triage skill does not use brain.repl. readiness is computed from dependency status, bandwidth from constraints.

**rationale**:
- triage should be predictable and reproducible
- same inputs always produce same outputs
- reduces complexity and cost
- brain.repl reserved for measure skill where judgment is needed

### 6.6 findsertDispatchDir for idempotent output initialization

**decision**: all skills call findsertDispatchDir before writing output. this creates the output directory structure and readme.md if not exists.

**rationale**:
- ensures consistent output structure
- readme.md explains cache and archive behavior to users
- idempotent - safe to call multiple times
- single skill can run independently without prior setup

### 6.7 dependencies.md generated by deptrace skill

**decision**: deptrace skill produces dependencies.md as an output, not prioritize composite.

**rationale**:
- dependency information is available immediately after deptrace
- allows users to inspect deps without running full pipeline
- prioritize just passes through the output

### 6.8 priority levels use odd numbers only

**decision**: priority levels are p0, p1, p3, p5 (skipping p2 and p4).

**rationale**:
- leaves room for future intermediate levels if needed
- common pattern in issue trackers
- provides clear separation between levels

### 6.9 cache invalidation via contentHash matching

**decision**: downstream skills check `contentHash` match before returning cached results. if contentHash differs from gathered behavior, cache is invalidated.

**rationale**:
- simple and reliable invalidation
- no need for timestamp comparison
- content-addressable caching

### 6.10 interactive mode out of scope

**decision**: interactive mode (user prompts during skill execution) is explicitly out of scope.

**rationale**:
- keeps initial implementation simple
- users can manually edit output files for overrides
- future enhancement if needed

---

## 7. context type

```ts
interface BehaviorDispatchContext {
  /**
   * loaded dispatch config
   */
  config: BehaviorDispatchConfig;

  /**
   * brain access for AI-powered analysis
   */
  brain: {
    repl: <T>(input: { prompt: string; schema: ZodSchema<T> }) => Promise<T>;
  };

  /**
   * logging
   */
  log: LogMethods;
}
```

---

## 8. traceability matrix

| wish                       | skill              | mechanism                                                                            |
| -------------------------- | ------------------ | ------------------------------------------------------------------------------------ |
| "where to start?"          | triageBehavior     | decision = min(readiness, bandwidth) → now/soon/later                                |
| "which is most important?" | measureBehavior    | effect(~$) = gain(+$) - cost(-$); higher effect = higher priority                    |
| "which unblocks the most?" | measureBehavior    | computeBehaviorMeasuredReverseDeps → blockee impact → transitive leverage + yieldage |
| "too many workstreams"     | coordinateBehavior | groupBehaviorWorkstreams → named workstreams                                         |
| "what is even active?"     | coordinateBehavior | workstream map with urgency annotations                                              |
| "which to review first?"   | coordinateBehavior | rankBehaviorWorkstreams → review in rank order                                       |
| "cache artifacts"          | all skills         | contentHash + byContentHash cache check                                              |
| "parallelize work"         | coordinateBehavior | independent behaviors → parallel workstreams                                         |
