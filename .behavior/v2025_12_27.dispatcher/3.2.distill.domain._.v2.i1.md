# domain distillation: dispatcher role v2

this document declares the domain model for the dispatcher role, enabling prioritization and coordination of behaviors across repositories.

---

## 1. usecases and contracts

### 1.0 contract vs operation separation

**principle**: contracts are agnostic of contentHash; operations require versioned refs.

**contracts** (in `contract/cmd/`):
- accept `{ by: BehaviorDispatchConfig }`
- invoke gather first to get latest refs
- then call domain.operations with those refs
- user-facing entry points

**domain.operations** (in `domain.operations/behavior/`):
- accept `{ over: { behaviors: RefByUnique<typeof BehaviorGathered>[] } }`
- operate on specific versioned refs (includes contentHash)
- leverage caching via contentHash in refs
- internal implementation

### 1.1 usecase: prioritize backlog

**user story**: as a @[developer] with many behaviors to build, i want to see which ones to work on first, so i can maximize impact.

**contract** (user-facing):
```ts
// agnostic of contentHash - gathers latest then calls operation
getAllBehaviorPrioritized({
  by: BehaviorDispatchConfig,
}, context) => Promise<{
  behaviors: BehaviorTriaged[];
  outputs: {
    prioritizationMd: string;   // .dispatch/prioritization.md
    prioritizationJson: string; // .dispatch/prioritization.json
    dependenciesMd: string;     // .dispatch/dependencies.md
  };
}>
```

**operation** (internal):
```ts
// operates on specific versioned refs
getAllBehaviorPrioritized({
  over: { behaviors: RefByUnique<typeof BehaviorGathered>[] },
  config: BehaviorDispatchConfig,
}, context) => Promise<{
  behaviors: BehaviorTriaged[];
  outputs: { ... };
}>

// .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
//         contentHashes so unchanged behavior set skips evaluation entirely
```

### 1.2 usecase: coordinate workstreams

**user story**: as a @[teamlead] with multiple parallel workstreams, i want to see how work can be organized and which workstreams to prioritize for review.

**contract** (user-facing):
```ts
// agnostic of contentHash - gathers latest then calls operation
getAllBehaviorCoordinated({
  by: BehaviorDispatchConfig,
}, context) => Promise<{
  workstreams: BehaviorWorkstream[];
  outputs: {
    coordinationMd: string;   // .dispatch/coordination.md
    coordinationJson: string; // .dispatch/coordination.json
  };
}>
```

**operation** (internal):
```ts
// operates on specific versioned refs
getAllBehaviorCoordinated({
  over: { behaviors: RefByUnique<typeof BehaviorGathered>[] },
  config: BehaviorDispatchConfig,
}, context) => Promise<{
  workstreams: BehaviorWorkstream[];
  outputs: { ... };
}>

// .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
//         contentHashes so unchanged behavior set skips evaluation entirely
```

### 1.3 usecase: gather behaviors

**user story**: as a @[dispatcher], i need to collect all behaviors from configured sources to analyze them.

**contract** (user-facing):
```ts
// agnostic of contentHash - scans sources and returns latest refs
getAllBehaviorGathered({
  by: BehaviorDispatchConfig,
}, context) => Promise<{
  behaviors: BehaviorGathered[];
  stats: {
    reposScanned: number;
    behaviorsFound: number;
    behaviorsChanged: number;
  };
}>
```

**operation** (internal, polymorphic):
```ts
getAllBehaviorGathered({
  by: { sources: BehaviorDispatchConfig['sources'] },
}, context) => Promise<{
  behaviors: BehaviorGathered[];
  stats: { ... };
}>

getAllBehaviorGathered({
  by: { local: { repos: RefByUnique<typeof GitDir>[] } },
}, context) => Promise<{
  behaviors: BehaviorGathered[];
  stats: { ... };
}>

getAllBehaviorGathered({
  by: { remote: { repos: BehaviorSourceRepoRemote[] } },
}, context) => Promise<{
  behaviors: BehaviorGathered[];
  stats: { ... };
}>

// single behavior lookup (cache-critical)
getOneBehaviorGathered({
  by: { unique: RefByUnique<typeof BehaviorGathered> },
}, context) => Promise<BehaviorGathered>
```

### 1.4 usecase: trace dependencies

**user story**: as a @[dispatcher], i need to trace which behaviors depend on which others to compute transitive impact.

**operation** (internal only - no user-facing contract):
```ts
// internal operation called by getOneBehaviorMeasured
// not a separate skill - deptrace is computed per-behavior during measure
// looks up dependencies in .gathered/latest/ directory

getOneBehaviorDeptraced({
  by: { unique: RefByUnique<typeof BehaviorGathered> },
}, context) => Promise<BehaviorDeptraced>

// .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
//         contentHash so unchanged behaviors skip evaluation entirely
// .note = key criteria: failfast if dependency not found in .gathered/latest/
//         this scenario MUST have test coverage
```

### 1.5 usecase: measure behaviors

**user story**: as a @[dispatcher], i need to score behaviors by gain (leverage, yieldage) and cost (attend, expend) to determine priority.

**operation** (internal only - no user-facing contract):
```ts
// per-behavior measurement operation
// internally calls getOneBehaviorGathered and getOneBehaviorDeptraced

getOneBehaviorMeasured({
  by: { unique: RefByUnique<typeof BehaviorGathered> },
}, context) => Promise<BehaviorMeasured>

// .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
//         contentHash so unchanged behaviors skip evaluation entirely
```

### 1.6 usecase: triage behaviors

**user story**: as a @[dispatcher], i need to assign urgency (now/soon/later) based on readiness and bandwidth constraints.

**operation** (internal):
```ts
// collective operation over all behaviors
// internally calls getOneBehaviorMeasured for each

getAllBehaviorTriaged({
  over: { behaviors: RefByUnique<typeof BehaviorGathered>[] },
  config: BehaviorDispatchConfig,
}, context) => Promise<{
  behaviors: BehaviorTriaged[];
  stats: {
    all: number;
    now: number;
    soon: number;
    later: number;
  };
}>

// .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
//         contentHashes so unchanged behavior set skips evaluation entirely
```

---

## 2. domain.objects

### 2.1 entities

#### Behavior

the root domain entity representing a behavior being tracked.

```ts
interface Behavior {
  /**
   * organization or owner of the repo
   */
  org: string;

  /**
   * repository name
   */
  repo: string;

  /**
   * behavior directory name (e.g., "v2025_01_01.auth-flow")
   */
  name: string;
}

class Behavior extends DomainEntity<Behavior> {
  public static unique = ['org', 'repo', 'name'] as const;
}
```

#### BehaviorGathered

represents a behavior after collection from source repositories.

```ts
import { GitFile } from 'rhachet-artifact-git';

interface BehaviorGathered {
  /**
   * timestamp when gathered
   */
  gatheredAt: string;

  /**
   * reference to the behavior being gathered
   */
  behavior: RefByUnique<typeof Behavior>;

  /**
   * sha256 hash of behavior directory contents
   * computed at gather time, reused downstream for cache invalidation
   */
  contentHash: string;

  /**
   * current status of the behavior
   */
  status: BehaviorGatheredStatus;

  /**
   * file paths within the behavior directory (not embedded content)
   */
  files: RefByUnique<typeof GitFile>[];

  /**
   * parsed wish document content (0.wish.md)
   */
  wish: string | null;

  /**
   * parsed vision document content (1.vision.md)
   */
  vision: string | null;

  /**
   * parsed criteria document content (2.criteria.md)
   */
  criteria: string | null;
}

class BehaviorGathered extends DomainEntity<BehaviorGathered> {
  public static unique = ['behavior', 'contentHash'] as const;
}
```

#### BehaviorDeptraced

represents a behavior after dependency analysis.

```ts
interface BehaviorDeptraced {
  /**
   * timestamp when deptraced
   */
  deptracedAt: string;

  /**
   * reference to the gathered behavior (includes contentHash for cache key)
   */
  gathered: RefByUnique<typeof BehaviorGathered>;

  /**
   * behaviors this one directly depends on
   */
  dependsOnDirect: RefByUnique<typeof Behavior>[];

  /**
   * all behaviors this one depends on (transitive closure)
   */
  dependsOnTransitive: RefByUnique<typeof Behavior>[];
}

class BehaviorDeptraced extends DomainEntity<BehaviorDeptraced> {
  public static unique = ['gathered'] as const;
}
```

#### BehaviorMeasured

represents a behavior after measurement scoring.

```ts
interface BehaviorMeasured {
  /**
   * timestamp when measured
   */
  measuredAt: string;

  /**
   * reference to the gathered behavior (contentHash for cache invalidation)
   */
  gathered: RefByUnique<typeof BehaviorGathered>;

  /**
   * gain: value gained by completing this behavior
   * gain(+$) = leverage + yieldage → converted to $$
   */
  gain: BehaviorMeasuredGain;

  /**
   * cost: resources required to complete this behavior
   * cost(-$) = attend + expend → converted to $$
   */
  cost: BehaviorMeasuredCost;

  /**
   * effect(~$) = gain.composite - cost.composite
   * absolute comparable metric; higher = more net value
   */
  effect: number;

  /**
   * assigned priority level: p0, p1, p3, p5
   */
  priority: BehaviorMeasuredPriorityLevel;
}

class BehaviorMeasured extends DomainEntity<BehaviorMeasured> {
  public static unique = ['gathered'] as const;
}
```

#### BehaviorTriaged

represents a behavior after urgency assignment.

```ts
interface BehaviorTriaged {
  /**
   * timestamp when triaged
   */
  triagedAt: string;

  /**
   * reference to the gathered behavior (contentHash for cache invalidation)
   */
  gathered: RefByUnique<typeof BehaviorGathered>;

  /**
   * triage dimensions
   */
  dimensions: {
    /**
     * readiness level: now | soon | later
     * based on dependency status
     */
    readiness: BehaviorTriagedUrgencyLevel;
    /**
     * bandwidth level: now | soon | later
     * based on concurrency constraints
     */
    bandwidth: BehaviorTriagedUrgencyLevel;
  };

  /**
   * decision = min(readiness, bandwidth)
   * determines urgency bucket
   */
  decision: BehaviorTriagedUrgencyLevel;

  /**
   * priority from measurement (carried forward)
   */
  priority: BehaviorMeasuredPriorityLevel;
}

class BehaviorTriaged extends DomainEntity<BehaviorTriaged> {
  public static unique = ['gathered'] as const;
}
```

#### BehaviorWorkstream

represents a grouping of related behaviors into a parallelizable workstream.

```ts
type BehaviorWorkstreamRank = `r${number}`;

interface BehaviorWorkstream {
  /**
   * workstream slug (e.g., "auth-foundation")
   */
  slug: string;

  /**
   * human-readable name (e.g., "auth foundation")
   */
  name: string;

  /**
   * rank for prioritization (r1 = highest)
   */
  rank: BehaviorWorkstreamRank;

  /**
   * aggregate priority of behaviors in workstream
   */
  priority: BehaviorMeasuredPriorityLevel;

  /**
   * ordered deliverables in this workstream
   * order reflects dependency chain
   */
  deliverables: BehaviorWorkstreamDeliverable[];
}

class BehaviorWorkstream extends DomainEntity<BehaviorWorkstream> {
  public static unique = ['slug'] as const;
}
```

### 2.2 literals

#### BehaviorMeasuredGain

composite gain measurement (blocker.9).

```ts
interface BehaviorMeasuredGain {
  /**
   * gain dimensions
   */
  dimensions: {
    leverage: BehaviorMeasuredGainLeverage;
    yieldage: BehaviorMeasuredGainYieldage;
  };

  /**
   * composite gain in $$ (leverage + yieldage converted via convert.equate)
   */
  composite: number;
}

class BehaviorMeasuredGain extends DomainLiteral<BehaviorMeasuredGain> {}
```

#### BehaviorMeasuredCost

composite cost measurement (blocker.9).

```ts
interface BehaviorMeasuredCost {
  /**
   * cost dimensions
   */
  dimensions: {
    attend: BehaviorMeasuredCostAttend;
    expend: BehaviorMeasuredCostExpend;
  };

  /**
   * composite cost in $$ (attend + expend converted via convert.equate)
   */
  composite: number;
}

class BehaviorMeasuredCost extends DomainLiteral<BehaviorMeasuredCost> {}
```

#### BehaviorMeasuredGainLeverage

leverage measurement capturing time saved (per 3.1.research.domain.leverage.v9.i1.md).

```ts
interface BehaviorMeasuredGainLeverage {
  /**
   * direct leverage from this behavior
   */
  direct: {
    /**
     * author leverage = time saved to create ("add behavior")
     * measured in minutes saved per use
     */
    author: number;

    /**
     * support leverage = time saved to operate ("fix behavior")
     * measured in minutes saved per failure
     */
    support: number;

    /**
     * composite direct leverage in minutes/week
     * = (author × freq) + (support × fail.rate)
     */
    composite: number;
  };

  /**
   * transitive leverage from unblocked behaviors
   * = sum of leverage.direct.composite from behaviors this one unblocks
   */
  transitive: number;
}

class BehaviorMeasuredGainLeverage extends DomainLiteral<BehaviorMeasuredGainLeverage> {}
```

#### BehaviorMeasuredGainYieldage

probabilistic yield model capturing cash gained (can be saved or earned).

```ts
interface BehaviorMeasuredGainYieldage {
  /**
   * direct yieldage from this behavior
   */
  direct: {
    /**
     * possible yield outcomes with probabilities
     * each chance represents a possible outcome
     * failure is captured as { yieldage: 0, probability: P }
     */
    chances: BehaviorMeasuredGainYieldageChance[];

    /**
     * expected value = sum(yieldage * probability)
     * weighted sum of chances
     */
    expected: number;
  };

  /**
   * transitive yieldage from unblocked behaviors
   * = sum of yieldage.direct.expected from behaviors this one unblocks
   */
  transitive: number;
}

interface BehaviorMeasuredGainYieldageChance {
  /**
   * yield value in $$
   * 0 = failure/no value delivered
   */
  yieldage: number;

  /**
   * probability of this outcome (0-1)
   */
  probability: number;
}

class BehaviorMeasuredGainYieldage extends DomainLiteral<BehaviorMeasuredGainYieldage> {}
```

#### BehaviorMeasuredCostAttend

time cost measurement (attention required).

```ts
interface BehaviorMeasuredCostAttend {
  /**
   * estimated hours to complete this behavior
   */
  hours: number;

  /**
   * complexity factor (1.0 = normal, >1 = more complex)
   */
  complexity: number;

  /**
   * composite time cost in hours
   * = hours × complexity
   */
  composite: number;
}

class BehaviorMeasuredCostAttend extends DomainLiteral<BehaviorMeasuredCostAttend> {}
```

#### BehaviorMeasuredCostExpend

cash cost measurement (expenditure required).

```ts
interface BehaviorMeasuredCostExpend {
  /**
   * direct cash costs (tools, services, etc.)
   */
  direct: number;

  /**
   * indirect cash costs (overhead, opportunity cost)
   */
  indirect: number;

  /**
   * composite cash cost in $$
   * = direct + indirect
   */
  composite: number;
}

class BehaviorMeasuredCostExpend extends DomainLiteral<BehaviorMeasuredCostExpend> {}
```

#### BehaviorWorkstreamDeliverable

a behavior's position within a workstream.

```ts
interface BehaviorWorkstreamDeliverable {
  /**
   * reference to the triaged behavior
   */
  triaged: RefByUnique<typeof BehaviorTriaged>;

  /**
   * position in workstream (1-indexed)
   */
  position: number;

  /**
   * current urgency level
   */
  urgency: BehaviorTriagedUrgencyLevel;

  /**
   * blocking behaviors (if blocked)
   */
  blockedBy: RefByUnique<typeof Behavior>[] | null;
}

class BehaviorWorkstreamDeliverable extends DomainLiteral<BehaviorWorkstreamDeliverable> {}
```

#### BehaviorDispatchConfig

configuration for dispatcher skills.

```ts
import { GitFile } from 'rhachet-artifact-git';

interface BehaviorDispatchConfig {
  /**
   * output directory path for all dispatcher outputs
   * @example '.dispatch' — outputs stored in .dispatch/ at repo root
   */
  output: string;

  /**
   * sources to gather behaviors from
   */
  sources: {
    /**
     * local repository paths (relative to config file)
     * @example ['../my-repo', '../other-repo'] — scan sibling repos for behaviors
     */
    local: {
      repos: RefByUnique<typeof GitFile>[];
    };
    /**
     * remote repositories (optional)
     */
    remote: {
      repos: BehaviorSourceRepoRemote[];
    } | null;
  };

  /**
   * measurement criteria
   */
  criteria: {
    gain: {
      /**
       * leverage = time gained (see 3.1.research.domain.leverage.v9.i1.md)
       */
      leverage: {
        weights: {
          /**
           * "add behavior" — time saved to create
           * @example 1.0 — full weight for authoring time savings
           */
          author: number;
          /**
           * "fix behavior" — time saved to operate
           * @example 0.5 — half weight for operational time savings (less frequent)
           */
          support: number;
        };
      };
    };

    /**
     * time is money — conversion for absolute comparison
     */
    convert: {
      equate: {
        cash: {
          /**
           * @example 150 — $150 per hour rate for time-to-cash conversion
           */
          dollars: number;
        };
        time: {
          /**
           * @example 1 — 1 hour baseline for cash-to-time conversion
           */
          hours: number;
        };
      };
    };
  };

  /**
   * constraints for triage
   */
  constraints: {
    /**
     * maximum parallel workstreams to mark as "now"
     * @example 3 — allow up to 3 behaviors in "now" bucket at once
     */
    maxConcurrency: number;
  };
}

/**
 * simplified remote repo config (blocker.17)
 */
interface BehaviorSourceRepoRemote {
  /**
   * git remote URL
   * @example 'https://github.com/org/repo'
   */
  url: string;
}

class BehaviorDispatchConfig extends DomainLiteral<BehaviorDispatchConfig> {}
```

### 2.3 enums

```ts
type BehaviorGatheredStatus =
  | 'wish'      // only wish defined
  | 'vision'    // wish + vision defined
  | 'criteria'  // wish + vision + criteria defined
  | 'active'    // being worked on
  | 'review'    // in review
  | 'delivered' // complete
  ;

type BehaviorMeasuredPriorityLevel =
  | 'p0'  // critical - must do now
  | 'p1'  // important - should do soon
  | 'p3'  // desired - would be nice
  | 'p5'  // bonus - if time permits
  ;

/**
 * unified urgency level (blocker.18)
 * used for readiness, bandwidth, and decision
 */
type BehaviorTriagedUrgencyLevel =
  | 'now'     // ready/available now
  | 'soon'    // ready/available soon
  | 'later'   // ready/available later
  ;
```

---

## 3. domain.operations

### 3.1 gather skill operations

```
src/domain.operations/behavior/
  getAllBehaviorGathered.ts              // polymorphic: by sources, local, remote
  getOneBehaviorGathered.ts              // single behavior lookup (cache-critical)
  enumBehaviorDirs.ts                    // find .behavior/*/ directories
  computeBehaviorGatheredContentHash.ts  // sha256 hash of directory contents
  loadBehaviorDispatchConfig.ts          // parse rhachet.dispatch.yml
```

#### getAllBehaviorGathered

```ts
/**
 * .what = gathers all behaviors from configured sources (polymorphic)
 * .why = provides input for downstream measure/triage operations
 */
export const getAllBehaviorGathered = async (
  input: {
    by:
      | { sources: BehaviorDispatchConfig['sources'] }
      | { local: { repos: RefByUnique<typeof GitDir>[] } }
      | { remote: { repos: BehaviorSourceRepoRemote[] } };
  },
  context: BehaviorDispatchContext,
): Promise<{ behaviors: BehaviorGathered[]; stats: { ... } }> => {
  // handle polymorphic dispatch
  if ('sources' in input.by) {
    const local = await getAllBehaviorGathered({ by: { local: input.by.sources.local } }, context);
    const remote = input.by.sources.remote
      ? await getAllBehaviorGathered({ by: { remote: input.by.sources.remote } }, context)
      : { behaviors: [] };
    return { behaviors: [...local.behaviors, ...remote.behaviors], stats: { ... } };
  }

  // enumerate behavior directories from specified source type
  const behaviorDirs = 'local' in input.by
    ? await enumBehaviorDirsLocal({ repos: input.by.local.repos }, context)
    : await enumBehaviorDirsRemote({ repos: input.by.remote.repos }, context);

  // gather each behavior
  const behaviors: BehaviorGathered[] = [];
  for (const dir of behaviorDirs) {
    const behavior = await parseBehaviorDir({ dir }, context);
    behaviors.push(behavior);
  }

  return { behaviors, stats: { ... } };
};
```

#### getOneBehaviorGathered

```ts
/**
 * .what = retrieves one gathered behavior by its unique ref
 * .why = enables downstream operations to hydrate gathered entity from ref
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
 *         contentHash so unchanged behaviors skip evaluation entirely
 */
export const getOneBehaviorGathered = withSimpleCacheOnDisk(
  async (
    input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
    context: BehaviorDispatchContext,
  ): Promise<BehaviorGathered> => {
    // check disk cache first (handled by wrapper)

    // if not cached: verify contentHash is still latest at source
    const currentHash = await computeBehaviorGatheredContentHash(
      { behavior: input.by.unique.behavior },
      context,
    );

    // failfast if requested contentHash is stale and not cached
    if (currentHash !== input.by.unique.contentHash) {
      throw new BadRequestError('requested contentHash is stale and not cached', {
        requested: input.by.unique.contentHash,
        current: currentHash,
      });
    }

    // fetch fresh and return
    return await parseBehaviorDir({ behavior: input.by.unique.behavior }, context);
  },
  {
    procedure: { name: 'getOneBehaviorGathered', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

#### computeBehaviorGatheredContentHash

```ts
/**
 * .what = computes sha256 hash of behavior directory contents
 * .why = enables cache invalidation when behavior changes
 * .note = computed ONLY at gather time, reused downstream
 */
export const computeBehaviorGatheredContentHash = async (
  input: {
    dir: string;
  },
  context: BehaviorDispatchContext,
): Promise<string> => {
  // enumerate all files in directory
  const files = await enumFilesRecursive({ dir: input.dir }, context);

  // sort files for deterministic ordering
  const sortedFiles = files.sort();

  // concatenate file contents
  const contents = await Promise.all(
    sortedFiles.map(async (file) => {
      const content = await readFile({ path: file }, context);
      return `${file}:${content}`;
    }),
  );

  // compute sha256 hash
  return sha256(contents.join('\n'));
};
```

### 3.2 deptrace operations (internal to measure)

```
src/domain.operations/behavior/
  getOneBehaviorDeptraced.ts                 // single behavior deptrace (cache-critical)
  parseBehaviorDeptracedDependencies.ts      // extract depends_on from criteria
  computeBehaviorDeptracedTransitiveDeps.ts  // compute transitive closure
  renderBehaviorDeptracedDependenciesMd.ts   // generate dependencies.md output
```

#### getOneBehaviorDeptraced

```ts
/**
 * .what = retrieves or computes deptraced behavior by gathered ref
 * .why = dependency info needed for transitive impact in measure
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
 *         contentHash so unchanged behaviors skip evaluation entirely
 * .note = key criteria: looks up dependencies in .gathered/latest/ directory;
 *         failfast if dependency not found - this scenario MUST have test coverage
 */
export const getOneBehaviorDeptraced = withSimpleCacheOnDisk(
  async (
    input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
    context: BehaviorDispatchContext,
  ): Promise<BehaviorDeptraced> => {
    // hydrate gathered entity
    const gathered = await getOneBehaviorGathered(input, context);

    // parse direct dependencies from criteria
    const parsedDeps = await parseBehaviorDeptracedDependencies(
      { criteria: gathered.criteria },
      context,
    );

    // resolve dependencies against .gathered/latest/ directory
    // key criteria: failfast if dependency not found (must have test coverage)
    const dependsOnDirect: RefByUnique<typeof Behavior>[] = [];
    for (const depRef of parsedDeps) {
      const depPath = `${context.config.output}/.gathered/latest/${depRef.org}/${depRef.repo}/${depRef.name}`;
      const depExists = await directoryExists({ path: depPath }, context);
      if (!depExists) {
        throw new BadRequestError(
          `dependency not found in .gathered/latest/: ${depRef.org}/${depRef.repo}/${depRef.name}`,
          {
            missingDependency: depRef,
            dependentBehavior: gathered.behavior,
            searchedPath: depPath,
          },
        );
      }
      dependsOnDirect.push(depRef);
    }

    // compute transitive closure
    const dependsOnTransitive = await computeBehaviorDeptracedTransitiveDeps(
      { behavior: gathered.behavior, direct: dependsOnDirect },
      context,
    );

    return new BehaviorDeptraced({
      deptracedAt: new Date().toISOString(),
      gathered: { behavior: gathered.behavior, contentHash: gathered.contentHash },
      dependsOnDirect,
      dependsOnTransitive,
    });
  },
  {
    procedure: { name: 'getOneBehaviorDeptraced', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

#### renderBehaviorDeptracedDependenciesMd

```ts
/**
 * .what = renders dependency tree as markdown
 * .why = provides human-readable dependency visualization
 */
export const renderBehaviorDeptracedDependenciesMd = async (
  input: {
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Promise<string> => {
  const lines: string[] = ['# dependencies', ''];

  for (const behavior of input.behaviors) {
    lines.push(`## ${behavior.behavior.org}/${behavior.behavior.repo}/${behavior.behavior.name}`);
    if (behavior.dependsOnDirect.length === 0) {
      lines.push('depends on: (none)');
    } else {
      lines.push('depends on:');
      // render as tree with urgency annotations
      for (const dep of behavior.dependsOnDirect) {
        lines.push(`  - ${dep.org}/${dep.repo}/${dep.name}`);
        // include transitive deps as nested tree
      }
    }
    lines.push('');
  }

  return lines.join('\n');
};
```

### 3.3 measure operations

```
src/domain.operations/behavior/
  getOneBehaviorMeasured.ts                   // single behavior measure (cache-critical)
  computeBehaviorMeasuredGainLeverage.ts      // leverage = time gained (author + support)
  computeBehaviorMeasuredGainYieldage.ts      // yieldage = cash gained (probabilistic)
  computeBehaviorMeasuredGainComposite.ts     // gain(+$) = leverage + yieldage → $$
  computeBehaviorMeasuredCostAttend.ts        // attend = time cost
  computeBehaviorMeasuredCostExpend.ts        // expend = cash cost
  computeBehaviorMeasuredCostComposite.ts     // cost(-$) = attend + expend → $$
  computeBehaviorMeasuredReverseDeps.ts       // invert dependency graph for transitive impact
  assignBehaviorMeasuredPriority.ts           // map effect(~$) to priority level
```

#### getOneBehaviorMeasured

```ts
/**
 * .what = retrieves or computes measured behavior by gathered ref
 * .why = scoring behaviors for prioritization requires gain/cost analysis
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
 *         contentHash so unchanged behaviors skip evaluation entirely
 */
export const getOneBehaviorMeasured = withSimpleCacheOnDisk(
  async (
    input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
    context: BehaviorDispatchContext,
  ): Promise<BehaviorMeasured> => {
    // hydrate gathered entity
    const gathered = await getOneBehaviorGathered(input, context);

    // get deptraced for dependency info
    const deptraced = await getOneBehaviorDeptraced(input, context);

    // compute gain dimensions
    const leverage = await computeBehaviorMeasuredGainLeverage({ gathered, deptraced }, context);
    const yieldage = await computeBehaviorMeasuredGainYieldage({ gathered, deptraced }, context);
    const gainComposite = computeBehaviorMeasuredGainComposite({ gathered, leverage, yieldage }, context);

    // compute cost dimensions
    const attend = await computeBehaviorMeasuredCostAttend({ gathered, deptraced }, context);
    const expend = await computeBehaviorMeasuredCostExpend({ gathered, deptraced }, context);
    const costComposite = computeBehaviorMeasuredCostComposite({ gathered, attend, expend }, context);

    // compute effect and assign priority
    const effect = gainComposite - costComposite;
    const priority = assignBehaviorMeasuredPriority({ effect }, context);

    return new BehaviorMeasured({
      measuredAt: new Date().toISOString(),
      gathered: { behavior: gathered.behavior, contentHash: gathered.contentHash },
      gain: { dimensions: { leverage, yieldage }, composite: gainComposite },
      cost: { dimensions: { attend, expend }, composite: costComposite },
      effect,
      priority,
    });
  },
  {
    procedure: { name: 'getOneBehaviorMeasured', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

#### computeBehaviorMeasuredGainLeverage

```ts
/**
 * .what = computes leverage for a behavior
 * .why = leverage = time gained (time can only be saved)
 * .note = includes transitive impact via blockee calculation
 * .ref = 3.1.research.domain.leverage.v9.i1.md
 */
export const computeBehaviorMeasuredGainLeverage = async (
  input: {
    gathered: BehaviorGathered;
    deptraced: BehaviorDeptraced;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredGainLeverage> => {
  // author leverage from brain.repl analysis
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const authorAnalysis = await context.brain.repl({
    prompt: `analyze author leverage for behavior: ${behaviorPath}
    - how much time saved to create (mins/use)?
    - what code blocks, paths, khues avoided?`,
    schema: authorLeverageSchema,
  });

  // support leverage from brain.repl analysis
  const supportAnalysis = await context.brain.repl({
    prompt: `analyze support leverage for behavior: ${behaviorPath}
    - how much time saved to fix (mins/fail)?
    - what signals and defences added?`,
    schema: supportLeverageSchema,
  });

  // compute composite with author/support weights
  const { author, support } = input.config.criteria.gain.leverage.weights;
  const composite = (authorAnalysis.time * author) + (supportAnalysis.time * support);

  // compute transitive leverage from unblocked behaviors
  const behaviorKey = serialize(input.deptraced.behavior);
  const blockees = input.reverseDeps.get(behaviorKey) || [];
  const transitive = await computeTransitiveLeverage({ blockees }, context);

  return {
    direct: {
      author: authorAnalysis.time,
      support: supportAnalysis.time,
      composite,
    },
    transitive,
  };
};
```

#### computeBehaviorMeasuredGainYieldage

```ts
/**
 * .what = computes yieldage for a behavior
 * .why = yieldage = cash gained (cash can be saved or earned)
 * .note = includes transitive impact via blockee calculation
 */
export const computeBehaviorMeasuredGainYieldage = async (
  input: {
    gathered: BehaviorGathered;
    deptraced: BehaviorDeptraced;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredGainYieldage> => {
  // base yield from brain.repl analysis
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const baseYield = await context.brain.repl({
    prompt: `analyze yieldage for behavior: ${behaviorPath}
    - what cash value does this deliver (revenue or savings)?
    - what are the possible outcomes and their probabilities?`,
    schema: yieldageSchema,
  });

  // compute transitive yieldage from unblocked behaviors
  const behaviorKey = serialize(input.deptraced.behavior);
  const blockees = input.reverseDeps.get(behaviorKey) || [];
  const transitive = await computeTransitiveYieldage({ blockees }, context);

  // build chances array
  const chances: BehaviorMeasuredGainYieldageChance[] = [
    { yieldage: 0, probability: baseYield.failureProbability },
    { yieldage: baseYield.successYield, probability: 1 - baseYield.failureProbability },
  ];

  // compute expected value
  const expected = chances.reduce(
    (sum, chance) => sum + chance.yieldage * chance.probability,
    0,
  );

  return {
    direct: { chances, expected },
    transitive,
  };
};
```

#### computeBehaviorMeasuredGainComposite

```ts
/**
 * .what = computes gain(+$) = leverage + yieldage → converted to $$
 * .why = combines time and cash gains into absolute value
 */
export const computeBehaviorMeasuredGainComposite = (
  input: {
    leverage: BehaviorMeasuredGainLeverage;
    yieldage: BehaviorMeasuredGainYieldage;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): number => {
  const { dollars, hours } = input.config.criteria.convert.equate;
  const ratePerMinute = (dollars / hours) / 60;

  // convert leverage (time in mins) to $$
  const leverageDollars = (input.leverage.composite + input.leverage.transitive) * ratePerMinute;

  // yieldage is already in $$
  const yieldageDollars = input.yieldage.expected + input.yieldage.transitive;

  return leverageDollars + yieldageDollars;
};
```

#### computeBehaviorMeasuredCostAttend

```ts
/**
 * .what = computes attend (time cost) for a behavior
 * .why = attend = time cost (attention required to complete)
 */
export const computeBehaviorMeasuredCostAttend = async (
  input: {
    deptraced: BehaviorDeptraced;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredCostAttend> => {
  // analyze time cost from brain.repl
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const analysis = await context.brain.repl({
    prompt: `analyze time cost for behavior: ${behaviorPath}
    - how many hours to complete?
    - what is the complexity factor (1.0 = normal)?`,
    schema: attendSchema,
  });

  // compute composite
  const composite = analysis.hours * analysis.complexity;

  return {
    hours: analysis.hours,
    complexity: analysis.complexity,
    composite,
  };
};
```

#### computeBehaviorMeasuredCostExpend

```ts
/**
 * .what = computes expend (cash cost) for a behavior
 * .why = expend = cash cost (expenditure required to complete)
 */
export const computeBehaviorMeasuredCostExpend = async (
  input: {
    deptraced: BehaviorDeptraced;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasuredCostExpend> => {
  // analyze cash cost from brain.repl
  const behaviorPath = `${input.deptraced.behavior.org}/${input.deptraced.behavior.repo}/${input.deptraced.behavior.name}`;
  const analysis = await context.brain.repl({
    prompt: `analyze cash cost for behavior: ${behaviorPath}
    - what direct costs (tools, services)?
    - what indirect costs (overhead)?`,
    schema: expendSchema,
  });

  // compute composite
  const composite = analysis.direct + analysis.indirect;

  return {
    direct: analysis.direct,
    indirect: analysis.indirect,
    composite,
  };
};
```

#### computeBehaviorMeasuredCostComposite

```ts
/**
 * .what = computes cost(-$) = attend + expend → converted to $$
 * .why = combines time and cash costs into absolute value
 */
export const computeBehaviorMeasuredCostComposite = (
  input: {
    attend: BehaviorMeasuredCostAttend;
    expend: BehaviorMeasuredCostExpend;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): number => {
  const { dollars, hours } = input.config.criteria.convert.equate;
  const ratePerHour = dollars / hours;

  // convert attend (time in hours) to $$
  const attendDollars = input.attend.composite * ratePerHour;

  // expend is already in $$
  const expendDollars = input.expend.composite;

  return attendDollars + expendDollars;
};
```

#### computeBehaviorMeasuredReverseDeps

```ts
/**
 * .what = inverts dependency graph to find blockees
 * .why = enables transitive impact calculation for both leverage and yieldage
 * .note = deptrace only tracks dependsOn*; this computes dependedBy*
 */
export const computeBehaviorMeasuredReverseDeps = (
  input: {
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Map<string, string[]> => {
  const reverseDeps = new Map<string, string[]>();

  // initialize all behaviors with empty arrays
  for (const behavior of input.behaviors) {
    const key = serialize(behavior.behavior);
    reverseDeps.set(key, []);
  }

  // invert the graph
  for (const behavior of input.behaviors) {
    const behaviorKey = serialize(behavior.behavior);
    for (const dep of behavior.dependsOnTransitive) {
      const depKey = serialize(dep);
      const blockees = reverseDeps.get(depKey) || [];
      blockees.push(behaviorKey);
      reverseDeps.set(depKey, blockees);
    }
  }

  return reverseDeps;
};
```

### 3.4 triage operations

```
src/domain.operations/behavior/
  getAllBehaviorTriaged.ts                // collective triage (cache-critical)
  computeBehaviorTriagedReadiness.ts      // determine readiness from deps
  computeBehaviorTriagedBandwidth.ts      // determine bandwidth from constraints
  renderBehaviorTriagedPrioritizationMd.ts   // generate prioritization.md
  renderBehaviorTriagedPrioritizationJson.ts // generate prioritization.json
```

#### getAllBehaviorTriaged

```ts
/**
 * .what = triages all behaviors into urgency buckets
 * .why = provides actionable prioritization for users
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
 *         contentHashes so unchanged behavior set skips evaluation entirely
 */
export const getAllBehaviorTriaged = withSimpleCacheOnDisk(
  async (
    input: {
      over: { behaviors: RefByUnique<typeof BehaviorGathered>[] };
      config: BehaviorDispatchConfig;
    },
    context: BehaviorDispatchContext,
  ): Promise<{ behaviors: BehaviorTriaged[]; stats: { ... } }> => {
    // measure each behavior (each call is cached individually)
    const measured: BehaviorMeasured[] = [];
    for (const ref of input.over.behaviors) {
      const result = await getOneBehaviorMeasured({ by: { unique: ref } }, context);
      measured.push(result);
    }

    // sort by priority then effect score
    const sorted = [...measured].sort((a, b) => {
      const priorityOrder = { p0: 0, p1: 1, p3: 2, p5: 3 };
      if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      }
      return b.effect - a.effect;
    });

    // triage each behavior
    const triaged: BehaviorTriaged[] = [];
    let nowCount = 0;
    for (const m of sorted) {
      const readiness = computeBehaviorTriagedReadiness({ measured: m, allBehaviors: sorted }, context);
      const bandwidth: BehaviorTriagedUrgencyLevel =
        nowCount < input.config.constraints.maxConcurrency ? 'now'
        : nowCount < input.config.constraints.maxConcurrency * 2 ? 'soon'
        : 'later';
      const decision = minUrgency(readiness, bandwidth);

      triaged.push({
        triagedAt: new Date().toISOString(),
        gathered: m.gathered,
        dimensions: { readiness, bandwidth },
        decision,
        priority: m.priority,
      });

      if (decision === 'now') nowCount++;
    }

    return {
      behaviors: triaged,
      stats: {
        all: triaged.length,
        now: triaged.filter((b) => b.decision === 'now').length,
        soon: triaged.filter((b) => b.decision === 'soon').length,
        later: triaged.filter((b) => b.decision === 'later').length,
      },
    };
  },
  {
    procedure: { name: 'getAllBehaviorTriaged', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

### 3.5 prioritize operations

```
src/domain.operations/behavior/
  getAllBehaviorPrioritized.ts  // collective prioritization (cache-critical)
```

#### getAllBehaviorPrioritized

```ts
/**
 * .what = collective prioritization over all behaviors
 * .why = provides one-command prioritization for users
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
 *         contentHashes so unchanged behavior set skips evaluation entirely
 */
export const getAllBehaviorPrioritized = withSimpleCacheOnDisk(
  async (
    input: {
      over: { behaviors: RefByUnique<typeof BehaviorGathered>[] };
      config: BehaviorDispatchConfig;
    },
    context: BehaviorDispatchContext,
  ): Promise<{
    behaviors: BehaviorTriaged[];
    outputs: {
      prioritizationMd: string;
      prioritizationJson: string;
      dependenciesMd: string;
    };
  }> => {
    // triage all behaviors (each getOneBehaviorMeasured call is cached)
    const triageResult = await getAllBehaviorTriaged(
      { over: input.over, config: input.config },
      context,
    );

    // render dependencies from deptraced data
    const deptraced: BehaviorDeptraced[] = [];
    for (const ref of input.over.behaviors) {
      const d = await getOneBehaviorDeptraced({ by: { unique: ref } }, context);
      deptraced.push(d);
    }
    const dependenciesMd = await renderBehaviorDeptracedDependenciesMd(
      { behaviors: deptraced },
      context,
    );

    // render prioritization outputs
    const prioritizationMd = await renderBehaviorTriagedPrioritizationMd(
      { behaviors: triageResult.behaviors },
      context,
    );
    const prioritizationJson = JSON.stringify(triageResult.behaviors, null, 2);

    // archive previous outputs if changed
    await archiveBehaviorIfChanged(
      { path: `${input.config.output}/prioritization.md`, content: prioritizationMd },
      context,
    );

    // write outputs
    await writeFile({ path: `${input.config.output}/prioritization.md`, content: prioritizationMd }, context);
    await writeFile({ path: `${input.config.output}/prioritization.json`, content: prioritizationJson }, context);
    await writeFile({ path: `${input.config.output}/dependencies.md`, content: dependenciesMd }, context);

    return {
      behaviors: triageResult.behaviors,
      outputs: {
        prioritizationMd,
        prioritizationJson,
        dependenciesMd,
      },
    };
  },
  {
    procedure: { name: 'getAllBehaviorPrioritized', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

### 3.6 coordinate operations

```
src/domain.operations/behavior/
  getAllBehaviorCoordinated.ts              // collective coordination (cache-critical)
  groupBehaviorWorkstreams.ts               // cluster behaviors into workstreams
  rankBehaviorWorkstreams.ts                // assign ranks based on priority
  renderBehaviorWorkstreamCoordinationMd.ts // generate coordination.md
```

#### getAllBehaviorCoordinated

```ts
/**
 * .what = collective coordination over all behaviors into workstreams
 * .why = enables team coordination and workstream prioritization
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
 *         contentHashes so unchanged behavior set skips evaluation entirely
 */
export const getAllBehaviorCoordinated = withSimpleCacheOnDisk(
  async (
    input: {
      over: { behaviors: RefByUnique<typeof BehaviorGathered>[] };
      config: BehaviorDispatchConfig;
    },
    context: BehaviorDispatchContext,
  ): Promise<{
    workstreams: BehaviorWorkstream[];
    outputs: {
      coordinationMd: string;
      coordinationJson: string;
    };
  }> => {
    // triage all behaviors if needed (each call is cached)
    const triageResult = await getAllBehaviorTriaged(
      { over: input.over, config: input.config },
      context,
    );

    // group into workstreams
    const workstreams = await groupBehaviorWorkstreams(
      { behaviors: triageResult.behaviors },
      context,
    );

    // rank workstreams
    const ranked = await rankBehaviorWorkstreams({ workstreams }, context);

    // render outputs
    const coordinationMd = await renderBehaviorWorkstreamCoordinationMd(
      { workstreams: ranked },
      context,
    );
    const coordinationJson = JSON.stringify(ranked, null, 2);

    // archive if changed
    await archiveBehaviorIfChanged(
      { path: `${input.config.output}/coordination.md`, content: coordinationMd },
      context,
    );

    // write outputs
    await writeFile({ path: `${input.config.output}/coordination.md`, content: coordinationMd }, context);
    await writeFile({ path: `${input.config.output}/coordination.json`, content: coordinationJson }, context);

    return {
      workstreams: ranked,
      outputs: { coordinationMd, coordinationJson },
    };
  },
  {
    procedure: { name: 'getAllBehaviorCoordinated', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

### 3.7 shared operations

```
src/domain.operations/behavior/
  findsertBehaviorDispatchDir.ts   // idempotent output dir initialization
  archiveBehaviorIfChanged.ts      // archive prior outputs
  loadBehaviorGathered.ts          // load from cache
```

#### findsertBehaviorDispatchDir

```ts
/**
 * .what = creates output directory with readme if not exists
 * .why = ensures consistent output structure across skills
 * .note = idempotent - safe to call multiple times
 */
export const findsertBehaviorDispatchDir = async (
  input: {
    path: string;
  },
  context: BehaviorDispatchContext,
): Promise<void> => {
  // check if directory exists
  const exists = await directoryExists({ path: input.path }, context);
  if (exists) return;

  // create directory structure
  await mkdir({ path: input.path }, context);
  await mkdir({ path: `${input.path}/.gathered` }, context);
  await mkdir({ path: `${input.path}/.deptraced` }, context);
  await mkdir({ path: `${input.path}/.measured` }, context);
  await mkdir({ path: `${input.path}/.triaged` }, context);
  await mkdir({ path: `${input.path}/.archive` }, context);

  // write readme
  const readme = `# .dispatch output

this directory contains dispatcher skill outputs.

## cache behavior

the .* directories (.gathered/, .deptraced/, .measured/, .triaged/) are caches.
they are reused in subsequent invocations to maximize efficiency:

- only behaviors with changed contentHash are reprocessed
- unchanged behaviors reuse cached results
- delete a .* directory to force recomputation of that stage

## archive behavior

when outputs change, prior versions are archived to .archive/:

- files are named {filename}.{isoTimestamp}.bak.md
- unchanged runs do not create archives
- archives are sorted by timestamp (ls shows history)

## files

- prioritization.md: human-readable summary of triaged behaviors
- prioritization.json: machine-readable data for downstream tools
- dependencies.md: dependency tree per behavior
- coordination.md: workstream map (after coordinate skill)
- coordination.json: machine-readable workstream data
`;

  await writeFile({ path: `${input.path}/readme.md`, content: readme }, context);
};
```

---

## 4. caching via with-simple-cache

operations use `withSimpleCacheOnDisk` from `with-simple-cache` for automatic read-through disk caching. the wrapper handles everything automatically:
- procedure name + version for cache namespace
- cache key derivation from serialized input (including `RefByUnique` refs with contentHash)
- filesystem-safe key generation
- serialization/deserialization of cached values
- read-through: on cache miss, executes logic and caches result

no daos needed - just wrap operations with `withSimpleCacheOnDisk`.

**cache-critical pattern**: all operations that take `{ by: { unique: RefByUnique<typeof BehaviorGathered> } }` are automatically cacheable because the ref includes `contentHash`. unchanged behaviors → cache hit → skip evaluation.

### 4.1 example: cached single-behavior operation

```ts
import { withSimpleCacheOnDisk } from 'with-simple-cache';

/**
 * .what = retrieves or computes deptraced behavior by gathered ref
 * .why = avoids recomputing deptrace for unchanged behaviors
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
 *         contentHash so unchanged behaviors skip evaluation entirely
 */
export const getOneBehaviorDeptraced = withSimpleCacheOnDisk(
  async (
    input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
    context: BehaviorDispatchContext,
  ): Promise<BehaviorDeptraced> => {
    // hydrate gathered entity from ref
    const gathered = await getOneBehaviorGathered(input, context);

    // parse direct dependencies from criteria
    const dependsOnDirect = await parseBehaviorDeptracedDependencies(
      { criteria: gathered.criteria },
      context,
    );

    // compute transitive closure
    const dependsOnTransitive = await computeBehaviorDeptracedTransitiveDeps(
      { behavior: gathered.behavior, direct: dependsOnDirect },
      context,
    );

    return new BehaviorDeptraced({
      deptracedAt: new Date().toISOString(),
      gathered: { behavior: gathered.behavior, contentHash: gathered.contentHash },
      dependsOnDirect,
      dependsOnTransitive,
    });
  },
  {
    procedure: { name: 'getOneBehaviorDeptraced', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

### 4.2 example: cached collective operation

```ts
/**
 * .what = collective triage over all behaviors
 * .why = provides urgency assignment for prioritization
 * .note = cache-critical: wrapped with withSimpleCacheOnDisk; refs include
 *         contentHashes so unchanged behavior set skips evaluation entirely
 */
export const getAllBehaviorTriaged = withSimpleCacheOnDisk(
  async (
    input: {
      over: { behaviors: RefByUnique<typeof BehaviorGathered>[] };
      config: BehaviorDispatchConfig;
    },
    context: BehaviorDispatchContext,
  ): Promise<{ behaviors: BehaviorTriaged[]; stats: { ... } }> => {
    // measure each behavior (each call is individually cached)
    const measured: BehaviorMeasured[] = [];
    for (const ref of input.over.behaviors) {
      const result = await getOneBehaviorMeasured({ by: { unique: ref } }, context);
      measured.push(result);
    }

    // sort and triage
    // ...

    return { behaviors: triaged, stats: { ... } };
  },
  {
    procedure: { name: 'getAllBehaviorTriaged', version: 'v1' },
    directory: ({ fromInput }) => fromInput[1].cacheDir,
  },
);
```

### 4.3 context.cacheDir initialization

the cache directory is passed via context:

```ts
/**
 * .what = generates dispatch context with cache directory
 * .why = provides cache path for all downstream operations
 */
export const genBehaviorDispatchContext = async (
  input: { config: BehaviorDispatchConfig },
): Promise<BehaviorDispatchContext> => {
  return {
    config: input.config,
    cacheDir: { mounted: { path: `${input.config.output}/.cache` } },
    log: console,
  };
};
```

---

## 5. directory structure

```
src/
  contract/
    cmd/
      getAllBehaviorGathered.ts     // npx rhachet run --skill gather
      getAllBehaviorTriaged.ts      // npx rhachet run --skill triage
      getAllBehaviorPrioritized.ts  // npx rhachet run --skill prioritize
      getAllBehaviorCoordinated.ts  // npx rhachet run --skill coordinate

  domain.objects/
    Behavior.ts
    BehaviorGathered.ts
    BehaviorDeptraced.ts
    BehaviorMeasured.ts
    BehaviorTriaged.ts
    BehaviorWorkstream.ts
    BehaviorMeasuredGain.ts
    BehaviorMeasuredCost.ts
    BehaviorMeasuredGainLeverage.ts
    BehaviorMeasuredGainYieldage.ts
    BehaviorMeasuredGainYieldageChance.ts
    BehaviorMeasuredCostAttend.ts
    BehaviorMeasuredCostExpend.ts
    BehaviorWorkstreamDeliverable.ts
    BehaviorDispatchConfig.ts
    BehaviorSourceRepoRemote.ts
    BehaviorGatheredStatus.ts
    BehaviorMeasuredPriorityLevel.ts
    BehaviorTriagedUrgencyLevel.ts

  domain.operations/
    behavior/
      // gather operations
      getAllBehaviorGathered.ts                 // polymorphic: by sources, local, remote
      getOneBehaviorGathered.ts                 // single behavior lookup (cache-critical)
      enumBehaviorDirs.ts
      parseBehaviorDir.ts
      computeBehaviorGatheredContentHash.ts
      loadBehaviorDispatchConfig.ts
      // deptrace operations (internal to measure)
      getOneBehaviorDeptraced.ts                // single behavior deptrace (cache-critical)
      parseBehaviorDeptracedDependencies.ts
      computeBehaviorDeptracedTransitiveDeps.ts
      renderBehaviorDeptracedDependenciesMd.ts
      // measure operations
      getOneBehaviorMeasured.ts                 // single behavior measure (cache-critical)
      computeBehaviorMeasuredGainYieldage.ts
      computeBehaviorMeasuredGainLeverage.ts
      computeBehaviorMeasuredGainComposite.ts
      computeBehaviorMeasuredCostAttend.ts
      computeBehaviorMeasuredCostExpend.ts
      computeBehaviorMeasuredCostComposite.ts
      computeBehaviorMeasuredReverseDeps.ts
      assignBehaviorMeasuredPriority.ts
      // triage operations
      getAllBehaviorTriaged.ts                  // collective triage (cache-critical)
      computeBehaviorTriagedReadiness.ts
      computeBehaviorTriagedBandwidth.ts
      renderBehaviorTriagedPrioritizationMd.ts
      renderBehaviorTriagedPrioritizationJson.ts
      // prioritize operations
      getAllBehaviorPrioritized.ts              // collective prioritization (cache-critical)
      // coordinate operations
      getAllBehaviorCoordinated.ts              // collective coordination (cache-critical)
      groupBehaviorWorkstreams.ts
      rankBehaviorWorkstreams.ts
      renderBehaviorWorkstreamCoordinationMd.ts
      // shared operations
      findsertBehaviorDispatchDir.ts
      archiveBehaviorIfChanged.ts
```

---

## 6. design decisions

### 6.1 contentHash computed at gather time only

**decision**: contentHash is computed once during gather and stored in BehaviorGathered. downstream skills (deptrace, measure, triage) read contentHash from gathered output rather than recomputing.

**rationale**:
- ensures consistent cache key across all stages
- avoids redundant computation
- single source of truth for "behavior changed"

### 6.2 deptrace only tracks dependsOn* (not dependedBy*)

**decision**: BehaviorDeptraced only contains dependsOnDirect and dependsOnTransitive. reverse dependencies (dependedBy*) are computed at measure time via graph inversion.

**rationale**:
- keeps deptrace output minimal and focused
- avoids dual-storage of same relationship
- blockee calculation is only needed for yieldage scoring

### 6.3 probabilistic yieldage chances

**decision**: yieldage is modeled as an array of chances { yieldage, probability }[] rather than a single number.

**rationale**:
- captures uncertainty in value delivery
- failure probability (yieldage: 0) is explicit
- expected value computed as weighted sum
- enables risk-aware prioritization

### 6.4 dimensions/decision structure

**decision**: both BehaviorMeasured and BehaviorTriaged use a dimensions/decision structure.

**rationale**:
- dimensions capture the inputs to decision
- decision is the computed output
- makes reasoning transparent and auditable
- enables debugging ("why is this behavior p1?")

### 6.5 triage is deterministic (no brain.repl)

**decision**: triage skill does not use brain.repl. readiness is computed from dependency status, bandwidth from constraints.

**rationale**:
- triage should be predictable and reproducible
- same inputs always produce same outputs
- reduces complexity and cost
- brain.repl reserved for measure skill where judgment is needed

### 6.6 findsertDispatchDir for idempotent output initialization

**decision**: all skills call findsertDispatchDir before writing output. this creates the output directory structure and readme.md if not exists.

**rationale**:
- ensures consistent output structure
- readme.md explains cache and archive behavior to users
- idempotent - safe to call multiple times
- single skill can run independently without prior setup

### 6.7 dependencies.md generated by deptrace skill

**decision**: deptrace skill produces dependencies.md as an output, not prioritize composite.

**rationale**:
- dependency information is available immediately after deptrace
- allows users to inspect deps without running full pipeline
- prioritize just passes through the output

### 6.8 priority levels use odd numbers only

**decision**: priority levels are p0, p1, p3, p5 (skipping p2 and p4).

**rationale**:
- leaves room for future intermediate levels if needed
- common pattern in issue trackers
- provides clear separation between levels

### 6.9 cache invalidation via contentHash matching

**decision**: downstream skills check `contentHash` match before returning cached results. if contentHash differs from gathered behavior, cache is invalidated.

**rationale**:
- simple and reliable invalidation
- no need for timestamp comparison
- content-addressable caching

### 6.10 interactive mode out of scope

**decision**: interactive mode (user prompts during skill execution) is explicitly out of scope.

**rationale**:
- keeps initial implementation simple
- users can manually edit output files for overrides
- future enhancement if needed

---

## 7. context type

```ts
interface BehaviorDispatchContext {
  /**
   * loaded dispatch config
   */
  config: BehaviorDispatchConfig;

  /**
   * cache directory for withSimpleCacheOnDisk
   * passed via directory: ({ fromInput }) => fromInput[1].cacheDir
   */
  cacheDir: { mounted: { path: string } };

  /**
   * brain access for AI-powered analysis
   */
  brain: {
    repl: <T>(input: { prompt: string; schema: ZodSchema<T> }) => Promise<T>;
  };

  /**
   * logging
   */
  log: LogMethods;
}
```

---

## 8. traceability matrix

| wish                       | skill              | mechanism                                                                            |
| -------------------------- | ------------------ | ------------------------------------------------------------------------------------ |
| "where to start?"          | triageBehavior     | decision = min(readiness, bandwidth) → now/soon/later                                |
| "which is most important?" | measureBehavior    | effect(~$) = gain(+$) - cost(-$); higher effect = higher priority                    |
| "which unblocks the most?" | measureBehavior    | computeBehaviorMeasuredReverseDeps → blockee impact → transitive leverage + yieldage |
| "too many workstreams"     | coordinateBehavior | groupBehaviorWorkstreams → named workstreams                                         |
| "what is even active?"     | coordinateBehavior | workstream map with urgency annotations                                              |
| "which to review first?"   | coordinateBehavior | rankBehaviorWorkstreams → review in rank order                                       |
| "cache artifacts"          | all skills         | contentHash + byContentHash cache check                                              |
| "parallelize work"         | coordinateBehavior | independent behaviors → parallel workstreams                                         |
