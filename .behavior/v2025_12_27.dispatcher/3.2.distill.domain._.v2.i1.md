# domain distillation: dispatcher role v2

this document declares the domain model for the dispatcher role, enabling prioritization and coordination of behaviors across repositories.

---

## 1. usecases and contracts

### 1.1 usecase: prioritize backlog

**user story**: as a developer with many behaviors to build, i want to see which ones to work on first, so i can maximize impact.

**contract**:
```ts
// input: rhachet.dispatch.yml config
// output: prioritization.md, prioritization.json, dependencies.md

const result = await prioritizeBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorPrioritizeResult {
  behaviors: BehaviorTriaged[];
  outputs: {
    prioritizationMd: string;   // .dispatch/prioritization.md
    prioritizationJson: string; // .dispatch/prioritization.json
    dependenciesMd: string;     // .dispatch/dependencies.md
  };
}
```

### 1.2 usecase: coordinate workstreams

**user story**: as a team lead with multiple parallel workstreams, i want to see how work can be organized and which workstreams to prioritize for review.

**contract**:
```ts
// input: triaged behaviors (from prioritize)
// output: coordination.md, coordination.json

const result = await coordinateBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorCoordinateResult {
  workstreams: BehaviorWorkstream[];
  outputs: {
    coordinationMd: string;   // .dispatch/coordination.md
    coordinationJson: string; // .dispatch/coordination.json
  };
}
```

### 1.3 usecase: gather behaviors

**user story**: as a dispatcher skill, i need to collect all behaviors from configured sources to analyze them.

**contract**:
```ts
// input: sources from config
// output: .gathered/*.gathered.json per behavior

const result = await gatherBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorGatherResult {
  behaviors: BehaviorGathered[];
  stats: {
    reposScanned: number;
    behaviorsFound: number;
    behaviorsChanged: number;
  };
}
```

### 1.4 usecase: trace dependencies

**user story**: as a dispatcher skill, i need to trace which behaviors depend on which others to compute transitive impact.

**contract**:
```ts
// input: gathered behaviors
// output: .deptraced/*.deptraced.json per behavior, dependencies.md

const result = await deptraceBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorGathered[],
}, context);

// result shape
interface BehaviorDeptraceResult {
  behaviors: BehaviorDeptraced[];
  outputs: {
    dependenciesMd: string; // .dispatch/dependencies.md
  };
  stats: {
    all: number;
  };
}
```

### 1.5 usecase: measure behaviors

**user story**: as a dispatcher skill, i need to score behaviors by yieldage, leverage, and cost to determine priority.

**contract**:
```ts
// input: deptraced behaviors
// output: .measured/*.measured.json per behavior

const result = await measureBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorDeptraced[],
}, context);

// result shape
interface BehaviorMeasureResult {
  behaviors: BehaviorMeasured[];
  stats: {
    all: number;
  };
}
```

### 1.6 usecase: triage behaviors

**user story**: as a dispatcher skill, i need to assign urgency (now/soon/later) based on readiness and bandwidth constraints.

**contract**:
```ts
// input: measured behaviors
// output: .triaged/*.triaged.json per behavior

const result = await triageBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorMeasured[],
}, context);

// result shape
interface BehaviorTriageResult {
  behaviors: BehaviorTriaged[];
  stats: {
    all: number;
    now: number;
    soon: number;
    later: number;
  };
}
```

---

## 2. domain.objects

### 2.1 entities

#### BehaviorGathered

represents a behavior after collection from source repositories.

```ts
interface BehaviorGathered {
  /**
   * composite key: {org}/{repo}/{behaviorName}
   */
  ref: string;

  /**
   * organization or owner of the repo
   */
  org: string;

  /**
   * repository name
   */
  repo: string;

  /**
   * behavior directory name (e.g., "v2025_01_01.auth-flow")
   */
  name: string;

  /**
   * sha256 hash of behavior directory contents
   * computed at gather time, reused downstream for cache invalidation
   */
  contentHash: string;

  /**
   * current status of the behavior
   */
  status: BehaviorStatus;

  /**
   * files within the behavior directory
   */
  files: BehaviorFile[];

  /**
   * parsed wish document content (0.wish.md)
   */
  wish: string | null;

  /**
   * parsed vision document content (1.vision.md)
   */
  vision: string | null;

  /**
   * parsed criteria document content (2.criteria.md)
   */
  criteria: string | null;

  /**
   * timestamp when gathered
   */
  gatheredAt: string;
}

class BehaviorGathered extends DomainEntity<BehaviorGathered> {
  public static primary = ['ref'] as const;
  public static unique = ['org', 'repo', 'name'] as const;
}
```

#### BehaviorDeptraced

represents a behavior after dependency analysis.

```ts
interface BehaviorDeptraced {
  /**
   * reference to gathered behavior
   */
  ref: string;

  /**
   * content hash from gathered behavior (for cache key)
   */
  contentHash: string;

  /**
   * behaviors this one directly depends on
   */
  dependsOnDirect: BehaviorRef[];

  /**
   * all behaviors this one depends on (transitive closure)
   */
  dependsOnTransitive: BehaviorRef[];

  /**
   * timestamp when deptraced
   */
  deptracedAt: string;
}

class BehaviorDeptraced extends DomainEntity<BehaviorDeptraced> {
  public static primary = ['ref'] as const;
  public static unique = ['ref'] as const;
}
```

#### BehaviorMeasured

represents a behavior after measurement scoring.

```ts
interface BehaviorMeasured {
  /**
   * reference to deptraced behavior
   */
  ref: string;

  /**
   * content hash from gathered behavior (for cache key)
   */
  contentHash: string;

  /**
   * gain: value delivered by completing this behavior
   */
  gain: {
    dimensions: {
      /**
       * probabilistic yield model
       */
      yieldage: BehaviorYieldage;
      /**
       * leverage multiplier (maintenance, velocity impact)
       */
      leverage: number;
    };
    /**
     * composite gain = yieldage.expected * leverage
     */
    composite: number;
  };

  /**
   * cost: resources required to complete this behavior
   */
  cost: {
    dimensions: {
      /**
       * time cost in hours
       */
      time: number;
      /**
       * monetary cost in dollars
       */
      money: number | null;
      /**
       * attention cost (cognitive load, context-switching)
       */
      attention: number;
    };
    /**
     * composite cost = weighted sum of dimensions
     */
    composite: number;
  };

  /**
   * decision score = gain.composite / cost.composite
   * higher = more valuable per unit cost
   */
  decision: number;

  /**
   * assigned priority level: p0, p1, p3, p5
   */
  priority: PriorityLevel;

  /**
   * timestamp when measured
   */
  measuredAt: string;
}

class BehaviorMeasured extends DomainEntity<BehaviorMeasured> {
  public static primary = ['ref'] as const;
  public static unique = ['ref'] as const;
}
```

#### BehaviorTriaged

represents a behavior after urgency assignment.

```ts
interface BehaviorTriaged {
  /**
   * reference to measured behavior
   */
  ref: string;

  /**
   * content hash from gathered behavior (for cache key)
   */
  contentHash: string;

  /**
   * triage dimensions
   */
  dimensions: {
    /**
     * readiness level: now | soon | later | blocked
     * based on dependency status
     */
    readiness: ReadinessLevel;
    /**
     * bandwidth level: now | soon | later
     * based on concurrency constraints
     */
    bandwidth: BandwidthLevel;
  };

  /**
   * decision = min(readiness, bandwidth)
   * determines urgency bucket
   */
  decision: UrgencyLevel;

  /**
   * priority from measurement (carried forward)
   */
  priority: PriorityLevel;

  /**
   * timestamp when triaged
   */
  triagedAt: string;
}

class BehaviorTriaged extends DomainEntity<BehaviorTriaged> {
  public static primary = ['ref'] as const;
  public static unique = ['ref'] as const;
}
```

#### BehaviorWorkstream

represents a grouping of related behaviors into a parallelizable workstream.

```ts
interface BehaviorWorkstream {
  /**
   * workstream identifier
   */
  id: string;

  /**
   * human-readable name (e.g., "auth foundation")
   */
  name: string;

  /**
   * rank for prioritization (1 = highest)
   */
  rank: number;

  /**
   * aggregate priority of behaviors in workstream
   */
  priority: PriorityLevel;

  /**
   * ordered behaviors in this workstream
   * order reflects dependency chain
   */
  behaviors: BehaviorWorkstreamEntry[];

  /**
   * bottlenecks affecting this workstream
   */
  bottlenecks: BehaviorWorkstreamBottleneck[];
}

class BehaviorWorkstream extends DomainEntity<BehaviorWorkstream> {
  public static primary = ['id'] as const;
  public static unique = ['name'] as const;
}
```

### 2.2 literals

#### BehaviorRef

reference to a behavior by its composite key.

```ts
interface BehaviorRef {
  /**
   * composite key: {org}/{repo}/{behaviorName}
   */
  ref: string;
}

class BehaviorRef extends DomainLiteral<BehaviorRef> {}
```

#### BehaviorFile

a file within a behavior directory.

```ts
interface BehaviorFile {
  /**
   * relative path within behavior directory
   */
  path: string;

  /**
   * file content (for relevant files like 0.wish.md)
   */
  content: string | null;
}

class BehaviorFile extends DomainLiteral<BehaviorFile> {}
```

#### BehaviorYieldage

probabilistic yield model capturing uncertainty in value delivery.

```ts
interface BehaviorYieldage {
  /**
   * probability distribution of yield outcomes
   * each entry represents a possible outcome with its probability
   * failure is captured as { yieldage: 0, probability: P }
   */
  distribution: BehaviorYieldageDistributionEntry[];

  /**
   * expected value = sum(yieldage * probability)
   * weighted sum of distribution
   */
  expected: number;
}

interface BehaviorYieldageDistributionEntry {
  /**
   * yield value (0-100 scale)
   * 0 = failure/no value delivered
   */
  yieldage: number;

  /**
   * probability of this outcome (0-1)
   */
  probability: number;
}

class BehaviorYieldage extends DomainLiteral<BehaviorYieldage> {
  public static nested = { distribution: DomainLiteral };
}
```

#### BehaviorWorkstreamEntry

a behavior's position within a workstream.

```ts
interface BehaviorWorkstreamEntry {
  /**
   * reference to the behavior
   */
  ref: string;

  /**
   * position in workstream (1-indexed)
   */
  position: number;

  /**
   * current urgency level
   */
  urgency: UrgencyLevel;

  /**
   * blocking behavior refs (if blocked)
   */
  blockedBy: string[] | null;
}

class BehaviorWorkstreamEntry extends DomainLiteral<BehaviorWorkstreamEntry> {}
```

#### BehaviorWorkstreamBottleneck

cross-workstream blocking relationship.

```ts
interface BehaviorWorkstreamBottleneck {
  /**
   * workstream being blocked
   */
  blockedWorkstream: string;

  /**
   * workstream causing the block
   */
  blockingWorkstream: string;

  /**
   * specific behavior causing the block
   */
  blockingBehavior: string;

  /**
   * position in blocked workstream where block occurs
   */
  atPosition: number;
}

class BehaviorWorkstreamBottleneck extends DomainLiteral<BehaviorWorkstreamBottleneck> {}
```

#### BehaviorDispatchConfig

configuration for dispatcher skills.

```ts
interface BehaviorDispatchConfig {
  /**
   * output directory path (default: .dispatch)
   */
  output: string;

  /**
   * sources to gather behaviors from
   */
  sources: {
    local: {
      repos: string[];
    };
    remote: {
      repos: BehaviorRemoteRepoConfig[];
    } | null;
  };

  /**
   * measurement criteria weights
   */
  criteria: {
    gain: {
      yieldage: {
        weights: {
          direct: number;
          transitive: number;
        };
      };
      leverage: {
        weights: {
          maintenance: number;
          velocity: number;
        };
      };
    };
    cost: {
      weights: {
        time: number;
        money: number;
        attention: number;
      };
    };
  };

  /**
   * constraints for triage
   */
  constraints: {
    maxConcurrency: number;
  };
}

interface BehaviorRemoteRepoConfig {
  url: string;
  prLabels: string[] | null;
  issueLabels: string[] | null;
}

class BehaviorDispatchConfig extends DomainLiteral<BehaviorDispatchConfig> {}
```

### 2.3 enums

```ts
type BehaviorStatus =
  | 'wish'      // only wish defined
  | 'vision'    // wish + vision defined
  | 'criteria'  // wish + vision + criteria defined
  | 'active'    // being worked on
  | 'review'    // in review
  | 'delivered' // complete
  ;

type PriorityLevel =
  | 'p0'  // critical - must do now
  | 'p1'  // important - should do soon
  | 'p3'  // desired - would be nice
  | 'p5'  // bonus - if time permits
  ;

type ReadinessLevel =
  | 'now'     // no blockers, ready to start
  | 'soon'    // minor blockers, ready soon
  | 'later'   // significant blockers
  | 'blocked' // hard blocked by dependency
  ;

type BandwidthLevel =
  | 'now'   // within concurrency limit
  | 'soon'  // next in queue
  | 'later' // beyond current capacity
  ;

type UrgencyLevel =
  | 'now'   // work on immediately
  | 'soon'  // queue for next
  | 'later' // backlog
  ;
```

---

## 3. domain.operations

### 3.1 gather skill operations

```
src/domain.operations/behavior/
  gatherBehavior.ts                      // main entry point
  enumBehaviorDirs.ts                    // find .behavior/*/ directories
  parseBehaviorDir.ts                    // parse a single behavior directory
  computeBehaviorGatheredContentHash.ts  // sha256 hash of directory contents
  loadBehaviorDispatchConfig.ts          // parse rhachet.dispatch.yml
```

#### gatherBehavior

```ts
/**
 * .what = gathers all behaviors from configured sources
 * .why = provides input for downstream deptrace/measure/triage skills
 */
export const gatherBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorGatherResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  // enumerate behavior directories from all sources
  const behaviorDirs = await enumBehaviorDirs({ sources: input.config.sources }, context);

  // parse each behavior directory
  const behaviors: BehaviorGathered[] = [];
  for (const dir of behaviorDirs) {
    const behavior = await parseBehaviorDir({ dir }, context);
    behaviors.push(behavior);
  }

  // save gathered behaviors to cache
  for (const behavior of behaviors) {
    await daoBehaviorGathered.set.upsert({ behavior }, context);
  }

  return { behaviors, stats: { ... } };
};
```

#### computeBehaviorGatheredContentHash

```ts
/**
 * .what = computes sha256 hash of behavior directory contents
 * .why = enables cache invalidation when behavior changes
 * .note = computed ONLY at gather time, reused downstream
 */
export const computeBehaviorGatheredContentHash = async (
  input: {
    dir: string;
  },
  context: BehaviorDispatchContext,
): Promise<string> => {
  // enumerate all files in directory
  const files = await enumFilesRecursive({ dir: input.dir }, context);

  // sort files for deterministic ordering
  const sortedFiles = files.sort();

  // concatenate file contents
  const contents = await Promise.all(
    sortedFiles.map(async (file) => {
      const content = await readFile({ path: file }, context);
      return `${file}:${content}`;
    }),
  );

  // compute sha256 hash
  return sha256(contents.join('\n'));
};
```

### 3.2 deptrace skill operations

```
src/domain.operations/behavior/
  deptraceBehavior.ts                        // main entry point
  parseBehaviorDeptracedDependencies.ts      // extract depends_on from criteria
  computeBehaviorDeptracedTransitiveDeps.ts  // compute transitive closure
  renderBehaviorDeptracedDependenciesMd.ts   // generate dependencies.md output
```

#### deptraceBehavior

```ts
/**
 * .what = traces dependencies for all gathered behaviors
 * .why = enables yieldage calculation with transitive impact
 */
export const deptraceBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
    behaviors: BehaviorGathered[];
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorDeptraceResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  const deptraced: BehaviorDeptraced[] = [];

  for (const behavior of input.behaviors) {
    // check cache by contentHash
    const cached = await daoBehaviorDeptraced.get.byContentHash(
      { ref: behavior.ref, contentHash: behavior.contentHash },
      context,
    );
    if (cached) {
      deptraced.push(cached);
      continue;
    }

    // parse direct dependencies from criteria
    const dependsOnDirect = await parseBehaviorDeptracedDependencies(
      { criteria: behavior.criteria },
      context,
    );

    // compute transitive closure
    const dependsOnTransitive = await computeBehaviorDeptracedTransitiveDeps(
      { ref: behavior.ref, direct: dependsOnDirect, allBehaviors: input.behaviors },
      context,
    );

    const result: BehaviorDeptraced = {
      ref: behavior.ref,
      contentHash: behavior.contentHash,
      dependsOnDirect,
      dependsOnTransitive,
      deptracedAt: new Date().toISOString(),
    };

    await daoBehaviorDeptraced.set.upsert({ behavior: result }, context);
    deptraced.push(result);
  }

  // render dependencies.md
  const dependenciesMd = await renderBehaviorDeptracedDependenciesMd(
    { behaviors: deptraced },
    context,
  );

  return { behaviors: deptraced, outputs: { dependenciesMd }, stats: { ... } };
};
```

#### renderBehaviorDeptracedDependenciesMd

```ts
/**
 * .what = renders dependency tree as markdown
 * .why = provides human-readable dependency visualization
 */
export const renderBehaviorDeptracedDependenciesMd = async (
  input: {
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Promise<string> => {
  const lines: string[] = ['# dependencies', ''];

  for (const behavior of input.behaviors) {
    lines.push(`## ${behavior.ref}`);
    if (behavior.dependsOnDirect.length === 0) {
      lines.push('depends on: (none)');
    } else {
      lines.push('depends on:');
      // render as tree with urgency annotations
      for (const dep of behavior.dependsOnDirect) {
        lines.push(`  - ${dep.ref}`);
        // include transitive deps as nested tree
      }
    }
    lines.push('');
  }

  return lines.join('\n');
};
```

### 3.3 measure skill operations

```
src/domain.operations/behavior/
  measureBehavior.ts                          // main entry point
  computeBehaviorMeasuredGainYieldage.ts      // probabilistic yield calculation
  computeBehaviorMeasuredGainLeverage.ts      // leverage multiplier
  computeBehaviorMeasuredGainComposite.ts     // aggregate gain = yieldage.expected * leverage
  computeBehaviorMeasuredCostTime.ts          // time cost estimation
  computeBehaviorMeasuredCostMoney.ts         // money cost estimation
  computeBehaviorMeasuredCostAttention.ts     // attention cost estimation
  computeBehaviorMeasuredCostComposite.ts     // aggregate cost = weighted sum
  computeBehaviorMeasuredReverseDeps.ts       // invert dependency graph for blockee count
  assignBehaviorMeasuredPriority.ts           // map decision score to priority level
```

#### measureBehavior

```ts
/**
 * .what = measures all deptraced behaviors
 * .why = provides scoring for prioritization decisions
 */
export const measureBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasureResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  // compute reverse dependency map for blockee calculation
  const reverseDeps = computeBehaviorMeasuredReverseDeps({ behaviors: input.behaviors }, context);

  const measured: BehaviorMeasured[] = [];

  for (const behavior of input.behaviors) {
    // check cache by contentHash
    const cached = await daoBehaviorMeasured.get.byContentHash(
      { ref: behavior.ref, contentHash: behavior.contentHash },
      context,
    );
    if (cached) {
      measured.push(cached);
      continue;
    }

    // compute gain dimensions
    const yieldage = await computeBehaviorMeasuredGainYieldage(
      { behavior, reverseDeps, config: input.config },
      context,
    );
    const leverage = await computeBehaviorMeasuredGainLeverage(
      { behavior, config: input.config },
      context,
    );
    const gainComposite = computeBehaviorMeasuredGainComposite(
      { yieldage, leverage },
      context,
    );

    // compute cost dimensions
    const time = await computeBehaviorMeasuredCostTime(
      { behavior, config: input.config },
      context,
    );
    const money = await computeBehaviorMeasuredCostMoney(
      { behavior, config: input.config },
      context,
    );
    const attention = await computeBehaviorMeasuredCostAttention(
      { behavior, config: input.config },
      context,
    );
    const costComposite = computeBehaviorMeasuredCostComposite(
      { time, money, attention, config: input.config },
      context,
    );

    // compute decision score
    const decision = gainComposite / costComposite;

    // assign priority
    const priority = assignBehaviorMeasuredPriority({ decision }, context);

    const result: BehaviorMeasured = {
      ref: behavior.ref,
      contentHash: behavior.contentHash,
      gain: {
        dimensions: { yieldage, leverage },
        composite: gainComposite,
      },
      cost: {
        dimensions: { time, money, attention },
        composite: costComposite,
      },
      decision,
      priority,
      measuredAt: new Date().toISOString(),
    };

    await daoBehaviorMeasured.set.upsert({ behavior: result }, context);
    measured.push(result);
  }

  return { behaviors: measured, stats: { ... } };
};
```

#### computeBehaviorMeasuredGainYieldage

```ts
/**
 * .what = computes probabilistic yield for a behavior
 * .why = captures uncertainty in value delivery
 * .note = includes transitive impact via blockee count
 */
export const computeBehaviorMeasuredGainYieldage = async (
  input: {
    behavior: BehaviorDeptraced;
    reverseDeps: Map<string, string[]>;
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorYieldage> => {
  // base yield from brain.repl analysis
  const baseYield = await context.brain.repl({
    prompt: `analyze yield potential for behavior: ${input.behavior.ref}`,
    schema: yieldageSchema,
  });

  // compute blockee bonus (transitive impact)
  const blockees = input.reverseDeps.get(input.behavior.ref) || [];
  const transitiveBonus = blockees.length * input.config.criteria.yieldage.weights.transitive;

  // build distribution
  const distribution: BehaviorYieldageDistributionEntry[] = [
    { yieldage: 0, probability: baseYield.failureProbability },
    { yieldage: baseYield.successYield + transitiveBonus, probability: 1 - baseYield.failureProbability },
  ];

  // compute expected value
  const expected = distribution.reduce(
    (sum, entry) => sum + entry.yieldage * entry.probability,
    0,
  );

  return { distribution, expected };
};
```

#### computeBehaviorMeasuredReverseDeps

```ts
/**
 * .what = inverts dependency graph to find blockees
 * .why = enables transitive impact calculation in yieldage
 * .note = deptrace only tracks dependsOn*; this computes dependedBy*
 */
export const computeBehaviorMeasuredReverseDeps = (
  input: {
    behaviors: BehaviorDeptraced[];
  },
  context: BehaviorDispatchContext,
): Map<string, string[]> => {
  const reverseDeps = new Map<string, string[]>();

  // initialize all behaviors with empty arrays
  for (const behavior of input.behaviors) {
    reverseDeps.set(behavior.ref, []);
  }

  // invert the graph
  for (const behavior of input.behaviors) {
    for (const dep of behavior.dependsOnTransitive) {
      const blockees = reverseDeps.get(dep.ref) || [];
      blockees.push(behavior.ref);
      reverseDeps.set(dep.ref, blockees);
    }
  }

  return reverseDeps;
};
```

### 3.4 triage skill operations

```
src/domain.operations/behavior/
  triageBehavior.ts                       // main entry point
  computeBehaviorTriagedReadiness.ts      // determine readiness from deps
  computeBehaviorTriagedBandwidth.ts      // determine bandwidth from constraints
  renderBehaviorTriagedPrioritizationMd.ts   // generate prioritization.md
  renderBehaviorTriagedPrioritizationJson.ts // generate prioritization.json
```

#### triageBehavior

```ts
/**
 * .what = triages all measured behaviors into urgency buckets
 * .why = provides actionable prioritization for users
 * .note = fully deterministic (no brain.repl)
 */
export const triageBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
    behaviors: BehaviorMeasured[];
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorTriageResult> => {
  // findsert output directory
  await findsertBehaviorDispatchDir({ path: input.config.output }, context);

  // sort by priority then decision score
  const sorted = [...input.behaviors].sort((a, b) => {
    const priorityOrder = { p0: 0, p1: 1, p3: 2, p5: 3 };
    if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    }
    return b.decision - a.decision; // higher decision first
  });

  const triaged: BehaviorTriaged[] = [];
  let nowCount = 0;

  for (const behavior of sorted) {
    // compute readiness from dependency status
    const readiness = computeBehaviorTriagedReadiness(
      { behavior, allBehaviors: sorted },
      context,
    );

    // compute bandwidth from constraints
    const bandwidth: BandwidthLevel =
      nowCount < input.config.constraints.maxConcurrency
        ? 'now'
        : nowCount < input.config.constraints.maxConcurrency * 2
          ? 'soon'
          : 'later';

    // decision = min(readiness, bandwidth)
    const decision = minUrgency(readiness, bandwidth);

    if (decision === 'now') nowCount++;

    const result: BehaviorTriaged = {
      ref: behavior.ref,
      contentHash: behavior.contentHash,
      dimensions: { readiness, bandwidth },
      decision,
      priority: behavior.priority,
      triagedAt: new Date().toISOString(),
    };

    await daoBehaviorTriaged.set.upsert({ behavior: result }, context);
    triaged.push(result);
  }

  return {
    behaviors: triaged,
    stats: {
      all: triaged.length,
      now: triaged.filter((b) => b.decision === 'now').length,
      soon: triaged.filter((b) => b.decision === 'soon').length,
      later: triaged.filter((b) => b.decision === 'later').length,
    },
  };
};
```

### 3.5 prioritize composite skill operations

```
src/domain.operations/behavior/
  prioritizeBehavior.ts        // main entry point (orchestrates atomic skills)
```

#### prioritizeBehavior

```ts
/**
 * .what = runs full prioritization pipeline: gather → deptrace → measure → triage
 * .why = provides one-command prioritization for users
 */
export const prioritizeBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorPrioritizeResult> => {
  // gather
  const gatherResult = await gatherBehavior({ config: input.config }, context);

  // deptrace
  const deptraceResult = await deptraceBehavior(
    { config: input.config, behaviors: gatherResult.behaviors },
    context,
  );

  // measure
  const measureResult = await measureBehavior(
    { config: input.config, behaviors: deptraceResult.behaviors },
    context,
  );

  // triage
  const triageResult = await triageBehavior(
    { config: input.config, behaviors: measureResult.behaviors },
    context,
  );

  // render outputs
  const prioritizationMd = await renderBehaviorTriagedPrioritizationMd(
    { behaviors: triageResult.behaviors },
    context,
  );
  const prioritizationJson = JSON.stringify(triageResult.behaviors, null, 2);

  // archive previous outputs if changed
  await archiveBehaviorIfChanged(
    { path: `${input.config.output}/prioritization.md`, content: prioritizationMd },
    context,
  );

  // write outputs
  await writeFile({ path: `${input.config.output}/prioritization.md`, content: prioritizationMd }, context);
  await writeFile({ path: `${input.config.output}/prioritization.json`, content: prioritizationJson }, context);
  await writeFile({ path: `${input.config.output}/dependencies.md`, content: deptraceResult.outputs.dependenciesMd }, context);

  return {
    behaviors: triageResult.behaviors,
    outputs: {
      prioritizationMd,
      prioritizationJson,
      dependenciesMd: deptraceResult.outputs.dependenciesMd,
    },
  };
};
```

### 3.6 coordinate skill operations

```
src/domain.operations/behavior/
  coordinateBehavior.ts                     // main entry point
  groupBehaviorWorkstreams.ts               // cluster behaviors into workstreams
  rankBehaviorWorkstreams.ts                // assign ranks based on priority
  detectBehaviorWorkstreamBottlenecks.ts    // find cross-workstream blocks
  renderBehaviorWorkstreamCoordinationMd.ts // generate coordination.md
```

#### coordinateBehavior

```ts
/**
 * .what = groups triaged behaviors into parallel workstreams
 * .why = enables team coordination and bottleneck detection
 */
export const coordinateBehavior = async (
  input: {
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<BehaviorCoordinateResult> => {
  // load triaged behaviors
  const triaged = await daoBehaviorTriaged.get.all({}, context);

  // group into workstreams
  const workstreams = await groupBehaviorWorkstreams({ behaviors: triaged }, context);

  // rank workstreams
  const ranked = await rankBehaviorWorkstreams({ workstreams }, context);

  // detect bottlenecks
  for (const workstream of ranked) {
    workstream.bottlenecks = await detectBehaviorWorkstreamBottlenecks(
      { workstream, allWorkstreams: ranked },
      context,
    );
  }

  // render outputs
  const coordinationMd = await renderBehaviorWorkstreamCoordinationMd({ workstreams: ranked }, context);
  const coordinationJson = JSON.stringify(ranked, null, 2);

  // archive if changed
  await archiveBehaviorIfChanged(
    { path: `${input.config.output}/coordination.md`, content: coordinationMd },
    context,
  );

  // write outputs
  await writeFile({ path: `${input.config.output}/coordination.md`, content: coordinationMd }, context);
  await writeFile({ path: `${input.config.output}/coordination.json`, content: coordinationJson }, context);

  return {
    workstreams: ranked,
    outputs: { coordinationMd, coordinationJson },
  };
};
```

### 3.7 shared operations

```
src/domain.operations/behavior/
  findsertBehaviorDispatchDir.ts   // idempotent output dir initialization
  archiveBehaviorIfChanged.ts      // archive prior outputs
  loadBehaviorGathered.ts          // load from cache
```

#### findsertBehaviorDispatchDir

```ts
/**
 * .what = creates output directory with readme if not exists
 * .why = ensures consistent output structure across skills
 * .note = idempotent - safe to call multiple times
 */
export const findsertBehaviorDispatchDir = async (
  input: {
    path: string;
  },
  context: BehaviorDispatchContext,
): Promise<void> => {
  // check if directory exists
  const exists = await directoryExists({ path: input.path }, context);
  if (exists) return;

  // create directory structure
  await mkdir({ path: input.path }, context);
  await mkdir({ path: `${input.path}/.gathered` }, context);
  await mkdir({ path: `${input.path}/.deptraced` }, context);
  await mkdir({ path: `${input.path}/.measured` }, context);
  await mkdir({ path: `${input.path}/.triaged` }, context);
  await mkdir({ path: `${input.path}/.archive` }, context);

  // write readme
  const readme = `# .dispatch output

this directory contains dispatcher skill outputs.

## cache behavior

the .* directories (.gathered/, .deptraced/, .measured/, .triaged/) are caches.
they are reused in subsequent invocations to maximize efficiency:

- only behaviors with changed contentHash are reprocessed
- unchanged behaviors reuse cached results
- delete a .* directory to force recomputation of that stage

## archive behavior

when outputs change, prior versions are archived to .archive/:

- files are named {filename}.{isoTimestamp}.bak.md
- unchanged runs do not create archives
- archives are sorted by timestamp (ls shows history)

## files

- prioritization.md: human-readable summary of triaged behaviors
- prioritization.json: machine-readable data for downstream tools
- dependencies.md: dependency tree per behavior
- coordination.md: workstream map (after coordinate skill)
- coordination.json: machine-readable workstream data
`;

  await writeFile({ path: `${input.path}/readme.md`, content: readme }, context);
};
```

---

## 4. access.daos

### 4.1 daoBehaviorGathered

```
src/access/daos/daoBehaviorGathered/
  index.ts
  get/
    byRef.ts
    byContentHash.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorGathered entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorGathered = {
  get: {
    /**
     * .what = get gathered behavior by ref
     */
    byRef: async (
      input: { ref: string },
      context: DispatchContext,
    ): Promise<BehaviorGathered | null> => {
      const cachePath = `${context.config.output}/.gathered/${slugify(input.ref)}.gathered.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    /**
     * .what = get gathered behavior by ref + contentHash
     * .why = cache invalidation check
     */
    byContentHash: async (
      input: { ref: string; contentHash: string },
      context: DispatchContext,
    ): Promise<BehaviorGathered | null> => {
      const existing = await daoBehaviorGathered.get.byRef(input, context);
      if (existing && existing.contentHash === input.contentHash) {
        return existing;
      }
      return null;
    },

    /**
     * .what = get all gathered behaviors
     */
    all: async (
      input: {},
      context: DispatchContext,
    ): Promise<BehaviorGathered[]> => {
      const files = await glob({ pattern: `${context.config.output}/.gathered/*.gathered.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    /**
     * .what = upsert gathered behavior to cache
     */
    upsert: async (
      input: { behavior: BehaviorGathered },
      context: DispatchContext,
    ): Promise<BehaviorGathered> => {
      const cachePath = `${context.config.output}/.gathered/${slugify(input.behavior.ref)}.gathered.json`;
      await writeJson({ path: cachePath, data: input.behavior }, context);
      return input.behavior;
    },
  },
};
```

### 4.2 daoBehaviorDeptraced

```
src/access/daos/daoBehaviorDeptraced/
  index.ts
  get/
    byRef.ts
    byContentHash.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorDeptraced entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorDeptraced = {
  get: {
    byRef: async (input: { ref: string }, context: DispatchContext): Promise<BehaviorDeptraced | null> => {
      const cachePath = `${context.config.output}/.deptraced/${slugify(input.ref)}.deptraced.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    byContentHash: async (
      input: { ref: string; contentHash: string },
      context: DispatchContext,
    ): Promise<BehaviorDeptraced | null> => {
      const existing = await daoBehaviorDeptraced.get.byRef(input, context);
      if (existing && existing.contentHash === input.contentHash) {
        return existing;
      }
      return null;
    },

    all: async (input: {}, context: DispatchContext): Promise<BehaviorDeptraced[]> => {
      const files = await glob({ pattern: `${context.config.output}/.deptraced/*.deptraced.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    upsert: async (
      input: { behavior: BehaviorDeptraced },
      context: DispatchContext,
    ): Promise<BehaviorDeptraced> => {
      const cachePath = `${context.config.output}/.deptraced/${slugify(input.behavior.ref)}.deptraced.json`;
      await writeJson({ path: cachePath, data: input.behavior }, context);
      return input.behavior;
    },
  },
};
```

### 4.3 daoBehaviorMeasured

```
src/access/daos/daoBehaviorMeasured/
  index.ts
  get/
    byRef.ts
    byContentHash.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorMeasured entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorMeasured = {
  get: {
    byRef: async (input: { ref: string }, context: DispatchContext): Promise<BehaviorMeasured | null> => {
      const cachePath = `${context.config.output}/.measured/${slugify(input.ref)}.measured.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    byContentHash: async (
      input: { ref: string; contentHash: string },
      context: DispatchContext,
    ): Promise<BehaviorMeasured | null> => {
      const existing = await daoBehaviorMeasured.get.byRef(input, context);
      if (existing && existing.contentHash === input.contentHash) {
        return existing;
      }
      return null;
    },

    all: async (input: {}, context: DispatchContext): Promise<BehaviorMeasured[]> => {
      const files = await glob({ pattern: `${context.config.output}/.measured/*.measured.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    upsert: async (
      input: { behavior: BehaviorMeasured },
      context: DispatchContext,
    ): Promise<BehaviorMeasured> => {
      const cachePath = `${context.config.output}/.measured/${slugify(input.behavior.ref)}.measured.json`;
      await writeJson({ path: cachePath, data: input.behavior }, context);
      return input.behavior;
    },
  },
};
```

### 4.4 daoBehaviorTriaged

```
src/access/daos/daoBehaviorTriaged/
  index.ts
  get/
    byRef.ts
    all.ts
  set/
    upsert.ts
```

```ts
/**
 * .what = dao for BehaviorTriaged entities
 * .why = provides caching via simple-on-disk-cache
 */
export const daoBehaviorTriaged = {
  get: {
    byRef: async (input: { ref: string }, context: DispatchContext): Promise<BehaviorTriaged | null> => {
      const cachePath = `${context.config.output}/.triaged/${slugify(input.ref)}.triaged.json`;
      return readJsonIfExists({ path: cachePath }, context);
    },

    all: async (input: {}, context: DispatchContext): Promise<BehaviorTriaged[]> => {
      const files = await glob({ pattern: `${context.config.output}/.triaged/*.triaged.json` }, context);
      return Promise.all(files.map((f) => readJson({ path: f }, context)));
    },
  },

  set: {
    upsert: async (
      input: { behavior: BehaviorTriaged },
      context: DispatchContext,
    ): Promise<BehaviorTriaged> => {
      const cachePath = `${context.config.output}/.triaged/${slugify(input.behavior.ref)}.triaged.json`;
      await writeJson({ path: cachePath, data: input.behavior }, context);
      return input.behavior;
    },
  },
};
```

---

## 5. directory structure

```
src/
  contract/
    cmd/
      gatherBehavior.ts         // npx rhachet run --skill gather
      deptraceBehavior.ts       // npx rhachet run --skill deptrace
      measureBehavior.ts        // npx rhachet run --skill measure
      triageBehavior.ts         // npx rhachet run --skill triage
      prioritizeBehavior.ts     // npx rhachet run --skill prioritize
      coordinateBehavior.ts     // npx rhachet run --skill coordinate

  domain.objects/
    BehaviorGathered.ts
    BehaviorDeptraced.ts
    BehaviorMeasured.ts
    BehaviorTriaged.ts
    BehaviorWorkstream.ts
    BehaviorRef.ts
    BehaviorFile.ts
    BehaviorYieldage.ts
    BehaviorWorkstreamEntry.ts
    BehaviorWorkstreamBottleneck.ts
    BehaviorDispatchConfig.ts
    BehaviorStatus.ts
    BehaviorPriorityLevel.ts
    BehaviorReadinessLevel.ts
    BehaviorBandwidthLevel.ts
    BehaviorUrgencyLevel.ts

  domain.operations/
    behavior/
      gatherBehavior.ts
      enumBehaviorDirs.ts
      parseBehaviorDir.ts
      computeBehaviorGatheredContentHash.ts
      loadBehaviorDispatchConfig.ts
      deptraceBehavior.ts
      parseBehaviorDeptracedDependencies.ts
      computeBehaviorDeptracedTransitiveDeps.ts
      renderBehaviorDeptracedDependenciesMd.ts
      measureBehavior.ts
      computeBehaviorMeasuredGainYieldage.ts
      computeBehaviorMeasuredGainLeverage.ts
      computeBehaviorMeasuredGainComposite.ts
      computeBehaviorMeasuredCostTime.ts
      computeBehaviorMeasuredCostMoney.ts
      computeBehaviorMeasuredCostAttention.ts
      computeBehaviorMeasuredCostComposite.ts
      computeBehaviorMeasuredReverseDeps.ts
      assignBehaviorMeasuredPriority.ts
      triageBehavior.ts
      computeBehaviorTriagedReadiness.ts
      computeBehaviorTriagedBandwidth.ts
      renderBehaviorTriagedPrioritizationMd.ts
      renderBehaviorTriagedPrioritizationJson.ts
      prioritizeBehavior.ts
      coordinateBehavior.ts
      groupBehaviorWorkstreams.ts
      rankBehaviorWorkstreams.ts
      detectBehaviorWorkstreamBottlenecks.ts
      renderBehaviorWorkstreamCoordinationMd.ts
      findsertBehaviorDispatchDir.ts
      archiveBehaviorIfChanged.ts
      loadBehaviorGathered.ts

  access/
    daos/
      daoBehaviorGathered/
        index.ts
        get/
          byRef.ts
          byContentHash.ts
          all.ts
        set/
          upsert.ts
      daoBehaviorDeptraced/
        index.ts
        get/...
        set/...
      daoBehaviorMeasured/
        index.ts
        get/...
        set/...
      daoBehaviorTriaged/
        index.ts
        get/...
        set/...
```

---

## 6. design decisions

### 6.1 contentHash computed at gather time only

**decision**: contentHash is computed once during gather and stored in BehaviorGathered. downstream skills (deptrace, measure, triage) read contentHash from gathered output rather than recomputing.

**rationale**:
- ensures consistent cache key across all stages
- avoids redundant computation
- single source of truth for "behavior changed"

### 6.2 deptrace only tracks dependsOn* (not dependedBy*)

**decision**: BehaviorDeptraced only contains dependsOnDirect and dependsOnTransitive. reverse dependencies (dependedBy*) are computed at measure time via graph inversion.

**rationale**:
- keeps deptrace output minimal and focused
- avoids dual-storage of same relationship
- blockee calculation is only needed for yieldage scoring

### 6.3 probabilistic yieldageDistribution

**decision**: yieldage is modeled as a probability distribution { yieldage, probability }[] rather than a single number.

**rationale**:
- captures uncertainty in value delivery
- failure probability (yieldage: 0) is explicit
- expected value computed as weighted sum
- enables risk-aware prioritization

### 6.4 dimensions/decision structure

**decision**: both BehaviorMeasured and BehaviorTriaged use a dimensions/decision structure.

**rationale**:
- dimensions capture the inputs to decision
- decision is the computed output
- makes reasoning transparent and auditable
- enables debugging ("why is this behavior p1?")

### 6.5 triage is deterministic (no brain.repl)

**decision**: triage skill does not use brain.repl. readiness is computed from dependency status, bandwidth from constraints.

**rationale**:
- triage should be predictable and reproducible
- same inputs always produce same outputs
- reduces complexity and cost
- brain.repl reserved for measure skill where judgment is needed

### 6.6 findsertDispatchDir for idempotent output initialization

**decision**: all skills call findsertDispatchDir before writing output. this creates the output directory structure and readme.md if not exists.

**rationale**:
- ensures consistent output structure
- readme.md explains cache and archive behavior to users
- idempotent - safe to call multiple times
- single skill can run independently without prior setup

### 6.7 dependencies.md generated by deptrace skill

**decision**: deptrace skill produces dependencies.md as an output, not prioritize composite.

**rationale**:
- dependency information is available immediately after deptrace
- allows users to inspect deps without running full pipeline
- prioritize just passes through the output

### 6.8 priority levels use odd numbers only

**decision**: priority levels are p0, p1, p3, p5 (skipping p2 and p4).

**rationale**:
- leaves room for future intermediate levels if needed
- common pattern in issue trackers
- provides clear separation between levels

### 6.9 cache invalidation via contentHash matching

**decision**: downstream skills check `contentHash` match before returning cached results. if contentHash differs from gathered behavior, cache is invalidated.

**rationale**:
- simple and reliable invalidation
- no need for timestamp comparison
- content-addressable caching

### 6.10 interactive mode out of scope

**decision**: interactive mode (user prompts during skill execution) is explicitly out of scope.

**rationale**:
- keeps initial implementation simple
- users can manually edit output files for overrides
- future enhancement if needed

---

## 7. context type

```ts
interface BehaviorDispatchContext {
  /**
   * loaded dispatch config
   */
  config: BehaviorDispatchConfig;

  /**
   * brain access for AI-powered analysis
   */
  brain: {
    repl: <T>(input: { prompt: string; schema: ZodSchema<T> }) => Promise<T>;
  };

  /**
   * logging
   */
  log: LogMethods;
}
```

---

## 8. traceability matrix

| wish | skill | mechanism |
|------|-------|-----------|
| "where to start?" | triageBehavior | decision = min(readiness, bandwidth) → now/soon/later |
| "which is most important?" | measureBehavior | decision = gain.composite / cost.composite |
| "which unblocks the most?" | measureBehavior | computeBehaviorMeasuredReverseDeps → blockee count → gain.yieldage bonus |
| "too many workstreams" | coordinateBehavior | groupBehaviorWorkstreams → named workstreams |
| "what is even active?" | coordinateBehavior | workstream map with urgency annotations |
| "which to review first?" | coordinateBehavior | rankBehaviorWorkstreams → review in rank order |
| "cache artifacts" | all skills | contentHash + byContentHash cache check |
| "parallelize work" | coordinateBehavior | independent behaviors → parallel workstreams |
