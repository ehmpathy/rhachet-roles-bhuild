here's our human thoughts on what leverage is and how it can be measured

---

relevant dimensions

- faster => takes less time to do things
- simpler => less thought cycles && word tokens required
- safer => pit of success


-----

for example

codegen
- declapract gives us leverage via
  - mechanism = 1 command to codegen changes in a repo -> apply best practices instantly and without thought -> no brains required
  - benefits =
    - faster - takes seconds to apply best practices (one command, totally deterministic)
    - simpler - no need to remember or know anything; the best practices are applied without any pre-reqs, skill, or knowledge required
    - safer - no risk of messing up, since there's no one in the loop; pit of success with failsafe

- dynamodb-dao-generator gives us leverage via
  - mechanism = 1 command to codegen a dao to persist data w/ dynamodb with best practices automatically applied in seconds
  - benefits
    - faster = 1 command, no brain written code, all deterministic
    - simpler = no need to remember anything or think about any details; the generator guarantees it will be done right; no skills required
    - safer = best practices are baked into the output; no risk of doing the wrong thing. no risk of using it wrong either, because the best practices of the produced dao ensure its a pit-of-success in usage


domain-driven-design libs
- domain-objects gives us leverage via
  - mechanism = enforces domain distillation; makes it easy & safe & simple to declare doain objects; then, enables a ton of transitive tools to leverage that domain knowledge to power even higher leverage behaviors (e.g., dynamodb-dao-generator uses distilled domain-objects as input) (e.g., RefByUnique<typeof X> makes it simple to see what a uuid references and then enables composition with declastruct daos that enable safe and simple dereference)
  - benefits
    - simpler = consistent pattern for how to declare domain objects && use them; simple intuitive contract with progressive disclocure of advanced usecases
    - faster = takes seconds to declare a ne wdomain object that's compatible with all the tools that build off of them
    - safer = guarantees best practices are followed in declaration of domain objects

----

the other dimensions to consider are

- observability

e.g.,
- helpful-errors ensures that whenever an error is thrown, it is dead easy to understand why and what happened, since it serializes all the info safely for logs and incentivizes authors to pass in maximum context

e.g., as-procedure embeds withLogTrail on every procedure, to make it easy to trace down exactly what happened as code progressed,making investigations take seconds; can instantly see when something failed or where latency originates; can easily reproduce as the full input and output is present


---

other dimensions are

- readability -> makes things LOOK simple and BE intuitive, to decrease tokens required to understand and evolve -> decrease maintance burden && decrease evolution cost (refactor cost)
- composability -> how easy it is to compose this into other usecases && how safe it is to do so
- reusability -> how many usecases a component can be reused in (via composition or direct usage)
- evolvability -> how easy it is to evolve + refactor a component (e.g., based on contracts that depends on it or assumptions it made internally or the tools that we have that support its evolution; e.g., domain object names vs attributes vs keys); the key concept here is that domain knowledge evolves constantly and our software must evolve with it to take advantage of the latest-greates knowledge; goes hand in hand with experiementation

etc
