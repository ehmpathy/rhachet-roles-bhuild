# leverage research: absolute measurement units (v7)

this document proposes absolute measurement units for leverage dimensions and demonstrates their application to three tools.


---


## 1. the problem with relative scores

v6 evaluations used relative scores (1-10) which suffer from:
- **subjectivity**: what does "8/10 simpler" mean?
- **incomparability**: can't compare across tools meaningfully
- **ungroundedness**: no connection to real-world impact

we need **absolute units** that measure concrete outcomes.


---


## 2. absolute measurement units

### 2.1. metric structure

```
leverage.{lifecycle}.{metric} = {polarity}({value}-{unit}/{scope})

where:
  lifecycle = author | support | adopt
  polarity  = save | gain | cost
  scope     = use | fail | tool
```

### 2.2. scopes

| scope | when | example |
|-------|------|---------|
| **/use** | each time the tool is used | codegen execution, runtime invocation |
| **/fail** | each time a failure occurs | incident diagnosis, debugging |
| **/tool** | once per tool | discovery, learning, integration |


### 2.3. leverage.author metrics

| metric | polarity | unit | description |
|--------|----------|------|-------------|
| **leverage.author.time** | save | hrs/use | wall-clock time saved per usage vs by-hand |
| **leverage.author.code.block** | save | blocks/use | logical code paragraphs you don't write |
| **leverage.author.code.path** | save | paths/use | conditional branches you don't write |
| **leverage.author.khue** | save | khues/use | questions/decisions the tool answers for you |


### 2.4. leverage.support metrics

"fast to fix, first to know, last to fail"

| metric | polarity | unit | description |
|--------|----------|------|-------------|
| **leverage.support.time** | save | mins/fail | time saved during incidents ("fast to fix") |
| **leverage.support.signal** | gain | signals/use | observability hooks ("first to know") |
| **leverage.support.defence** | gain | defences/use | safeguards + failsafes ("last to fail") |


### 2.5. leverage.adopt metrics

| metric | polarity | unit | description |
|--------|----------|------|-------------|
| **leverage.adopt.freq** | — | uses/week | how often this tool would be used ("how frequently?") |
| **leverage.adopt.time** | cost | mins/tool | one-time cost to learn and integrate |


### 2.6. estimating leverage.adopt.freq

when estimating freq, consider the tool's domain depth:

| depth | scope | example |
|-------|-------|---------|
| 0 | **usecase** | specific business logic (invoice generator) |
| 1 | **domain** | domain-specific patterns (e-commerce, fintech) |
| 2 | **framework** | framework-specific (react, express) |
| 3 | **language** | language-specific (typescript, python) |
| 4 | **platform** | platform-specific (aws, node.js) |
| 5 | **universal** | any software (git, http) |

higher depth = broader applicability = higher freq potential


---


## 3. measurement methodology

### 3.1. enumeration method (shared pattern)

all count-based metrics use the same enumeration methodology:

```
perX.Y.saved = enumerate(Y.byHand) - enumerate(Y.byTool)
perX.Y.added = enumerate(Y.addedByTool)
```

this pattern applies to:
- `perUse.code.blocks.saved` → enumerate logical code paragraphs
- `perUse.code.paths.saved` → enumerate conditional branches
- `perUse.khues.saved` → enumerate decision points
- `perUse.signals.added` → enumerate observability hooks
- `perUse.defences.added` → enumerate safeguards + failsafes


### 3.2. how to measure perUse.time.saved

```
perUse.time.saved = time.byHand - time.byTool

where:
  time.byHand = estimated time to implement equivalent by hand
  time.byTool = time to achieve same result with tool
```


### 3.3. how to measure perUse.code.blocks.saved

```
perUse.code.blocks.saved = blocks.byHand - blocks.byTool

where:
  block = a logical code paragraph (cohesive unit of logic, with or without comment)
  blocks.byHand = count of blocks in by-hand equivalent
  blocks.byTool = count of blocks you write when using tool
```

blocks are more meaningful than lines because:
- a block represents a cohesive unit of logic
- lines vary due to formatting
- blocks better capture "conceptual units" avoided


### 3.4. how to measure perUse.khues.saved

```
perUse.khues.saved = enumerate(questions the tool answers for you)

where khues (questions) include:
  - "which algorithm to use?"
  - "how to handle null?"
  - "what retry strategy?"
  - "how to serialize?"
  - "what's the batch limit?"
  - "how to handle pagination?"
  - etc.
```

each khue represents a decision point where the tool provides an answer so you don't have to research, debate, or decide.


---


## 4. tool measurements

### 4.1. with-simple-cache

**purpose:** add caching to any function with one-line wrapper


#### 4.1.1. leverage.author

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.author.time | save(15-25 mins/use) | by-hand cache logic takes 15-25 min; wrapper takes 1 min |
| leverage.author.code.block | save(5-7 blocks/use) | key gen, cache check, compute, cache store, error handling + backend wiring |
| leverage.author.code.path | save(7 paths/use) | cache hit, cache miss, cache error + edge cases (undefined, race, collision, backend fail) |
| leverage.author.khue | save(9 khues/use) | key serialization, TTL handling, cache backend, async handling, invalidation + configs |


#### 4.1.2. leverage.support

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.support.time | save(30 mins/fail) | consistent pattern reduces investigation |
| leverage.support.signal | gain(1 signal/use) | cache hit/miss traceability |
| leverage.support.defence | gain(3 defences/use) | graceful degradation, TTL expiration, key uniqueness |


#### 4.1.3. leverage.adopt

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.adopt.freq | 5 uses/week | any function that benefits from caching |
| leverage.adopt.time | cost(45 mins/tool) | learning (30) + integration (15) |


### 4.2. dynamodb-dao-generator

**purpose:** generate type-safe DAOs from domain objects


#### 4.2.1. leverage.author

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.author.time | save(4-8 hrs/use) | by-hand DAO takes 4-8 hours; generator takes 5 min |
| leverage.author.code.block | save(28-43 blocks/use) | CRUD + batch + pagination + error + terraform + dependency wiring blocks |
| leverage.author.code.path | save(40 paths/use) | CRUD × error handling × batch vs single + edge cases |
| leverage.author.khue | save(25 khues/use) | table design, GSI strategy, batch limits, pagination, retry, serialization, typing + configs |


#### 4.2.2. leverage.support

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.support.time | save(2 hrs/fail) | consistent patterns, known locations |
| leverage.support.signal | gain(4 signals/use) | operation start, success, failure, duration logs |
| leverage.support.defence | gain(8 defences/use) | retry with backoff, conditional writes, idempotency, unique keys, type safety, batch limits |


#### 4.2.3. leverage.adopt

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.adopt.freq | 0.5 uses/week | each new domain entity needing persistence |
| leverage.adopt.time | cost(3 hrs/tool) | learning (2) + integration (1) |


### 4.3. declapract-typescript-ehmpathy

**purpose:** 40+ typescript best practices as inheritable declarations


#### 4.3.1. leverage.author

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.author.time | save(4-8 hrs/use) | by-hand setup takes 4-8 hours; `declapract apply` takes 5 min |
| leverage.author.code.block | save(75+ blocks/use) | config file blocks + dependency wiring blocks across all tooling |
| leverage.author.code.path | save(0 paths/use) | practices are config, not runtime code |
| leverage.author.khue | save(80+ khues/use) | practice decisions + config choices (strict mode?, lint rules?, test config?, deps?, etc.) |


#### 4.3.2. leverage.support

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.support.time | save(1 hr/fail) | consistent patterns across all projects |
| leverage.support.signal | gain(5+ signals/use) | structured logging practices, CI feedback, violation reports |
| leverage.support.defence | gain(43+ defences/use) | 40+ invariants enforced + plan/apply/rollback recovery |


#### 4.3.3. leverage.adopt

| metric | measurement | calculation |
|--------|-------------|-------------|
| leverage.adopt.freq | 0.25 uses/week | each new typescript project |
| leverage.adopt.time | cost(90 mins/tool) | learning (60) + integration (30) |


---


## 5. comparison matrix

### 5.1. leverage.author comparison

| metric | with-simple-cache | dynamodb-dao-gen | declapract-ts |
|--------|-------------------|------------------|---------------|
| leverage.author.time | save(15-25 mins/use) | save(4-8 hrs/use) | save(4-8 hrs/use) |
| leverage.author.code.block | save(5-7 blocks/use) | save(28-43 blocks/use) | save(75+ blocks/use) |
| leverage.author.code.path | save(7 paths/use) | save(40 paths/use) | save(0 paths/use) |
| leverage.author.khue | save(9 khues/use) | save(25 khues/use) | save(80+ khues/use) |


### 5.2. leverage.support comparison

| metric | with-simple-cache | dynamodb-dao-gen | declapract-ts |
|--------|-------------------|------------------|---------------|
| leverage.support.time | save(30 mins/fail) | save(2 hrs/fail) | save(1 hr/fail) |
| leverage.support.signal | gain(1 signal/use) | gain(4 signals/use) | gain(5+ signals/use) |
| leverage.support.defence | gain(3 defences/use) | gain(8 defences/use) | gain(43+ defences/use) |


### 5.3. leverage.adopt comparison

| metric | with-simple-cache | dynamodb-dao-gen | declapract-ts |
|--------|-------------------|------------------|---------------|
| leverage.adopt.freq | 5 uses/week | 0.5 uses/week | 0.25 uses/week |
| leverage.adopt.time | cost(45 mins/tool) | cost(3 hrs/tool) | cost(90 mins/tool) |


---


## 6. composite leverage calculation

### 6.1. formula

```
leverage.composite/week =
  (leverage.author.time × leverage.adopt.freq) +
  (leverage.author.code.block × mins/block × leverage.adopt.freq) +
  (leverage.author.khue × mins/khue × leverage.adopt.freq)
  - leverage.adopt.time (amortized)

where:
  mins/block = 5 min (avg time to write and debug one logical code paragraph)
  mins/khue = 5 min (avg time to research and decide one question)
```

### 6.2. example calculation: with-simple-cache

```
assume: 20 usages per month across codebase

time.contribution = 20 min × 20 = 400 min/month
blocks.contribution = 6 blocks × 5 min × 20 = 600 min/month
khues.contribution = 9 × 5 min × 20 = 900 min/month

total.authorable.leverage = 400 + 600 + 900 = 1900 min/month ≈ 32 hr/month
```

### 6.3. example calculation: dynamodb-dao-generator

```
assume: 2 new entities per month

time.contribution = 6 hr × 2 = 12 hr/month
blocks.contribution = 35 blocks × 5 min × 2 = 350 min = 5.8 hr/month
khues.contribution = 25 × 5 min × 2 = 250 min = 4.2 hr/month

total.authorable.leverage = 12 + 5.8 + 4.2 = 22 hr/month
```

### 6.4. example calculation: declapract-typescript-ehmpathy

```
assume: 1 new project per month, + ongoing compliance across 10 repos

time.contribution = 6 hr × 1 = 6 hr/month
blocks.contribution = 75 blocks × 5 min × 1 = 375 min = 6.25 hr/month
khues.contribution = 80 × 5 min × 1 = 400 min = 6.7 hr/month

total.authorable.leverage = 6 + 6.25 + 6.7 = 19 hr/month
```


---


## 7. insights from absolute measurement

### 7.1. frequency amplifies small gains

with-simple-cache saves only 20 min per use, but high frequency (20/month) yields comparable monthly leverage to dynamodb-dao-generator (2/month but 6hr each).

### 7.2. khues are undervalued

cognitive load reduction (leverage.author.khue) often contributes more than raw time or code saved. each khue avoided saves research time, debate time, and future regret.

### 7.3. leverage.adopt.freq drives total leverage

- **5 uses/week**: with-simple-cache - frequent, small gains compound
- **0.5 uses/week**: dynamodb-dao-generator - infrequent, large gains per use
- **0.25 uses/week**: declapract - rare, but massive gains per use

high freq × small gain ≈ low freq × large gain


---


## 8. metric summary

### 8.1. leverage.author (effort saved)

| metric | polarity | what it measures |
|--------|----------|------------------|
| **leverage.author.time** | save | wall-clock effort reduction |
| **leverage.author.code.block** | save | structural complexity reduction |
| **leverage.author.code.path** | save | branching complexity reduction |
| **leverage.author.khue** | save | cognitive load reduction |

### 8.2. leverage.support (upkeep cost)

| metric | polarity | what it measures |
|--------|----------|------------------|
| **leverage.support.time** | save | "fast to fix" - time saved during incidents |
| **leverage.support.signal** | gain | "first to know" - observability hooks |
| **leverage.support.defence** | gain | "last to fail" - safeguards + failsafes |

### 8.3. leverage.adopt (adoption cost)

| metric | polarity | what it measures |
|--------|----------|------------------|
| **leverage.adopt.freq** | — | "how often?" - expected uses per week |
| **leverage.adopt.time** | cost | "how hard to start?" - one-time learning + integration |


---


## 9. open questions

1. how to weight different metrics in composite calculation?
2. should frequency be measured or estimated?
3. how to handle metrics that are infinite (∞ usecases)?
4. should lock-in (perTool.migration.hours) be a negative factor?
5. how to normalize across different scales (hours vs LOC vs count)?

