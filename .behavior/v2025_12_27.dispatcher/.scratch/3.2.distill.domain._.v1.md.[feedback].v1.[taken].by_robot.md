# feedback response: domain distillation v1

## response checklist

- [x] blocker.1: split measureBehaviors into deptraceBehaviors + measureBehaviors
  - [x] add deptraceBehaviors operation -> BehaviorDeptraced
  - [x] update measureBehaviors to depend on deptrace output
  - [x] clarify dependency: deptrace runs first, measure uses its output

- [x] blocker.2: clarify contracts for independent per-behavior processing
  - [x] deptraceOneBehavior: input = (behaviorsGathered, subject)
  - [x] measureOneBehavior: input = (behaviorsGathered, behaviorsDeptraced, subject, criteria)
  - [x] make parallelizable structure explicit via notes

- [x] blocker.3: rename BehaviorMeasurement -> BehaviorMeasured
  - [x] update all references in domain.objects
  - [x] update all references in domain.operations
  - [x] update all references in access.daos

- [x] blocker.4: remove fromCache from contracts
  - [x] remove from BehaviorGathered
  - [x] remove from BehaviorMeasured
  - [x] remove from operation return types
  - [x] cache is implementation detail, not contract

- [x] blocker.5: rename byBucket -> byUrgency
  - [x] update triage output contracts
  - [x] clarify temporal dimension of triage (urgency = temporal)

- [x] blocker.6: rename writePrioritizationOutput -> savePrioritizationDecisions
  - [x] update operation name
  - [x] renamed all write* -> save* for consistency (saveGatheredBehaviors, savePrioritizationDecisions, saveCoordinationDecisions)

- [x] blocker.7: rename coordination operations for clarity
  - [x] groupIntoStreams -> assignBehaviorsToWorkstreams
  - [x] identifyStreamIntersections -> detectWorkstreamBottlenecks
  - [x] orderStreamsByReviewPriority -> rankWorkstreamsByReviewPriority
  - [x] coordinateStreams -> coordinateWorkstreams

- [x] blocker.8: extract gather as standalone skill
  - [x] gather skill: produces gathered behaviors output to .gathered/
  - [x] prioritize skill: consumes gathered output, produces prioritization
  - [x] coordinate skill: consumes prioritization output
  - [x] each skill has clear input/output contracts
  - [x] updated 2.criteria.md to reflect skill decomposition

---

## response checkoffs

- [x] blocker.1: split measureBehaviors into deptraceBehaviors + measureBehaviors
  - [x] add deptraceBehaviors operation -> BehaviorDependencyGraph
  - [x] update measureBehaviors to depend on deptrace output
  - [x] clarify dependency: deptrace runs first, measure uses its output

- [x] blocker.2: clarify contracts for independent per-behavior processing
  - [x] deptraceBehaviors: input = (gatheredBasket, subjectBehavior)
  - [x] measureBehaviors: input = (gatheredBasket, deptracedBasket, subjectBehavior)
  - [x] make parallelizable structure explicit

- [x] blocker.3: rename BehaviorMeasurement -> BehaviorMeasured
  - [x] update all references in domain.objects
  - [x] update all references in domain.operations
  - [x] update all references in access.daos

- [x] blocker.4: remove fromCache from contracts
  - [x] remove from BehaviorGathered
  - [x] remove from BehaviorMeasured
  - [x] remove from operation return types
  - [x] cache is implementation detail, not contract

- [x] blocker.5: rename byBucket -> byUrgency
  - [x] update triage output contracts
  - [x] clarify temporal dimension of triage

- [x] blocker.6: rename writePrioritizationOutput -> savePrioritizationDecisions
  - [x] update operation name
  - [x] consider other write* operations for consistency

- [x] blocker.7: rename coordination operations for clarity
  - [x] groupIntoStreams -> assignBehaviorsToWorkstreams
  - [x] review other coordination operations for intuitive names

- [x] blocker.8: extract gather as standalone skill
  - [x] gather skill: produces gathered behaviors output
  - [x] prioritize skill: consumes gathered output, produces prioritization
  - [x] update criteria to reflect skill decomposition
  - [x] 2.criteria.md updated with all scope renumbering and terminology changes

- [x] follow-up: extract deptrace as standalone skill
  - [x] deptrace skill: consumes gathered output, produces deptraced output
  - [x] prioritize skill: now consumes gathered + deptraced output
  - [x] added deptrace.ts to skill entry points (section 4.6)
  - [x] added saveDeptracedBehaviors operation
  - [x] updated directory structure with deptrace skill folder
  - [x] updated skill pipeline: gather → deptrace → prioritize → coordinate
  - [x] updated section 7.3, 7.4, 7.8 for skill decomposition
  - [x] updated 2.criteria.md:
    - [x] usecase.2.1: added deptrace to skill list
    - [x] scope.4: renamed to "deptrace skill" (was "prioritize skill - deptrace behaviors")
    - [x] scope.5: updated to note prioritize consumes deptrace output
    - [x] usecase.9.2: added deptrace skill invocation
    - [x] usecase.9.3: updated prioritize to consume gathered + deptraced
    - [x] usecase.9.5: added deptrace idempotency check
    - [x] scope.12: renamed to "deptrace skill cache"
    - [x] scope.13: added "prioritize skill cache" (was combined in scope.12)
  - [x] expanded scope.4 deptrace criteria (10 usecases):
    - [x] usecase.4.1: deptrace skill purpose (what "deptrace" means)
    - [x] usecase.4.2: input/output contracts (BehaviorDeptraced fields)
    - [x] usecase.4.3: parallelizable per-behavior processing
    - [x] usecase.4.4: resolve direct dependencies (same-repo and cross-repo)
    - [x] usecase.4.5: compute transitive dependencies (upstream and downstream)
    - [x] usecase.4.6: handle missing dependencies (resolved=false placeholder)
    - [x] usecase.4.7: detect circular dependencies (flag + cycle list)
    - [x] usecase.4.8: handle behaviors with no dependencies
    - [x] usecase.4.9: handle behaviors depended by nothing
    - [x] usecase.4.10: deterministic output
  - [x] updated BehaviorDeptraced in domain distillation:
    - [x] added resolved flag to dependsOnDirect/dependsOnTransitive
    - [x] added circularDependency boolean
    - [x] added circularDependencyCycle array

- [x] follow-up: gather skill directory-copy model
  - [x] changed from JSON-encoding to literal directory copy
  - [x] each behavior copied to {output}/.gathered/{org}/{repo}/{behaviorName}/
  - [x] added .origin.json for provenance (sourceType, sourcePath, org, repo, gatheredAt, contentHash)
  - [x] removed gathered.json index (redundant - directory structure is sufficient)
  - [x] updated scope.3 usecases for coherence:
    - [x] usecase.3.1: output contract with directory copy model
    - [x] usecase.3.2: local sources (local.dirs)
    - [x] usecase.3.3: remote sources (remote.repos only)
    - [x] usecase.3.4: capture behavior status (all copied, status in .origin.json)
  - [x] dropped remote.orgs scanning (repos must be enumerated explicitly)
  - [x] changed status handling: all behaviors copied, status tracked in .origin.json
    - [x] status="delivered" for done behaviors (not filtered out)
    - [x] status="paused" for paused behaviors
    - [x] status="active" for behaviors with no status declared

- [x] follow-up: probabilistic measurement model
  - [x] added yieldageDistribution as { yieldage, probability }[] model
  - [x] failure probability captured as { yieldage: 0, probability: P }
  - [x] yieldageExpected = sum of (yieldage × probability) for each entry
  - [x] deterministic yield is degenerate case: [{ yieldage: X, probability: 1.0 }]
  - [x] added brief reference for yieldageDistribution in usecase.1.1

- [x] follow-up: $noun.$adj naming pattern
  - [x] renamed expectedYieldage → yieldageExpected
  - [x] consistent with naming pattern throughout criteria

- [x] follow-up: gerund elimination
  - [x] replaced all gerunds throughout criteria
  - [x] "modeling" → "model", "naming" → "names", "unblocking" → "unblocked"
  - [x] "analyzing" → "analysis of", "ordering" → "order", "containing" → "contains"
  - [x] "missing" → "absent/unresolved", "causing" → "occurs"
  - [x] "producing/consuming" → arrow notation, "running" → "runs"
  - [x] "failing" → "failed", "debugging" → "debug", "caching" → "cache"

- [x] follow-up: simplified deptrace for composability
  - [x] deptrace only tracks dependsOn* (not dependedBy*)
  - [x] each behavior deptrace is self-contained and cacheable independent of other behaviors
  - [x] removed dependedByDirect and dependedByTransitive from output
  - [x] removed usecase.4.9 (behaviors with no dependents) - no longer applicable
  - [x] updated usecase.4.1 to clarify graph does NOT include dependedBy

- [x] follow-up: blockee computation in measure skill
  - [x] added usecase.5.2 for blockee computation via graph inversion
  - [x] blockees computed once per measure run, not per behavior
  - [x] measureOneBehavior now receives (gatheredBasket, deptracedBasket, subject, blockees)
  - [x] renumbered subsequent usecases in scope.5

- [x] follow-up: cache/idempotency criteria per skill
  - [x] added usecase.3.5: gather cache and idempotency
  - [x] added usecase.4.9: deptrace cache and idempotency
  - [x] added usecase.5.6: measure cache and idempotency
  - [x] added usecase.6.4: triage cache and idempotency
  - [x] added usecase.9.4: coordinate cache and idempotency
  - [x] each skill explains when recomputation is needed vs skipped

- [x] follow-up: consolidated cache scopes
  - [x] removed old scope.12-14 (separate cache sections for gather, deptrace, measure)
  - [x] replaced with single scope.12 about cache implementation mechanism
  - [x] added usecase.12.1: cache mechanism (with-simple-cache, simple-on-disk-cache)
  - [x] added usecase.12.2: parallel execution for deptrace and measure skills

- [x] follow-up: removed rank skill (absolute thresholds suffice)
  - [x] removed scope.7 (rank skill) entirely
  - [x] rank skill was unnecessary; absolute measurement thresholds in triage.dimension=bandwidth suffice
  - [x] updated pipeline: gather → deptrace → measure → triage (no rank)
  - [x] renumbered scopes: coordinate → 8, invocation → 9, interactive → 10, cache → 11
  - [x] updated coordinate skill to reference triaged behaviors instead of ranked
  - [x] removed rank skill invocation (usecase.9.5)
  - [x] updated prioritize composite to remove rank from pipeline
  - [x] updated idempotent execution to remove rank references

- [x] follow-up: symmetric dimension/decision contracts
  - [x] BehaviorMeasured: dimensions = { gain: { yieldage, leverage }, cost }
  - [x] BehaviorMeasured: decision = dimensions.gain.yieldage / dimensions.cost
  - [x] BehaviorTriaged: dimensions = { readiness, bandwidth }
  - [x] BehaviorTriaged: decision = min(readiness, bandwidth)
  - [x] consistent { dimensions, decision } pattern for both measure and triage