# leverage evaluation: dynamodb-dao-generator

**source:** https://github.com/ehmpathy/dynamodb-dao-generator


---


## 1. tool description

dynamodb-dao-generator is a CLI tool that automatically generates data-access objects (DAOs) from domain-object definitions. one command produces:
- typescript type definitions
- query functions (get, set, find, etc)
- terraform infrastructure code
- schema migration utilities

the tool extracts metadata from domain-objects and generates complete, production-ready database access layer code.


---


## 2. leverage narrative

### 2.1. what problem does it solve?

writing dynamodb DAOs by hand is:
- **slow**: each entity requires 200-500 lines of boilerplate
- **error-prone**: easy to miss edge cases (pagination, retries, batch limits)
- **inconsistent**: different authors write different patterns
- **maintenance burden**: changes to best practices require manual propagation

### 2.2. how does it create leverage?

the generator moves effort from **use time** (adhoc, per entity) to **arm time** (upfront, once):

```
wout generator:
  per entity: 4-8 hours to write DAO + tests + terraform
  10 entities = 40-80 hours

with generator:
  arm.effort: 1 hour to configure
  per entity: 5 minutes to add to config + regenerate
  10 entities = 1 hour + 50 minutes ≈ 2 hours
```

**leverage ratio:** ~20-40x for authorship velocity

### 2.3. where does leverage compound?

1. **authorable → adoptable**: generated code follows consistent patterns, making adoption easier
2. **authorable → supportable**: generated code includes observability hooks, making support easier
3. **safer → faster**: type-safe generated code reduces debugging time


---


## 3. leverage measurements

### 3.1. leverage.authorable

| subdimension | score | rationale |
|--------------|-------|-----------|
| **simpler** | 9/10 | declare domain object + run command; no DAO knowledge required |
| **faster** | 10/10 | seconds to generate vs hours to write |
| **safer** | 9/10 | generated code eliminates typos, edge cases, best practice misses |

**composite:** 9.3/10

**narrative:** "one command generates production-ready persistence code in seconds, eliminating the cognitive load of dynamodb quirks and the risk of implementation errors."


### 3.2. leverage.supportable

| subdimension | score | rationale |
|--------------|-------|-----------|
| **observable** | 8/10 | generated code includes logging hooks, but no built-in tracing |
| **intuitive** | 9/10 | consistent patterns across all generated DAOs; predictable structure |
| **resilient** | 8/10 | retry logic, pagination handling built-in |
| **maintainable** | 9/10 | regenerate to apply fixes; single source of truth |

**composite:** 8.5/10

**narrative:** "when issues occur, the consistent structure makes debugging fast. regenerating propagates fixes across all DAOs instantly."


### 3.3. leverage.adoptable

| subdimension | score | rationale |
|--------------|-------|-----------|
| **reusable** | 9/10 | works with any domain-object; platform-agnostic design |
| **pitofsuccess** | 9/10 | generated code is idempotent, type-safe, hard to misuse |
| **documented** | 7/10 | README covers basics; inline comments in generated code sparse |
| **evolvable** | 8/10 | regenerate to evolve; but customizations require care |

**composite:** 8.3/10

**narrative:** "adopting the generator is straightforward for any domain-objects project. generated code is hard to misuse due to type safety and idempotent operations."


---


## 4. gain analysis

### 4.1. absolute gain per use

| metric | wout generator | with generator | gain |
|--------|----------------|----------------|------|
| time to create DAO | 4-8 hours | 5 minutes | 48-96x |
| lines of code written | 300-500 | 10 (config) | 30-50x |
| defect rate | ~5% per DAO | <0.5% | 10x safer |
| terraform accuracy | manual, error-prone | generated | ∞ (0 effort) |

**absolute gain per use:** ~50x authorship velocity, ~10x safety improvement


### 4.2. relative frequency (how often we gain)

| scenario | frequency | notes |
|----------|-----------|-------|
| new domain entity needing persistence | high (30-50% of entities) | most entities need persistence |
| new project setup | medium (every new service) | one-time per project |
| best practice updates | low (quarterly) | regenerate propagates instantly |

**coverage:** ~40% of domain modeling work benefits directly


### 4.3. compound leverage

```
total_leverage = absolute_gain × frequency × compound_factor

where:
  absolute_gain = 50x (authorship velocity)
  frequency = 0.4 (40% of entities)
  compound_factor = 1.5 (supportable + adoptable benefits)

total_leverage = 50 × 0.4 × 1.5 = 30x effective leverage
```


---


## 5. dimension summary

| dimension | score | key insight |
|-----------|-------|-------------|
| leverage.authorable | 9.3/10 | eliminates boilerplate, enforces best practices |
| leverage.supportable | 8.5/10 | consistent patterns, regenerate to fix |
| leverage.adoptable | 8.3/10 | works with any domain-objects project |

**overall leverage grade:** A (8.7/10)

**one-sentence summary:** dynamodb-dao-generator provides ~30x effective leverage by eliminating persistence boilerplate and enforcing production-ready patterns across ~40% of domain modeling work.

