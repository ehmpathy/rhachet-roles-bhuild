# domain research: leverage dimensions (v5)

this document builds on v4 research to:
1. catalog termFound → termCluster mappings
2. analyze termCluster.choice candidates with pros/cons
3. establish dimension hierarchy with subdimensions
4. propose lifecycle-based taxonomy: authorable, supportable, adoptable
5. provide usage examples for term validation


---


## 1. term cluster catalog

### 1.1. termFound → termCluster mapping

| termFound            | termCluster               | rationale                              |
| -------------------- | ------------------------- | -------------------------------------- |
| modular              | **leverage.reusable**     | structural property enabling reuse     |
| reusable             | **leverage.reusable**     | direct term                            |
| composable           | **leverage.reusable**     | composition requires reusable parts    |
| decomposition        | **leverage.reusable**     | breaking into reusable parts           |
| decoupled            | **leverage.reusable**     | decoupling enables reuse               |
| generalized          | **leverage.reusable**     | generalization enables broader reuse   |
| portable             | **leverage.reusable**     | portability = reuse across platforms   |
| loose coupling       | **leverage.reusable**     | enables independent reuse              |
| ---                  | ---                       | ---                                    |
| resilient            | **leverage.resilient**    | direct term                            |
| fault tolerant       | **leverage.resilient**    | fault tolerance = resilience mechanism |
| robust               | **leverage.resilient**    | robustness = resilience property       |
| graceful degradation | **leverage.resilient**    | resilience pattern                     |
| error adaptation     | **leverage.resilient**    | resilience mechanism                   |
| survivability        | **leverage.resilient**    | resilience outcome                     |
| ---                  | ---                       | ---                                    |
| safer                | **leverage.safer**        | direct term                            |
| secure               | **leverage.safer**        | security = safety from attacks         |
| freedom from risk    | **leverage.safer**        | safety outcome                         |
| ---                  | ---                       | ---                                    |
| discoverable         | **leverage.intuitive**    | findability = intuitive access         |
| predictable          | **leverage.intuitive**    | predictability = intuitive behavior    |
| readable             | **leverage.intuitive**    | readability = intuitive comprehension  |
| findable             | **leverage.intuitive**    | findability = intuitive discovery      |
| deterministic        | **leverage.intuitive**    | determinism = intuitive expectations   |
| ---                  | ---                       | ---                                    |
| traceable            | **leverage.observable**   | traceability = causal observation      |
| visible              | **leverage.observable**   | visibility = state observation         |
| observable           | **leverage.observable**   | direct term                            |
| logging              | **leverage.observable**   | observation mechanism                  |
| metrics              | **leverage.observable**   | observation mechanism                  |
| debuggable           | **leverage.observable**   | observation outcome                    |
| ---                  | ---                       | ---                                    |
| faster               | **leverage.velocity**     | speed dimension                        |
| speed                | **leverage.velocity**     | direct term                            |
| velocity             | **leverage.velocity**     | direct term                            |
| throughput           | **leverage.velocity**     | throughput = sustained velocity        |
| latency              | **leverage.velocity**     | latency = inverse velocity             |
| responsiveness       | **leverage.velocity**     | responsiveness = perceived velocity    |
| iteration rate       | **leverage.velocity**     | velocity of feedback cycles            |
| ---                  | ---                       | ---                                    |
| evolvable            | **leverage.evolvable**    | direct term                            |
| extensible           | **leverage.evolvable**    | extensibility = evolution mechanism    |
| flexible             | **leverage.evolvable**    | flexibility = evolution enabler        |
| adaptable            | **leverage.evolvable**    | adaptability = evolution outcome       |
| modifiable           | **leverage.evolvable**    | modifiability = evolution capability   |
| changeable           | **leverage.evolvable**    | changeability = evolution synonym      |
| scalable             | **leverage.evolvable**    | scalability = evolution for load       |
| configurable         | **leverage.evolvable**    | runtime evolution                      |
| ---                  | ---                       | ---                                    |
| maintainable         | **leverage.maintainable** | direct term                            |
| analysable           | **leverage.maintainable** | analysis for maintenance               |
| supportable          | **leverage.maintainable** | support = maintenance role             |
| ---                  | ---                       | ---                                    |
| testable             | **leverage.feedback**     | testing = feedback mechanism           |
| verifiable           | **leverage.feedback**     | verification = feedback mechanism      |
| autonomous           | **leverage.feedback**     | self-service = fast feedback           |
| feedback loops       | **leverage.feedback**     | direct term                            |
| iteration count      | **leverage.feedback**     | feedback cycle measure                 |
| ---                  | ---                       | ---                                    |
| idempotent           | **leverage.pitofsuccess** | idempotency = safe retry               |
| deterministic        | **leverage.pitofsuccess** | determinism = predictable outcome      |
| pure                 | **leverage.pitofsuccess** | purity = no side effects               |
| side-effect free     | **leverage.pitofsuccess** | safety property                        |
| parallelizable       | **leverage.pitofsuccess** | safe concurrency                       |
| ---                  | ---                       | ---                                    |
| simpler              | **leverage.simpler**      | direct term                            |
| cognitive load       | **leverage.simpler**      | simplicity measure                     |
| comprehension        | **leverage.simpler**      | simplicity outcome                     |
| ---                  | ---                       | ---                                    |
| documented           | **leverage.adoptable**    | documentation = adoption enabler       |
| onboarding           | **leverage.adoptable**    | adoption measure                       |
| adoption rate        | **leverage.adoptable**    | adoption outcome                       |
| self-service         | **leverage.adoptable**    | adoption mechanism                     |


---


## 2. termCluster.choice analysis

### 2.1. cluster: structural reuse

**options:** modular, reusable, composable, portable, decoupled, generalized

| candidate      | pros                                                     | cons                                      |
| -------------- | -------------------------------------------------------- | ----------------------------------------- |
| **reusable**   | direct, intuitive, action-oriented ("can i reuse this?") | may imply copy-paste reuse vs composition |
| **composable** | captures assembly pattern, modern term                   | less intuitive to non-engineers           |
| **modular**    | ISO 25010 standard term, well-defined                    | describes structure, not outcome          |

**choice:** `leverage.reusable`

**rationale:** "reusable" is the most direct answer to the adoption question "can i use this again?" it subsumes modular (structure), composable (assembly), and portable (platforms) as mechanisms toward the outcome of reuse.


### 2.2. cluster: failure handling

**options:** resilient, safer, robust, fault-tolerant

| candidate     | pros                                  | cons                    |
| ------------- | ------------------------------------- | ----------------------- |
| **safer**     | broader scope (prevention + recovery) | ambiguous with security |
| **resilient** | recovery-focused, industry standard   | narrower than "safe"    |
| **robust**    | captures stress handling              | less common in software |

**choice:** split into two clusters

- `leverage.safer` = prevention (reduce failure risk)
- `leverage.resilient` = recovery (handle failures gracefully)

**rationale:** prevention and recovery are distinct concerns. safer reduces the probability of failure. resilient reduces the impact of failure. both contribute to reliability but require different mechanisms.


### 2.3. cluster: cognitive access

**options:** discoverable, predictable, readable, intuitive, findable

| candidate        | pros                                | cons                                 |
| ---------------- | ----------------------------------- | ------------------------------------ |
| **intuitive**    | captures "falls into understanding" | subjective, hard to measure          |
| **readable**     | concrete, measurable                | narrower than discovery + prediction |
| **discoverable** | captures findability                | misses behavioral predictability     |
| **predictable**  | captures behavioral expectation     | misses structural findability        |

**choice:** `leverage.intuitive`

**rationale:** "intuitive" composes readable (comprehension), discoverable (findability), and predictable (expectation). something intuitive requires all three: you can find it, read it, and predict how it behaves. intuitive is the outcome; readable/discoverable/predictable are subdimensions.


### 2.4. cluster: visibility

**options:** traceable, visible, observable, debuggable

| candidate      | pros                            | cons                               |
| -------------- | ------------------------------- | ---------------------------------- |
| **observable** | industry standard (o11y), broad | sometimes confused with monitoring |
| **traceable**  | captures causality              | narrower scope                     |
| **visible**    | simple                          | too generic                        |

**choice:** `leverage.observable`

**rationale:** "observable" is the industry standard term encompassing metrics, logs, and traces. it's the broadest term that subsumes traceable (causality), visible (state), and debuggable (outcome).


### 2.5. cluster: speed

**options:** faster, speed, velocity, throughput, latency, efficiency

| candidate      | pros                          | cons                         |
| -------------- | ----------------------------- | ---------------------------- |
| **velocity**   | encompasses direction + speed | overloaded (story points)    |
| **throughput** | measures sustained output     | narrower than "fast"         |
| **faster**     | intuitive, direct             | relative term needs baseline |
| **efficiency** | output/input ratio            | conflates resource usage     |

**choice:** `leverage.velocity`

**rationale:** "velocity" best captures both development speed (iteration rate) and production speed (throughput). it avoids confusion with "efficiency" (resource optimization) and "faster" (relative comparison). velocity = distance/time = outcomes/duration.


### 2.6. cluster: changeability

**options:** evolvable, maintainable, extensible, flexible, adaptable

| candidate        | pros                    | cons                       |
| ---------------- | ----------------------- | -------------------------- |
| **evolvable**    | captures forward change | less common term           |
| **maintainable** | ISO standard, intuitive | conflates retain vs evolve |
| **extensible**   | captures growth         | narrower than evolution    |

**choice:** split into two clusters

- `leverage.maintainable` = retain behavior set (fix bugs, keep running)
- `leverage.evolvable` = update behavior set (add features, refactor)

**rationale:** critical distinction:
- maintainable = ease of keeping the system working as-is
- evolvable = ease of changing what the system does

you can have high maintainability (easy to fix bugs) but low evolvability (hard to add features). and vice versa.


### 2.7. cluster: feedback

**options:** testable, verifiable, autonomous, feedback loops

| candidate      | pros                      | cons                   |
| -------------- | ------------------------- | ---------------------- |
| **testable**   | concrete, measurable      | narrower than feedback |
| **feedback**   | captures the loop concept | more abstract          |
| **verifiable** | formal methods term       | too academic           |

**choice:** `leverage.feedback`

**rationale:** "feedback" is the parent dimension. testable, verifiable, and autonomous are subdimensions that contribute to feedback speed and quality. fast feedback requires: automated tests (testable), formal proofs (verifiable), and self-service (autonomous).


### 2.8. cluster: pit of success

**options:** idempotent, deterministic, pure, failsafe, predictable

| candidate         | pros                    | cons                     |
| ----------------- | ----------------------- | ------------------------ |
| **pitofsuccess**  | captures "hard to fail" | non-standard term        |
| **failsafe**      | captures safe failure   | only covers failure case |
| **deterministic** | captures predictability | narrower scope           |

**choice:** `leverage.pitofsuccess`

**rationale:** "pitofsuccess" goes beyond failsafe. failsafe = fail safely when things go wrong. pitofsuccess = hard to do wrong in the first place. it composes idempotent (safe retry), deterministic (predictable output), pure (no side effects), and parallelizable (safe concurrency).


---


## 3. dimension hierarchy

### 3.1. full hierarchy

```
leverage dimensions
├── leverage.authorable (author time)
│   ├── leverage.simpler (cognitive load)
│   │   ├── comprehension ease
│   │   ├── integration ease
│   │   └── establishment ease
│   ├── leverage.safer (failure risk)
│   │   ├── mistake prevention
│   │   ├── mistake severity (sweater vs haircut vs tattoo)
│   │   └── security
│   ├── leverage.velocity (consumed cost)
│   │   ├── time to produce
│   │   ├── tokens consumed
│   │   └── tools required
│   └── leverage.feedback (validation loops)
│       ├── testable (automated validation)
│       ├── verifiable (formal proofs)
│       └── autonomous (self-service)
│
├── leverage.supportable (upkeep time)
│   ├── leverage.observable (detect issues)
│   │   ├── traceable (causality)
│   │   ├── visible (state)
│   │   ├── metrics (quantitative)
│   │   └── logging (qualitative)
│   ├── leverage.intuitive (fix issues)
│   │   ├── readable (comprehension)
│   │   ├── discoverable (findability)
│   │   └── predictable (expectation)
│   ├── leverage.resilient (survive issues)
│   │   ├── fault tolerant (zero degradation)
│   │   ├── graceful degradation (partial function)
│   │   └── recovery speed (MTTR)
│   └── leverage.maintainable (retain behavior)
│       ├── analysable (understand for fix)
│       └── modifiable (change for fix)
│
├── leverage.adoptable (adoption time)
│   ├── leverage.reusable (multi-use potential)
│   │   ├── modular (independent units)
│   │   ├── composable (combinable units)
│   │   ├── portable (platform independent)
│   │   └── decoupled (low trust contracts)
│   ├── leverage.pitofsuccess (hard to misuse)
│   │   ├── idempotent (safe retry)
│   │   ├── deterministic (predictable output)
│   │   ├── pure (no side effects)
│   │   └── parallelizable (safe concurrency)
│   ├── leverage.documented (learnable)
│   │   ├── api docs (contract clarity)
│   │   ├── examples (usage patterns)
│   │   └── comments (inline context)
│   └── leverage.evolvable (update behavior)
│       ├── extensible (add capabilities)
│       ├── flexible (adapt to usecases)
│       ├── scalable (handle growth)
│       └── configurable (runtime changes)
```


### 3.2. lifecycle mapping

| lifecycle phase   | parent dimension     | what it measures             |
| ----------------- | -------------------- | ---------------------------- |
| **author time**   | leverage.authorable  | ease of writing products     |
| **upkeep time**   | leverage.supportable | ease of maintaining products |
| **adoption time** | leverage.adoptable   | ease of reusing products     |


### 3.3. key distinctions

**maintainable vs evolvable:**
- maintainable = retain existing behavior (fix bugs, keep running)
- evolvable = change behavior set (add features, refactor arch)

example:
- legacy COBOL system: high maintainability (runs for decades), low evolvability (hard to extend)
- over-abstracted system: high evolvability (easy to add features), low maintainability (hard to debug)

**safer vs resilient:**
- safer = reduce probability of failure (prevention)
- resilient = reduce impact of failure (recovery)

example:
- type system: increases safety (catches errors at compile time)
- circuit breaker: increases resilience (prevents cascade failures)

**feedback vs testable:**
- feedback = parent dimension (loop speed + quality)
- testable = subdimension (automated validation mechanism)

example:
- testable code with slow CI: high testability, low feedback
- REPL with no tests: high feedback speed, low testability


---


## 4. usage examples

### 4.1. grading examples

**example A: domain-objects library**

```
leverage.authorable: 9/10
├── simpler: 9/10 (declarative syntax, minimal boilerplate)
├── safer: 8/10 (runtime validation, type safety)
├── velocity: 9/10 (seconds to declare, compatible with tools)
└── feedback: 8/10 (instant type errors, test utilities)

leverage.supportable: 8/10
├── observable: 7/10 (serializable, but no built-in tracing)
├── intuitive: 9/10 (explicit .unique, .updatable declarations)
├── resilient: 7/10 (fails fast on invalid data)
└── maintainable: 9/10 (single file per domain object)

leverage.adoptable: 9/10
├── reusable: 10/10 (domain-agnostic, any project)
├── pitofsuccess: 9/10 (immutable by default, clone pattern)
├── documented: 8/10 (README, examples, but sparse inline docs)
└── evolvable: 8/10 (extensible via .build(), .nested)
```

**verdict:** high leverage across all dimensions. optimized for pit-of-success via immutability and declarative patterns.


**example B: poorly documented internal service**

```
leverage.authorable: 4/10
├── simpler: 3/10 (complex setup, many implicit dependencies)
├── safer: 5/10 (some validation, but hidden edge cases)
├── velocity: 4/10 (hours to understand before writing)
└── feedback: 3/10 (no tests, manual QA only)

leverage.supportable: 3/10
├── observable: 2/10 (minimal logging, no tracing)
├── intuitive: 3/10 (cryptic names, magic values)
├── resilient: 4/10 (some retry logic, but brittle)
└── maintainable: 4/10 (coupled modules, shared state)

leverage.adoptable: 2/10
├── reusable: 2/10 (tightly coupled to specific usecase)
├── pitofsuccess: 2/10 (easy to misuse, side effects everywhere)
├── documented: 1/10 (no docs, tribal knowledge only)
└── evolvable: 3/10 (fear of change, unknown blast radius)
```

**verdict:** low leverage. high maintenance burden, poor adoption potential.


### 4.2. dimension sentences

**leverage.authorable:**
> "this dao generator has high authorable leverage: one command produces type-safe persistence code in seconds, with built-in validation that catches mistakes at compile time."

**leverage.supportable:**
> "the service has low supportable leverage: when issues occur, there's no tracing to find the cause, logs are sparse, and the code is hard to read."

**leverage.adoptable:**
> "domain-objects has high adoptable leverage: it's reusable across any project, hard to misuse due to immutability, and well-documented with examples."

**leverage.feedback:**
> "the inner loop has high feedback leverage: type errors appear instantly, unit tests run in 2 seconds, and CI validates within 5 minutes."

**leverage.pitofsuccess:**
> "this function has high pitofsuccess leverage: it's idempotent (safe to retry), deterministic (same input → same output), and pure (no side effects)."


### 4.3. discriminative scenarios

**scenario: "should we use library X or build custom?"**

evaluate on adoptable dimensions:
- leverage.reusable: is X general enough for our usecase?
- leverage.pitofsuccess: is X hard to misuse?
- leverage.documented: can our team learn X quickly?
- leverage.evolvable: can we extend X if needed?

**scenario: "why is debugging this system so painful?"**

evaluate on supportable dimensions:
- leverage.observable: can we see what happened?
- leverage.intuitive: can we understand what we see?
- leverage.resilient: does the system help us recover?

**scenario: "why is feature development so slow?"**

evaluate on authorable dimensions:
- leverage.simpler: is there too much cognitive load?
- leverage.feedback: is the validation loop slow?
- leverage.safer: are we spending time on fear-driven testing?


---


## 5. proposed ubiquitous language

### 5.1. canonical terms

| cluster             | canonical term          | deprecated terms                         |
| ------------------- | ----------------------- | ---------------------------------------- |
| structural reuse    | `leverage.reusable`     | modular, composable, portable, decoupled |
| failure prevention  | `leverage.safer`        | secure, risk-free                        |
| failure recovery    | `leverage.resilient`    | fault-tolerant, robust                   |
| cognitive access    | `leverage.intuitive`    | readable, discoverable, predictable      |
| visibility          | `leverage.observable`   | traceable, visible, debuggable           |
| speed               | `leverage.velocity`     | faster, throughput, latency              |
| retain behavior     | `leverage.maintainable` | supportable, analysable                  |
| update behavior     | `leverage.evolvable`    | extensible, flexible, adaptable          |
| validation loops    | `leverage.feedback`     | testable, verifiable, autonomous         |
| hard to misuse      | `leverage.pitofsuccess` | idempotent, deterministic, pure          |
| cognitive load      | `leverage.simpler`      | easy, straightforward                    |
| adoption enablement | `leverage.adoptable`    | documented, onboardable                  |


### 5.2. lifecycle phases

| phase         | canonical term         | measures                     |
| ------------- | ---------------------- | ---------------------------- |
| author time   | `leverage.authorable`  | ease of writing products     |
| upkeep time   | `leverage.supportable` | ease of maintaining products |
| adoption time | `leverage.adoptable`   | ease of reusing products     |


### 5.3. formula reference

all dimensions follow the core leverage formula:

```
leverage.X = effort_wout_mechanism / effort_with_mechanism
```

where:
- leverage.X > 1.0 → mechanism provides leverage (less effort)
- leverage.X = 1.0 → no change in effort
- leverage.X < 1.0 → mechanism adds friction (more effort)


---


## 6. open questions

1. should `leverage.authorable` be renamed to `leverage.productive` for clarity?
2. should `leverage.supportable` be renamed to `leverage.maintainable` and current maintainable → `leverage.preservable`?
3. how to weight lifecycle phases against each other? (author vs upkeep vs adoption)
4. should `leverage.pitofsuccess` be split into `leverage.safe` (fail safely) and `leverage.pit` (hard to fail)?
5. are there missing subdimensions under each parent?

