emit your response to the feedback into
- .behavior/v2025_12_27.dispatcher/3.2.distill.domain._.v2.md.[feedback].v3.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist


---

reload your context from
- .behavior/v2025_12_27.dispatcher/0.wish.md
- .behavior/v2025_12_27.dispatcher/1.vision.md
- .behavior/v2025_12_27.dispatcher/2.criteria.blackbox.md
- .behavior/v2025_12_27.dispatcher/2.criteria.md
- .behavior/v2025_12_27.dispatcher/3.1.research.domain._.v1.i1.md
- .behavior/v2025_12_27.dispatcher/3.1.research.domain.leverage.v9.i1.md

then


1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---
---
---

# blocker.1

**user story**: as a dispatcher skill, i need to collect all behaviors from configured sources to analyze them.

=>

**user story**: as a @[dispatcher], i need to collect all behaviors from configured sources to analyze them.

---

# blocker.2


const result = await gatherBehavior({
  config: BehaviorDispatchConfig,
}, context);

// result shape
interface BehaviorGatherResult {
  behaviors: BehaviorGathered[];
  stats: {
    reposScanned: number;
    behaviorsFound: number;
    behaviorsChanged: number;
  };
}

=>


gatherBehavior({
  config: BehaviorDispatchConfig,
}, context) => Promise<{
  behaviors: BehaviorGathered[];
  stats: {
    reposScanned: number;
    behaviorsFound: number;
    behaviorsChanged: number;
  };
}>

why? cause we hate interfaces creeated for boudnary types; they just add noise. no benefit


do that for each

-----

# blocker.3

**user story**: as a dispatcher skill, i need to score behaviors by yieldage, leverage, and cost to determine priority.

=>

**user story**: as a @[dispatcher], i need to score behaviors by gain (yieldage, leverage) and cost (attend, expend) to determine priority.


what other descriptions are inconsistent with the latest criteria and terms distilled?

---

# blocker.4


measureBehavior({
  config: BehaviorDispatchConfig,
  behaviors: BehaviorDeptraced[],
}, context) => Promise<{
  behaviors: BehaviorMeasured[];
  stats: {
    all: number;
  };
}>

it should return stats on how many are in each priority basket, too


---

# blocker.5

why do i see custom cache keys declared?

lookup how with-simple-cache works and redeclare the contracts to make it clear that the get operations, when wrapped withSimpleCache, will automatically compute the cache key, when the key serialization mechanism is specified

---

# blocker.6

why do i see

BehaviorGathered

has the file contents bakedinto the domain object?

aren't paths to the cached files && the content hash sufficient?

why require massive variables in memory just to describe the fact that a behavior was gathered?

---

# blocker.7

isn't BehaviorGathered unique on [behavior, contentHash] both?

i.e., we gather a behavior, but the gathered behavior is specific to a particular contentHash

i.e., to reference a specific behavior gthered, you must know the contentHash

and on the contrary, you can have gathered multiple versions of contents of the behavior (i.e., many distinct BehaviorGathered over time for a distinct behavior)


if we make that update, then we can stop embedding contentHash in the other entities that need it. instead, they can just RefByUnique<typeof BehaviorGathered> - which will itself be composed of a unique reference to a behavior and a particular content hash of it


---

# nitpick.8


  /**
   * timestamp when deptraced
   */
  deptracedAt: string;


put the metadata timestamps closer to top of the attributes of the domain.objects


---

# blocker.9

decompose out distinct domain objects for these



  /**
   * gain: value gained by completing this behavior
   * gain(+$) = leverage + yieldage → converted to $$
   */
  gain: {
    dimensions: {
      /**
       * leverage = time gained (time can only be saved)
       * includes transitive impact from unblocked behaviors
       * see: 3.1.research.domain.leverage.v9.i1.md
       */
      leverage: BehaviorMeasuredGainLeverage;
      /**
       * yieldage = cash gained (cash can be saved or earned)
       * includes transitive impact from unblocked behaviors
       */
      yieldage: BehaviorMeasuredGainYieldage;
    };
    /**
     * composite gain in $$ (leverage + yieldage converted via convert.equate)
     */
    composite: number;
  };



and


  cost: {
    dimensions: {
      /**
       * attend = time cost (attention)
       */
      attend: BehaviorMeasuredCostAttend;
      /**
       * expend = cash cost (expenditure)
       */
      expend: BehaviorMeasuredCostExpend;
    };
    /**
     * composite cost in $$ (attend + expend converted via convert.equate)
     */
    composite: number;
  };


e.g., BehaviorMeasuredGain and BehaviorMeasuredCost



---

# blocker.10


interface BehaviorWorkstream {
  /**
   * workstream identifier
   */
  id: string;

  /**
   * human-readable name (e.g., "auth foundation")
   */
  name: string;

  /**
   * rank for prioritization (1 = highest)
   */
  rank: number;


id => slug

rank: number => BehaviorWorkstreamRank

where

type BehaviorWorkstreamRank = `r${number}`


---

# blocker.11

BehaviorWorkstreamEntry => BehaviorWorkstreamDeliverable


---

# blocker.12


interface BehaviorFile {
  /**
   * relative path within behavior directory
   */
  path: string;

  /**
   * file content (for relevant files like 0.wish.md)
   */
  content: string | null;
}

class BehaviorFile extends DomainLiteral<BehaviorFile> {}

dont create an adhoc file type

instead, leverage `rhachet-artifact-git` file type. websearch and lookup what it looks like and show an exmaple in the doc


---

# blocker.13

clearly nest direct vs transitive


interface BehaviorMeasuredGainLeverage {
  /**
   * author leverage = time saved to create ("add behavior")
   * measured in minutes saved per use
   */
  author: number;

  /**
   * support leverage = time saved to operate ("fix behavior")
   * measured in minutes saved per failure
   */
  support: number;

  /**
   * composite leverage in minutes/week
   * = (author × freq) + (support × fail.rate)
   */
  composite: number;

  /**
   * transitive leverage from unblocked behaviors
   * = sum of leverage.composite from behaviors this one unblocks
   */
  transitive: number;
}


=>


interface BehaviorMeasuredGainLeverage {
  /**
   * ...
   */
  direct: {
    /**
    * author leverage = time saved to create ("add behavior")
    * measured in minutes saved per use
    */
    author: number;

    /**
    * support leverage = time saved to operate ("fix behavior")
    * measured in minutes saved per failure
    */
    support: number;

    /**
    * composite leverage in minutes/week
    * = (author × freq) + (support × fail.rate)
    */
    composite: number;
  }

  /**
   * transitive leverage from unblocked behaviors
   * = sum of leverage.composite from behaviors this one unblocks
   */
  transitive: number;
}


# blocker.14

same here


interface BehaviorMeasuredGainYieldage {
  /**
   * possible yield outcomes with probabilities
   * each chance represents a possible outcome
   * failure is captured as { yieldage: 0, probability: P }
   */
  chances: BehaviorMeasuredGainYieldageChance[];

  /**
   * expected value = sum(yieldage * probability)
   * weighted sum of chances
   */
  expected: number;

  /**
   * transitive yieldage from unblocked behaviors
   * = sum of yieldage.expected from behaviors this one unblocks
   */
  transitive: number;
}

=>


interface BehaviorMeasuredGainYieldage {
  /**
   * ...
   */
  direct: {
    /**
    * possible yield outcomes with probabilities
    * each chance represents a possible outcome
    * failure is captured as { yieldage: 0, probability: P }
    */
    chances: BehaviorMeasuredGainYieldageChance[];

    /**
    * expected value = sum(yieldage * probability)
    * weighted sum of chances
    */
    expected: number;
  }

  /**
   * transitive yieldage from unblocked behaviors
   * = sum of yieldage.expected from behaviors this one unblocks
   */
  transitive: number;
}


---

# blocker.15

remove this for now. causes more confusion than solves utility


#### BehaviorWorkstreamBottleneck

cross-workstream blocking relationship.

```ts
interface BehaviorWorkstreamBottleneck {
  /**
   * workstream being blocked
   */
  blockedWorkstream: RefByUnique<typeof BehaviorWorkstream>;

  /**
   * workstream causing the block
   */
  blockingWorkstream: RefByUnique<typeof BehaviorWorkstream>;

  /**
   * specific behavior causing the block
   */
  blockingBehavior: RefByUnique<typeof Behavior>;

  /**
   * position in blocked workstream where block occurs
   */
  atPosition: number;
}

class BehaviorWorkstreamBottleneck extends DomainLiteral<BehaviorWorkstreamBottleneck> {}
```

---

# blocker.16

add example values into BehaviorDispatchConfig comments

also, use RefByUnique<typeof GitFile> for file paths, rather than just a string, where GitFile comes from rhachet-artifact-git

---

# blocker.17



interface BehaviorRemoteRepoConfig {
  url: string;
  prLabels: string[] | null;
  issueLabels: string[] | null;
}

prLabels and issueLabels are not configurable. stop increasing the config surface area without clear requirment.

instead, make it just { url: string }. also, its just a BehaviorSourceRepoRemote; not RemoteRepoConfig

---

# blocker.18

why are each of these different? why not all just leverage common `BehaviorTriagedUrgencyLevel` ?


type BehaviorTriagedReadinessLevel =
  | 'now'     // no blockers, ready to start
  | 'soon'    // minor blockers, ready soon
  | 'later'   // significant blockers
  | 'blocked' // hard blocked by dependency
  ;

type BehaviorTriagedBandwidthLevel =
  | 'now'   // within concurrency limit
  | 'soon'  // next in queue
  | 'later' // beyond current capacity
  ;

type BehaviorTriagedUrgencyLevel =
  | 'now'   // work on immediately
  | 'soon'  // queue for next
  | 'later' // backlog
  ;
