# domain research: dispatcher role

research on domain objects, operations, and relationships for the dispatcher role with `prioritize` and `coordinate` skills.

---

## 1. domain objects

### 1.1 entities (identity matters, lifecycle exists)

#### Behavior
the central entity representing a unit of work to be prioritized and coordinated.

- **attributes**: uuid, sourcePath, repoPath, status (active|paused|done), wish, vision, criteria
- **identity**: unique by sourcePath within a repo
- **lifecycle**: discovered → measured → triaged → coordinated → completed

> "In a Scrum project management application, there are four prominent Aggregates: Product, BacklogItem, Release, and Sprint." [1]

analogous to BacklogItem in domain-driven design literature.

#### Source
represents a location from which behaviors are gathered.

- **attributes**: uuid, type (local.dir|remote.repo|remote.org|remote.pr|remote.issue), path, lastFetchedAt, contentHash
- **identity**: unique by type + path combination
- **lifecycle**: configured → fetched → cached → invalidated

> "Reach is defined as the number of people a particular product initiative will affect within a specific period of time." [2]

sources define the reach of the dispatcher's scope.

#### Measurement
the scored assessment of a behavior against criteria.

- **attributes**: uuid, behaviorRef, yieldage, leverage, cost, dependencyRefs[], contentHash, measuredAt
- **identity**: unique by behaviorRef + contentHash (enables cache invalidation)
- **lifecycle**: pending → computed → cached → invalidated

> "The components that help calculate the Cost of Delay are: User Business Value, Time Criticality, and Risk Reduction/Opportunity Enablement Value." [3]

#### Stream
a parallel execution lane for coordinated work.

- **attributes**: uuid, number, behaviorsInOrder[], blockedOnStreamRef?, priority
- **identity**: unique by number within a coordination run
- **lifecycle**: created → active → blocked → unblocked → completed

> "A parallel schedule for a DAG, D, is a partition of V(D) into blocks A0, A1, ... such that when j < k, no vertex in Aj is reachable from any vertex in Ak." [4]

#### Dependency
represents a blocker relationship between behaviors.

- **attributes**: blockerBehaviorRef, blockedBehaviorRef, type (requires|enables)
- **identity**: unique by blockerRef + blockedRef pair
- **lifecycle**: declared → active → resolved

> "The types of dependencies most commonly found in project schedules include: Finish-to-start (a task cannot start until a previous task is completed)." [5]

---

### 1.2 events (temporal facts, immutable)

#### BehaviorDiscoveredEvent
emitted when a behavior is found during gather phase.

- **attributes**: behaviorRef, sourceRef, discoveredAt, docsParsed (wish|vision|criteria)

#### BehaviorMeasuredEvent
emitted when measurement completes for a behavior.

- **attributes**: behaviorRef, measurementRef, measuredAt, fromCache (boolean)

#### BehaviorTriagedEvent
emitted when a behavior is assigned to a bucket.

- **attributes**: behaviorRef, bucket (now|soon|later), triagedAt

#### StreamIntersectionEvent
emitted when streams converge on a shared dependency.

- **attributes**: streamRefs[], blockerBehaviorRef, detectedAt

> "When a backlog item is first created, there are zero contained tasks. Normally it is not until sprint planning that tasks are defined." [1]

events track the progression of behaviors through phases.

---

### 1.3 literals (value objects, identity via all properties)

#### YieldageScore
represents effective gain measurement.

- **attributes**: direct (number), dependent (number), total (number)
- **identity**: all attributes combined

> "Impact is an estimate of how much the project will contribute to the user's satisfaction, retention, or revenue. Impact is sometimes scored on the following scale: minimal (0.25), low (0.5), medium (1), high (2), or massive (3)." [2]

#### LeverageScore
represents efficiency gain measurement.

- **attributes**: costReduction (number), speedIncrease (number), maintenanceReduction (number), total (number)

> "In SAFe, WSJF is estimated as the relative cost of delay divided by the relative job duration." [3]

#### CostEstimate
represents multi-dimensional expenditure.

- **attributes**: time (number), money (number), trust (number), focus (number), skill (number), trade (number), repute (number), total (number)

> "Effort is estimated as a number of 'person-months' – the work that one team member can do in a month." [2]

#### PriorityLevel
represents urgency classification.

- **attributes**: level (p0|p1|p3|p5), label (critical|important|desired|bonus)

> "MoSCoW: M - Must have, S - Should have, C - Could have, W - Won't have." [6]

maps to our odd-numbered priority levels (p0=critical, p1=important, p3=desired, p5=bonus).

#### TriageBucket
represents time-horizon classification.

- **attributes**: bucket (now|soon|later)

> "Requirements labelled as Must have are critical to the current delivery timebox in order for it to be a success." [6]

#### DependencyGraph
represents the DAG of behavior dependencies.

- **attributes**: nodes (BehaviorRef[]), edges (Dependency[])

> "Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u→v, vertex u comes before v in the ordering." [4]

#### ContentHash
represents cache invalidation key.

- **attributes**: algorithm (sha256), value (string), computedAt (timestamp)

> "simple-on-disk-cache which only remeasures if content hash has changed on the input files for the behavior" - from wish.md

---

## 2. domain operations

### 2.1 gather operations (prioritize skill - phase 1)

| operation | input | output | description |
|-----------|-------|--------|-------------|
| `scanLocalSources` | Source[] | Behavior[] | discovers behaviors in local git repos |
| `scanRemoteSources` | Source[] | Behavior[] | discovers behaviors from remote repos/orgs/prs/issues |
| `parseBehaviorDocs` | behaviorPath | {wish, vision, criteria} | extracts behavior documentation |
| `filterCompletedBehaviors` | Behavior[] | Behavior[] | excludes behaviors with status=done |
| `computeContentHash` | filePaths[] | ContentHash | generates cache key from file contents |

> "The main idea is to perform a Depth First Search (DFS) on the Directed Acyclic Graph (DAG) and, for each vertex, push it onto a stack only after visiting all its adjacent vertices." [4]

gather uses DFS-like traversal of source directories.

### 2.2 measure operations (prioritize skill - phase 2)

| operation | input | output | description |
|-----------|-------|--------|-------------|
| `measureYieldage` | Behavior, criteria | YieldageScore | calculates effective gain (direct + dependent) |
| `measureLeverage` | Behavior, criteria | LeverageScore | calculates efficiency gain |
| `measureCost` | Behavior, criteria | CostEstimate | calculates multi-dimensional cost |
| `buildDependencyGraph` | Behavior[] | DependencyGraph | constructs DAG of dependencies |
| `computeDependentYieldage` | Behavior, DependencyGraph | number | sums yieldage of transitively unblocked behaviors |

> "RICE Score = (Reach * Impact * Confidence) / Effort" [2]

our formula: priority = (yieldage + leverage) / cost

> "The core concept of the Theory of Constraints is that every process has a single constraint and that total process throughput can only be improved when the constraint is improved." [7]

identifying high-leverage work aligns with TOC principles.

### 2.3 triage operations (prioritize skill - phase 3)

| operation | input | output | description |
|-----------|-------|--------|-------------|
| `assignTriageBucket` | Measurement | TriageBucket | determines now/soon/later based on scores |
| `sortByPriority` | Behavior[], Measurement[] | Behavior[] | orders by yieldage/leverage/cost ratio |
| `identifyBlockedBehaviors` | Behavior[], DependencyGraph | Behavior[] | finds behaviors with unresolved dependencies |
| `writePrioritizationOutput` | TriagedBehavior[] | {md, json} | renders human-readable and machine-usable output |

> "Backlogs are continuously prioritized based on a WSJF algorithm that uses relative user and business value, time criticality, risk reduction and/or opportunity enablement, and job size." [3]

### 2.4 coordinate operations (coordinate skill)

| operation | input | output | description |
|-----------|-------|--------|-------------|
| `groupIntoStreams` | TriagedBehavior[], DependencyGraph | Stream[] | partitions into parallel execution lanes |
| `assignPriorityLevel` | Behavior, DependencyGraph | PriorityLevel | determines p0/p1/p3/p5 based on blocker status |
| `identifyStreamIntersections` | Stream[] | StreamIntersectionEvent[] | finds convergence points |
| `orderStreamsByPriority` | Stream[] | Stream[] | ranks streams by highest-priority behavior |
| `estimateUnblockTime` | Stream, blockerBehaviorRef | timestamp? | predicts when blocker will resolve |
| `writeCoordinationOutput` | Stream[] | {md, json} | renders stream map and intersection points |

> "Look at the cumulative flow diagram of your board to identify where the horizontal bands widen—that's where queuing is most prevalent." [8]

> "Kahn's Algorithm is better for task scheduling & parallel execution." [4]

---

## 3. relationships

### 3.1 entity relationship diagram

```
Source (1)──────(*)→ Behavior
                      │
                      ├──(1)→ Measurement
                      │         ├── YieldageScore
                      │         ├── LeverageScore
                      │         └── CostEstimate
                      │
                      ├──(*)→ Dependency ←(*)── Behavior (blocker)
                      │
                      └──(*)→ Stream (membership)
                               └── PriorityLevel
```

### 3.2 phase data flow

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   GATHER    │───▸│   MEASURE   │───▸│   TRIAGE    │───▸│ COORDINATE  │
│  .gather/   │    │  .measure/  │    │  .triage/   │    │    output   │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
     │                   │                  │                  │
     ▼                   ▼                  ▼                  ▼
  Behavior[]       Measurement[]      TriagedBehavior[]    Stream[]
  Source[]         DependencyGraph    by bucket            with priorities
```

> "Queue states are one of the main components in a Kanban pull system." [8]

each phase output becomes the next phase's input queue.

### 3.3 dependency graph structure

```
     ┌──────┐
     │  A   │  (blocker - p0)
     └──┬───┘
        │
   ┌────┴────┐
   ▼         ▼
┌──────┐  ┌──────┐
│  B   │  │  C   │
└──┬───┘  └──┬───┘
   │         │
   ▼         ▼
┌──────┐  ┌──────┐
│  D   │  │  E   │
└──────┘  └──────┘

stream 1: A → B → D
stream 2: A → C → E
intersection: behavior A
```

> "The critical path is the longest chain of essential tasks that must finish on time for the project to be completed." [5]

---

## 4. composition: how domain supports the wish

### 4.1 prioritize skill composition

```
prioritize({source: rhachet.dispatch.yml, output: .dispatch/})
  │
  ├── GATHER PHASE
  │     ├── Source[] ← parseDispatchYml(source)
  │     ├── for each source:
  │     │     ├── checkCache(source.contentHash)
  │     │     └── if stale: scanSource(source) → Behavior[]
  │     └── filterCompletedBehaviors(behaviors)
  │
  ├── MEASURE PHASE
  │     ├── for each behavior (parallel, cached):
  │     │     ├── checkCache(behavior.contentHash)
  │     │     └── if stale: measureBehavior(behavior) → Measurement
  │     └── buildDependencyGraph(behaviors) → DependencyGraph
  │
  ├── TRIAGE PHASE
  │     ├── sortByPriority(behaviors, measurements)
  │     ├── assignTriageBuckets(behaviors) → {now[], soon[], later[]}
  │     └── writePrioritizationOutput() → {.triage/prioritization.md, .json}
  │
  └── OUTPUT
        ├── .dispatch/.gather/    (gathered behaviors)
        ├── .dispatch/.measure/   (measurements + dependency graph)
        └── .dispatch/.triage/    (triaged + sorted behaviors)
```

### 4.2 coordinate skill composition

```
coordinate({input: .dispatch/prioritization.json, output: .dispatch/})
  │
  ├── LOAD PHASE
  │     ├── TriagedBehavior[] ← loadPrioritization(input)
  │     └── DependencyGraph ← loadDependencyGraph(input)
  │
  ├── STREAM GROUPING
  │     ├── groupIntoStreams(now + soon behaviors) → Stream[]
  │     ├── for each stream:
  │     │     ├── orderBehaviorsByDependency(topological sort)
  │     │     └── assignPriorityLevels(behaviors)
  │     └── identifyStreamIntersections(streams) → intersections
  │
  ├── PRIORITY ORDERING
  │     ├── for each blocked stream:
  │     │     └── computeReviewPriority(yieldage × priority)
  │     └── orderStreamsByPriority(streams)
  │
  └── OUTPUT
        ├── .dispatch/coordination.md  (human-readable stream map)
        └── .dispatch/coordination.json (machine-usable)
```

> "If streams 3 and 2 are both ready for review (blocked on human), then which one to look at first?" - from wish.md

answered by: `orderStreamsByPriority(streams)` using yieldage × priority calculation.

---

## 5. citations

[1] Vernon, V. (2011). "Effective Aggregate Design Part III: Gaining Insight Through Discovery". [DDD Community](https://www.dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf)

[2] McBride, S. / Intercom. "RICE Prioritization Framework for Product Managers". [Intercom Blog](https://www.intercom.com/blog/rice-simple-prioritization-for-product-managers/)

[3] Scaled Agile, Inc. "WSJF - Weighted Shortest Job First". [Scaled Agile Framework](https://scaledagileframework.com/wsjf/)

[4] MIT OpenCourseWare. "Directed Acyclic Graphs (DAGs) & Scheduling: Chapter 9.5". [MIT 6.042J](https://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-spring-2015/mit6_042js15_session17.pdf)

[5] Atlassian. "Project dependencies". [Atlassian Agile](https://www.atlassian.com/agile/project-management/project-management-dependencies)

[6] Agile Business Consortium. "MoSCoW Prioritisation - DSDM Project Framework". [Agile Business](https://www.agilebusiness.org/dsdm-project-framework/moscow-prioririsation.html)

[7] Goldratt, E. / Lean Production. "Theory of Constraints (TOC)". [Lean Production](https://www.leanproduction.com/theory-of-constraints/)

[8] Nave. "The Top 3 Benefits of Introducing Queue States to Your System". [Nave Blog](https://getnave.com/blog/queue-states-in-kanban/)

[9] Wikipedia. "Topological sorting". [Wikipedia](https://en.wikipedia.org/wiki/Topological_sorting)

[10] ProductPlan. "RICE Scoring Model". [ProductPlan Glossary](https://www.productplan.com/glossary/rice-scoring-model/)

[11] Businessmap. "What Is the Cost of Delay?". [Businessmap](https://businessmap.io/lean-management/value-waste/cost-of-delay)

[12] Office Timeline. "Critical path method and task dependencies explained". [Office Timeline](https://www.officetimeline.com/project-management/critical-path)

[13] Atlassian. "DORA Metrics: How to measure Open DevOps Success". [Atlassian DevOps](https://www.atlassian.com/devops/frameworks/dora-metrics)

[14] Scrum.org. "4 Key Flow Metrics and How to Use Them in Scrum's Events". [Scrum.org](https://www.scrum.org/resources/blog/4-key-flow-metrics-and-how-use-them-scrums-events)

[15] Reinertsen, D. G. (2009). "The Principles of Product Development Flow: Second Generation Lean Product Development". [Amazon](https://www.amazon.com/Principles-Product-Development-Flow-Generation/dp/1935401009)

[16] Float. "What is Resource Leveling & How Does It Help Manage Project Constraints?". [Float Resources](https://www.float.com/resources/resource-leveling)

[17] Wikipedia. "Program evaluation and review technique". [Wikipedia PERT](https://en.wikipedia.org/wiki/Program_evaluation_and_review_technique)

[18] PMI. "Work Breakdown Structure (WBS) - Basic Principles". [PMI Learning Library](https://www.pmi.org/learning/library/work-breakdown-structure-basic-principles-4883)

[19] ProductPlan. "Opportunity Costs: A Crucial Prioritization Step". [ProductPlan Learn](https://www.productplan.com/learn/justify-opportunity-cost/)

[20] Eisenhower.me. "The Eisenhower Matrix: Introduction & 3-Minute Video Tutorial". [Eisenhower.me](https://www.eisenhower.me/eisenhower-matrix/)

[21] Untools. "Impact-Effort Matrix". [Untools](https://untools.co/impact-effort-matrix/)

[22] Scaled Agile, Inc. "Lean Portfolio Management". [Scaled Agile Framework](https://framework.scaledagile.com/lean-portfolio-management/)

[23] Wikipedia. "Dijkstra's algorithm". [Wikipedia Dijkstra](https://en.wikipedia.org/wiki/Dijkstra's_algorithm)

[24] Nave. "Boost Your Predictability: How to Manage Blocked Work in Kanban". [Nave Blog](https://getnave.com/blog/blocked-work-in-kanban/)

[25] DORA. "DORA's software delivery metrics: the four keys". [DORA.dev](https://dora.dev/guides/dora-metrics-four-keys/)

[26] Scaled Agile, Inc. "Domain Modeling - Extended Guidance". [Scaled Agile Framework](https://framework.scaledagile.com/domain-modeling)

[27] Wikipedia. "Bellman–Ford algorithm". [Wikipedia Bellman-Ford](https://en.wikipedia.org/wiki/Bellman–Ford_algorithm)

---

## 6. additional domain concepts from research

### 6.1 flow metrics (DORA & kanban)

> "Lead Time for Changes measures the amount of time it takes a commit to get into production." [13]

> "Throughput is the number of items finished per unit of time (per day, per week, per sprint and so on)." [14]

> "Work Item Age, or WIP Age, measures the total time that has elapsed since an item entered a workflow, specifically for items still in progress." [14]

these metrics apply directly to behavior lifecycle tracking:
- **lead time** = time from behavior discovery to completion
- **cycle time** = time from measurement to triage
- **throughput** = behaviors completed per time period
- **work item age** = how long a behavior has been in "now" bucket

### 6.2 queuing theory (reinertsen)

> "Reinertsen carefully explains why invisible and unmanaged queues are the underlying root cause of poor product development performance." [15]

> "According to Reinertsen's Principles of Product Development Flow, queues profoundly affect the economics of product development. They cause valuable work products to sit idle, waiting to access busy resources." [15]

key principles for dispatcher:
- **queue visualization** = .gather/, .measure/, .triage/ are explicit queues
- **wip limits** = limit behaviors in "now" bucket to match reviewer capacity
- **batch size reduction** = smaller behaviors flow faster through the system

### 6.3 resource-constrained scheduling (RCPSP)

> "The Resource Constrained Project Scheduling Problem (RCPSP) was introduced by Kelley to produce a schedule that optimizes management objectives while satisfying activity tightness and resource constraints." [16]

> "The resource-constrained scheduling problem is a complex combinatorial one and includes several activity and resource input parameters as well as constraints that need to be met." [16]

dispatcher addresses RCPSP where:
- **resource** = human reviewer time (today's constraint per vision.md)
- **activities** = behaviors in dependency graph
- **objective** = maximize throughput under constraint

### 6.4 probabilistic estimation (PERT)

> "The expected duration of each task is calculated using the PERT formula: (O + 4M + P) / 6." [17]

> "PERT defines four types of time required to accomplish an activity: Optimistic time, Pessimistic time, Most likely time, Expected time." [17]

applicable to cost estimation:
- cost.time could use PERT-style three-point estimation
- provides confidence intervals for prioritization

### 6.5 work breakdown structure (WBS)

> "The Project Management Institute (PMI) PMBOK defines the Work Breakdown Structure as a 'deliverable oriented hierarchical decomposition of the work to be executed by the project team.'" [18]

> "The 100% rule states that the WBS includes 100% of the work defined by the project scope and captures all deliverables." [18]

behaviors are analogous to WBS work packages:
- behaviors = terminal elements (work packages)
- .behavior/ directories = hierarchical decomposition
- gather phase enforces 100% rule (all behaviors discovered)

### 6.6 opportunity cost economics

> "Opportunity cost represents the value of the next best alternative foregone when making a business decision." [19]

> "CD3 (Cost of Delay Divided by Duration) addresses this question by combining urgency (CoD) with effort (duration) to maximize economic returns." [19]

our prioritization formula aligns:
- **yieldage** ≈ cost of delay (value lost per unit time)
- **cost** ≈ duration/effort
- **priority** ≈ CD3 score

### 6.7 urgency vs importance (eisenhower)

> "The Eisenhower Matrix helps you decide on and prioritize tasks by urgency and importance, sorting out less urgent and important tasks which you should either delegate or not do at all." [20]

> "Research shows an interesting quirk called the 'mere urgency effect' - we tend to handle urgent tasks over the most important ones even when they give us less reward." [20]

triage buckets encode both dimensions:
| bucket | urgency | importance |
|--------|---------|------------|
| now | high | high (Q1: do) |
| soon | low | high (Q2: schedule) |
| later | varies | lower (Q3/Q4) |

### 6.8 impact-effort matrix

> "The Impact-Effort Matrix is a powerful decision-making tool that helps you prioritize based on their potential impact and the effort required to complete them." [21]

> "Quick Wins (High Impact, Low Effort): These tasks are your quick wins. They're actions that impact your customers significantly and don't require a lot of work from you." [21]

maps directly to triage:
| quadrant | yieldage | cost | bucket |
|----------|----------|------|--------|
| quick wins | high | low | now |
| big bets | high | high | soon |
| fill-ins | low | low | later |
| time sinks | low | high | (excluded) |

### 6.9 portfolio management (SAFe LPM)

> "Lean Portfolio Management (LPM) aligns strategy and execution by applying Lean and systems thinking approaches to strategy and investment funding, Agile portfolio operations, and governance." [22]

> "Epics are the key drivers to realize the Portfolio Vision. They represent large-scale, value-delivering work items that encapsulate strategic initiatives." [22]

behaviors are analogous to epics:
- behaviors = epics with explicit wish/vision/criteria
- sources = portfolios (org, repo collections)
- dispatcher = lean portfolio kanban

### 6.10 shortest path algorithms

> "Dijkstra's algorithm is one of the SSSP (Single Source Shortest Path) algorithms. It calculates the shortest path from a source node to all the nodes inside the graph." [23]

> "The Bellman–Ford algorithm is capable of handling graphs in which some of the edge weights are negative numbers." [23]

applicable to critical path calculation:
- dependency graph = weighted DAG
- edge weights = behavior cost estimates
- critical path = longest path through dependencies

---

## 7. key insights from research

### 7.1 yieldage aligns with "cost of delay"
> "Cost of Delay helps you understand and quantify the impact of time on outcomes." [11]

yieldage captures the effective gain that would be delayed if behavior is not completed.

### 7.2 leverage aligns with "enabling value"
> "Risk Reduction/Opportunity Enablement Value focuses on the amount of risk that can be reduced with the delivery of the feature." [3]

leverage captures the efficiency gain that makes future work faster/cheaper.

### 7.3 triage buckets align with MoSCoW
| our bucket | MoSCoW equivalent | definition |
|------------|-------------------|------------|
| now | Must have | critical to current timebox |
| soon | Should have | important but not time-critical |
| later | Could have / Won't have | desirable but deferrable |

### 7.4 streams align with parallel scheduling theory
> "The maximum number of elements scheduled at any step is called the number of processors required by the schedule." [4]

streams = parallel processors; resource constraints = number of available human reviewers.

### 7.5 priority levels align with urgency classification
| our level | semantic | TOC alignment |
|-----------|----------|---------------|
| p0 | critical blocker | "the constraint" - everything depends on this |
| p1 | required work | immediate subordination to p0 |
| p3 | desired work | can proceed in parallel |
| p5 | bonus work | only if capacity permits |

### 7.6 cache invalidation via content hash
> "simple-on-disk-cache which only remeasures if content hash has changed" - from wish.md

aligns with standard build system cache invalidation patterns (make, gradle, etc).

---

## 8. open questions for blueprint phase

1. **measurement criteria format**: how should explicit measurement criteria be declared in rhachet.dispatch.yml?

2. **brain.repl invocation boundary**: which measurement decisions require probabilistic inference vs deterministic calculation?

3. **remote source authentication**: how to handle private repos, orgs with SSO, etc?

4. **pr/issue behavior synthesis**: how to convert issue body to behavior wish format?

5. **cross-repo dependencies**: how to express dependencies between behaviors in different repos?

6. **cache storage location**: global cache vs per-output-dir cache?

7. **parallelism configuration**: how many concurrent measurements? configurable per resource type?
