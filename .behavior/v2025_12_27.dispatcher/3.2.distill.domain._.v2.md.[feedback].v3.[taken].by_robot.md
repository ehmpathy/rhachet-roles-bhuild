# feedback response: domain distillation v2 → v3

## checklist

- [x] blocker.1: update user story format to `@[dispatcher]` ✓ verified
- [x] blocker.2: remove interface declarations for boundary types, use inline types ✓ verified
- [x] blocker.3: fix terminology consistency (gain=leverage+yieldage, cost=attend+expend) ✓ verified
- [x] blocker.4: add priority basket counts to measureBehavior stats ✓ verified
- [x] blocker.5: lookup with-simple-cache and update contracts for automatic cache key ✓ verified
- [x] blocker.6: BehaviorGathered use paths + contentHash, not embedded file contents ✓ verified
- [x] blocker.7: update BehaviorGathered unique to [behavior, contentHash] ✓ verified
- [x] nitpick.8: move metadata timestamps closer to top of domain objects ✓ verified
- [x] blocker.9: decompose gain/cost into separate domain objects (BehaviorMeasuredGain, BehaviorMeasuredCost) ✓ verified
- [x] blocker.10: BehaviorWorkstream id→slug, rank→BehaviorWorkstreamRank type ✓ verified
- [x] blocker.11: BehaviorWorkstreamEntry → BehaviorWorkstreamDeliverable ✓ verified
- [x] blocker.12: use GitFile from rhachet-artifact-git instead of custom BehaviorFile ✓ verified
- [x] blocker.13: nest direct vs transitive in BehaviorMeasuredGainLeverage ✓ verified + fixed implementation
- [x] blocker.14: nest direct vs transitive in BehaviorMeasuredGainYieldage ✓ verified + fixed implementation
- [x] blocker.15: remove BehaviorWorkstreamBottleneck (causes confusion) ✓ verified
- [x] blocker.16: add example values to BehaviorDispatchConfig, use RefByUnique<typeof GitFile> ✓ verified
- [x] blocker.17: simplify BehaviorRemoteRepoConfig → BehaviorSourceRepoRemote { url: string } ✓ verified
- [x] blocker.18: unify ReadinessLevel/BandwidthLevel to use common BehaviorTriagedUrgencyLevel ✓ verified
- [x] cleanup.19: remove `access/daos/` section (no longer needed with withSimpleCacheOnDisk) ✓ verified
- [x] cleanup.20: add `cacheDir` to BehaviorDispatchContext ✓ verified
- [x] cleanup.21: remove `blocked` from BehaviorTriagedUrgencyLevel (not a valid option) ✓ verified
- [x] cleanup.22: improve @example comments with explanations of what values mean ✓ verified
- [x] cleanup.23: operation names follow `getOneBehavior*` pattern (not `*BehaviorOne`) ✓ verified
- [x] cleanup.24: triageBehavior result uses `gathered` reference (not `behavior`+`contentHash`) ✓ fixed

---

## response plan

### blocker.1: user story format
change all user stories from "as a dispatcher skill" to "as a @[dispatcher]"

### blocker.2: inline types for boundary contracts
remove interface declarations like `interface BehaviorGatherResult` and use inline return types:
```ts
gatherBehavior(...) => Promise<{
  behaviors: BehaviorGathered[];
  stats: {...};
}>
```

### blocker.3: terminology consistency
update user story in usecase 1.5 from:
- "score behaviors by yieldage, leverage, and cost"
to:
- "score behaviors by gain (leverage, yieldage) and cost (attend, expend)"

### blocker.4: measureBehavior stats
add priority basket counts:
```ts
stats: {
  all: number;
  p0: number;
  p1: number;
  p3: number;
  p5: number;
}
```

### blocker.5: with-simple-cache
research shows with-simple-cache automatically computes cache keys via `serialize()` when wrapped. update dao contracts to show this pattern.

### blocker.6: BehaviorGathered structure
remove embedded file contents. use:
- `files: RefByUnique<typeof GitFile>[]` for file paths
- `contentHash: string` for cache invalidation
no need for massive variables in memory.

### blocker.7: BehaviorGathered unique key
change from `unique = ['behavior']` to `unique = ['behavior', 'contentHash']`
this allows multiple gathered versions over time for same behavior.
downstream entities can use `RefByUnique<typeof BehaviorGathered>` instead of embedding contentHash.

### nitpick.8: timestamp positioning
move `gatheredAt`, `deptracedAt`, `measuredAt`, `triagedAt` closer to top of each domain object interface.

### blocker.9: decompose gain/cost
create separate domain objects:
- `BehaviorMeasuredGain` with dimensions + composite
- `BehaviorMeasuredCost` with dimensions + composite

### blocker.10: BehaviorWorkstream changes
- `id: string` → `slug: string`
- `rank: number` → `rank: BehaviorWorkstreamRank`
- add type: `type BehaviorWorkstreamRank = \`r${number}\``

### blocker.11: rename workstream entry
- `BehaviorWorkstreamEntry` → `BehaviorWorkstreamDeliverable`

### blocker.12: use GitFile
remove custom BehaviorFile, use GitFile from rhachet-artifact-git:
```ts
import { GitFile } from 'rhachet-artifact-git';
// GitFile has: { uri: string; ... }
```

### blocker.13-14: nest direct/transitive
structure leverage and yieldage as:
```ts
{
  direct: { author, support, composite } | { chances, expected },
  transitive: number,
}
```

### blocker.15: remove bottleneck
delete BehaviorWorkstreamBottleneck and all references. causes more confusion than utility.

### blocker.16: config examples
add inline examples to BehaviorDispatchConfig comments. use `RefByUnique<typeof GitFile>` for file paths.

### blocker.17: simplify remote config
- rename `BehaviorRemoteRepoConfig` → `BehaviorSourceRepoRemote`
- simplify to just `{ url: string }` (remove prLabels, issueLabels)

### blocker.18: unify urgency levels
use single `BehaviorTriagedUrgencyLevel = 'now' | 'soon' | 'later'` for all:
- readiness: now | soon | later (no 'blocked' - that's not a valid urgency level)
- bandwidth: now | soon | later
- decision: min(readiness, bandwidth)

### cleanup.23: operation naming
operation names follow `getOneBehavior*` pattern:
- `getOneBehaviorDeptraced` (not `deptraceBehaviorOne`)
- `getOneBehaviorMeasured` (not `measureBehaviorOne`)

### cleanup.24: triageBehavior result structure
result uses `gathered: RefByUnique<typeof BehaviorGathered>` instead of separate `behavior`/`contentHash` fields to match the BehaviorTriaged interface.

---

## appendix: getOne/getAll operation naming plan

### analysis: what is the grain of each operation?

| skill | operation signature | internally calls |
|-------|---------------------|------------------|
| gather | `getAllBehaviorGathered({ by: { sources } })` | `getAllBehaviorGathered({ by: { local } })`, `getAllBehaviorGathered({ by: { remote } })` |
| gather | `getAllBehaviorGathered({ by: { local } })` | — |
| gather | `getAllBehaviorGathered({ by: { remote } })` | — |
| gather | `getOneBehaviorGathered({ by: { unique } })` | — (cache lookup) |
| deptrace | `getOneBehaviorDeptraced({ by: { unique } })` | `getOneBehaviorGathered` |
| measure | `getOneBehaviorMeasured({ by: { unique } })` | `getOneBehaviorGathered`, `getOneBehaviorDeptraced` |
| triage | `getAllBehaviorTriaged({ over: { behaviors } })` | `getOneBehaviorMeasured` |
| coordinate | `getAllBehaviorWorkstream({ over: { behaviors } })` | `getAllBehaviorTriaged` |

### reasoning

1. **gather**: polymorphic by source type
   - `getAllBehaviorGathered({ by: { sources: BehaviorDispatchConfig['sources'] } })`
     - iterates local + remote, returns all gathered
   - `getAllBehaviorGathered({ by: { local: { repos: RefByUnique<typeof GitDir>[] } } })`
     - enumerates `.behavior/*/` in each local repo
   - `getAllBehaviorGathered({ by: { remote: { repos: BehaviorSourceRepoRemote[] } } })`
     - clones/fetches remote repos, enumerates `.behavior/*/`
   - `getOneBehaviorGathered({ by: { unique: RefByUnique<typeof BehaviorGathered> } })`
     - looks up ONE gathered by its unique key
     - **cache-critical**: wrapped with `withSimpleCacheOnDisk`; ref includes contentHash so unchanged behaviors skip evaluation entirely
     - if not cached: check if contentHash matches current/latest at source
       - if matches latest → fetch fresh, cache, return
       - if not latest → failfast (can't retrieve old uncached versions)

2. **deptrace**: lookup/compute ONE deptraced by its unique key
   - `getOneBehaviorDeptraced({ by: { unique: RefByUnique<typeof BehaviorGathered> } })`
   - BehaviorDeptraced.unique = ['gathered']
   - internally calls `getOneBehaviorGathered` to hydrate gathered entity
   - **cache-critical**: wrapped with `withSimpleCacheOnDisk`; ref includes contentHash so unchanged behaviors skip evaluation entirely

3. **measure**: lookup/compute ONE measured by its unique key
   - `getOneBehaviorMeasured({ by: { unique: RefByUnique<typeof BehaviorGathered> } })`
   - BehaviorMeasured.unique = ['gathered']
   - internally calls `getOneBehaviorGathered` to hydrate gathered
   - internally calls `getOneBehaviorDeptraced` to get deps
   - **cache-critical**: wrapped with `withSimpleCacheOnDisk`; ref includes contentHash so unchanged behaviors skip evaluation entirely

4. **triage**: operates on ALL measured behaviors (collective state)
   - `getAllBehaviorTriaged({ over: { behaviors: RefByUnique<typeof BehaviorGathered>[] }, config })`
   - internally calls `getOneBehaviorMeasured` for each
   - **cache-critical**: wrapped with `withSimpleCacheOnDisk`; refs include contentHashes so unchanged behavior set skips evaluation entirely

5. **coordinate**: operates on ALL triaged behaviors to form workstreams
   - `getAllBehaviorWorkstream({ over: { behaviors: RefByUnique<typeof BehaviorGathered>[] } })`
   - internally calls `getAllBehaviorTriaged` if needed
   - **cache-critical**: wrapped with `withSimpleCacheOnDisk`; refs include contentHashes so unchanged behavior set skips evaluation entirely

### changes required

- [ ] blocker.25: replace `gatherBehavior` with polymorphic `getAllBehaviorGathered`
  - `getAllBehaviorGathered({ by: { sources } })` - from all configured sources
  - `getAllBehaviorGathered({ by: { local } })` - from local repos only
  - `getAllBehaviorGathered({ by: { remote } })` - from remote repos only

- [ ] blocker.26: add `getOneBehaviorGathered({ by: { unique } })`
  - input = `{ by: { unique: RefByUnique<typeof BehaviorGathered> } }`
  - cached on disk for downstream operations to call

- [ ] blocker.27: update `getOneBehaviorDeptraced({ by: { unique } })`
  - input = `{ by: { unique: RefByUnique<typeof BehaviorGathered> } }`
  - internally calls `getOneBehaviorGathered` to hydrate gathered entity
  - cached on disk

- [ ] blocker.28: update `getOneBehaviorMeasured({ by: { unique } })`
  - input = `{ by: { unique: RefByUnique<typeof BehaviorGathered> } }`
  - internally calls `getOneBehaviorGathered` and `getOneBehaviorDeptraced`
  - cached on disk

- [ ] blocker.29: replace `triageBehavior` + `getOneBehaviorTriaged` → `getAllBehaviorTriaged({ over: { behaviors }, config })`
  - input = `{ over: { behaviors: RefByUnique<typeof BehaviorGathered>[] }, config }`
  - internally calls `getOneBehaviorMeasured` for each
  - handles sorting, nowCount, readiness internally
  - **cache-critical**: refs include contentHashes so unchanged behavior set skips evaluation

- [ ] blocker.30: add `getAllBehaviorWorkstream({ over: { behaviors } })`
  - input = `{ over: { behaviors: RefByUnique<typeof BehaviorGathered>[] } }`
  - internally calls `getAllBehaviorTriaged` if needed
  - **cache-critical**: refs include contentHashes so unchanged behavior set skips evaluation

- [ ] blocker.31: update directory structure in section 3 to reflect new operation names

- [ ] blocker.32: update caching examples in section 4 to show the `{ by: { unique } }` pattern

- [ ] blocker.33: remove `deptraceBehavior` and `measureBehavior` as separate skills
  - they become internal to the getOne* operations
  - pipeline simplifies to: gather → measure (calls deptrace) → triage → coordinate

- [ ] blocker.34: wrap cacheable operations with `withSimpleCacheOnDisk`
  - `getOneBehaviorGathered`, `getOneBehaviorDeptraced`, `getOneBehaviorMeasured`
  - cache key derived from `RefByUnique<typeof BehaviorGathered>` (includes contentHash)
  - if ref unchanged → cache hit → no evaluation needed
  - this is why refs are critical: they include contentHash for cache invalidation
  - each operation must include a header comment calling out cache behavior:
    ```ts
    /**
     * .what = retrieves or computes measured behavior by gathered ref
     * .why = scoring behaviors requires deps and content analysis
     * .note = cache-critical: wrapped with withSimpleCacheOnDisk; ref includes
     *         contentHash so unchanged behaviors skip evaluation entirely
     */
    const getOneBehaviorMeasured = withSimpleCacheOnDisk(
      async (input: { by: { unique: RefByUnique<typeof BehaviorGathered> } }) => { ... },
      { dir: context.cacheDir }
    );
    ```
