# implementation blueprint: dispatcher role v1

this document declares the implementation plan for the dispatcher role, enabling prioritization and coordination of behaviors across repositories.

---

## 1. implementation phases

### phase 0: brief research
research knowledge domains relevant to dispatcher skills per scope.2 criteria:

**research topics**:
- behavior prioritization
  - leverage measurement (time savings multipliers)
  - yieldage measurement (value realization, probabilistic outcomes)
  - cost estimation (attend: complexity √ó time, expend: direct costs)
  - priority assignment (effect = gain - cost, priority levels p0/p1/p3/p5)
- behavior coordination
  - workstream grouping (dependency chains, parallel execution)
  - workstream ranking (by priority, by effect)
  - urgency levels (now/soon/later, readiness vs bandwidth)
- cache invalidation
  - content hashing for cache keys
  - cache-critical operation patterns

**research deliverables**:
- brief files with appropriate format tags ([article], [catalog], [demo], [lesson], [seed])
- citations for all claims per usecase.2.2
- format tags determined by content type per usecase.2.3:
  - [article] = curated external knowledge with citations
  - [catalog] = enumerated options or patterns
  - [demo] = worked examples
  - [lesson] = distilled learnings from experience
  - [seed] = original definitions created for this domain

**note**: brief file names and format tags will be finalized after research phase completes. the briefs directory structure will be:
```
briefs/
  practices/
    behavior.prioritization/
      # files determined after research
    behavior.coordination/
      # files determined after research
```

### phase 1: foundation
- domain objects (types, validation, serialization)
- shared utilities (content hash, file ops)
- context types and config loading

### phase 2: gather skill
- `getAllBehaviorGathered` operations
- local repo scanning
- remote repo fetching (optional, phase 1.5)
- `.gathered/` output structure

### phase 3: deptrace skill
- `getOneBehaviorDeptraced` operations
- dependency parsing from criteria
- transitive closure computation
- `.gathered/latest/` resolution

### phase 4: measure skill
- `getOneBehaviorMeasured` operations
- gain computation (leverage + yieldage)
- cost computation (attend + expend)
- priority assignment

### phase 5: triage skill
- `getAllBehaviorTriaged` operations
- readiness computation
- bandwidth computation
- decision = min(readiness, bandwidth)

### phase 6: coordinate skill
- `getAllBehaviorCoordinated` operations
- workstream grouping
- workstream ranking
- bottleneck detection

### phase 7: composite skills
- `getAllBehaviorPrioritized` contract (gather ‚Üí deptrace ‚Üí measure ‚Üí triage)
- output archiving
- CLI rendering

---

## 2. directory structure

```
src/
  domain.roles/
    dispatcher/
      getDispatcherRole.ts                    # Role.build({ slug: 'dispatcher', ... })
      getDispatcherRole.test.ts               # unit: role construction
      briefs/
        practices/
          behavior.prioritization/
            # brief files determined after phase 0 research
            # format tags ([article], [catalog], [demo], [lesson], [seed])
            # assigned based on content type per usecase.2.3
          behavior.coordination/
            # brief files determined after phase 0 research
      skills/
        gather.sh                             # invokes contract/cli/getAllBehaviorGathered.ts
        deptrace.sh                           # invokes contract/cli/getOneBehaviorDeptraced.ts
        measure.sh                            # invokes contract/cli/getOneBehaviorMeasured.ts
        triage.sh                             # invokes contract/cli/getAllBehaviorTriaged.ts
        prioritize.sh                         # invokes contract/cli/getAllBehaviorPrioritized.ts
        coordinate.sh                         # invokes contract/cli/getAllBehaviorCoordinated.ts

  domain.objects/
    Behavior.ts                               # root entity
    BehaviorGathered.ts                       # gathered state
    BehaviorDeptraced.ts                      # dependency-traced state
    BehaviorMeasured.ts                       # scored state
    BehaviorTriaged.ts                        # urgency-assigned state
    BehaviorWorkstream.ts                     # workstream grouping
    BehaviorMeasuredGain.ts                   # composite gain
    BehaviorMeasuredCost.ts                   # composite cost
    BehaviorMeasuredGainLeverage.ts           # leverage dimension
    BehaviorMeasuredGainYieldage.ts           # yieldage dimension
    BehaviorMeasuredGainYieldageChance.ts     # probabilistic outcome
    BehaviorMeasuredCostAttend.ts             # attend dimension
    BehaviorMeasuredCostExpend.ts             # expend dimension
    BehaviorWorkstreamDeliverable.ts          # behavior in workstream
    BehaviorDispatchConfig.ts                 # config literal
    BehaviorDispatchContext.ts                # context type
    BehaviorSourceRepoRemote.ts               # remote source config
    # enums as string literal types (not separate files)

  domain.operations/
    behavior/
      dispatch/
        findsertBehaviorDispatchDir.ts          # idempotent dir init
        findsertBehaviorDispatchDir.test.ts
        archiveBehaviorIfChanged.ts             # archive prior outputs
        archiveBehaviorIfChanged.test.ts
        genBehaviorDispatchContext.ts           # context factory
        genBehaviorDispatchContext.test.ts

        gather/
          getAllBehaviorGathered.ts               # polymorphic: by sources, local, remote
          getAllBehaviorGathered.test.ts          # unit tests
          getAllBehaviorGathered.integration.test.ts  # integration tests
          getOneBehaviorGathered.ts               # single lookup (cache-critical)
          getOneBehaviorGathered.test.ts
          enumBehaviorDirs.ts                     # find .behavior/*/ directories
          enumBehaviorDirs.test.ts
          parseBehaviorDir.ts                     # parse behavior directory
          parseBehaviorDir.test.ts
          computeBehaviorGatheredContentHash.ts   # sha256 hash
          computeBehaviorGatheredContentHash.test.ts
          loadBehaviorDispatchConfig.ts           # parse rhachet.dispatch.yml
          loadBehaviorDispatchConfig.test.ts

        deptrace/
          getOneBehaviorDeptraced.ts              # single deptrace (cache-critical)
          getOneBehaviorDeptraced.test.ts
          getOneBehaviorDeptraced.integration.test.ts
          parseBehaviorDeptracedDependencies.ts   # extract depends_on
          parseBehaviorDeptracedDependencies.test.ts
          computeBehaviorDeptracedTransitiveDeps.ts  # transitive closure
          computeBehaviorDeptracedTransitiveDeps.test.ts
          renderBehaviorDeptracedDependenciesMd.ts   # render dependencies.md
          renderBehaviorDeptracedDependenciesMd.test.ts

        measure/
          getOneBehaviorMeasured.ts               # single measure (cache-critical)
          getOneBehaviorMeasured.test.ts
          getOneBehaviorMeasured.integration.test.ts
          computeBehaviorMeasuredGainLeverage.ts  # leverage dimension
          computeBehaviorMeasuredGainLeverage.test.ts
          computeBehaviorMeasuredGainYieldage.ts  # yieldage dimension
          computeBehaviorMeasuredGainYieldage.test.ts
          computeBehaviorMeasuredGainComposite.ts # gain(+$)
          computeBehaviorMeasuredGainComposite.test.ts
          computeBehaviorMeasuredCostAttend.ts    # attend dimension
          computeBehaviorMeasuredCostAttend.test.ts
          computeBehaviorMeasuredCostExpend.ts    # expend dimension
          computeBehaviorMeasuredCostExpend.test.ts
          computeBehaviorMeasuredCostComposite.ts # cost(-$)
          computeBehaviorMeasuredCostComposite.test.ts
          computeBehaviorMeasuredReverseDeps.ts   # invert dependency graph
          computeBehaviorMeasuredReverseDeps.test.ts
          assignBehaviorMeasuredPriority.ts       # effect ‚Üí priority level
          assignBehaviorMeasuredPriority.test.ts

        triage/
          getAllBehaviorTriaged.ts                # collective triage (cache-critical)
          getAllBehaviorTriaged.test.ts
          getAllBehaviorTriaged.integration.test.ts
          computeBehaviorTriagedReadiness.ts      # readiness dimension
          computeBehaviorTriagedReadiness.test.ts
          computeBehaviorTriagedBandwidth.ts      # bandwidth dimension
          computeBehaviorTriagedBandwidth.test.ts
          renderBehaviorTriagedPrioritizationMd.ts   # render prioritization.md
          renderBehaviorTriagedPrioritizationMd.test.ts

        prioritize/
          getAllBehaviorPrioritized.ts            # composite (cache-critical)
          getAllBehaviorPrioritized.test.ts
          getAllBehaviorPrioritized.integration.test.ts

        coordinate/
          getAllBehaviorCoordinated.ts            # collective coordination (cache-critical)
          getAllBehaviorCoordinated.test.ts
          getAllBehaviorCoordinated.integration.test.ts
          groupBehaviorWorkstreams.ts             # cluster into workstreams
          groupBehaviorWorkstreams.test.ts
          rankBehaviorWorkstreams.ts              # assign ranks
          rankBehaviorWorkstreams.test.ts
          renderBehaviorWorkstreamCoordinationMd.ts  # render coordination.md
          renderBehaviorWorkstreamCoordinationMd.test.ts

  contract/
    cli/
      getAllBehaviorGathered.ts               # contract.cli: gather skill
      getAllBehaviorGathered.acceptance.test.ts
      getOneBehaviorDeptraced.ts              # contract.cli: deptrace skill
      getOneBehaviorDeptraced.acceptance.test.ts
      getOneBehaviorMeasured.ts               # contract.cli: measure skill
      getOneBehaviorMeasured.acceptance.test.ts
      getAllBehaviorTriaged.ts                # contract.cli: triage skill
      getAllBehaviorTriaged.acceptance.test.ts
      getAllBehaviorPrioritized.ts            # contract.cli: prioritize skill
      getAllBehaviorPrioritized.acceptance.test.ts
      getAllBehaviorCoordinated.ts            # contract.cli: coordinate skill
      getAllBehaviorCoordinated.acceptance.test.ts
```

---

## 3. domain objects implementation

### 3.1 entity implementation pattern

each entity follows the `domain-objects` pattern:

```ts
// src/domain.objects/BehaviorGathered.ts
import { DomainEntity, RefByUnique } from 'domain-objects';
import { Behavior } from './Behavior';

/**
 * .what = represents a behavior after collection from source repositories
 * .why = provides versioned snapshot with contentHash for cache invalidation
 */
interface BehaviorGathered {
  gatheredAt: string;
  behavior: RefByUnique<typeof Behavior>;
  contentHash: string;
  status: BehaviorGatheredStatus;
  files: RefByUnique<typeof GitFile>[];
  wish: string | null;
  vision: string | null;
  criteria: string | null;
}

class BehaviorGathered
  extends DomainEntity<BehaviorGathered>
  implements BehaviorGathered
{
  public static primary = ['behavior', 'contentHash'] as const;
  public static unique = ['behavior', 'contentHash'] as const;
}

export { BehaviorGathered };
```

### 3.2 literal implementation pattern

```ts
// src/domain.objects/BehaviorMeasuredGain.ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = composite gain measurement
 * .why = combines leverage (time) and yieldage (cash) into absolute value
 */
interface BehaviorMeasuredGain {
  dimensions: {
    leverage: BehaviorMeasuredGainLeverage;
    yieldage: BehaviorMeasuredGainYieldage;
  };
  composite: number;
}

class BehaviorMeasuredGain
  extends DomainLiteral<BehaviorMeasuredGain>
  implements BehaviorMeasuredGain
{
  public static nested = {
    dimensions: DomainLiteral,
  };
}

export { BehaviorMeasuredGain };
```

### 3.3 enum types (as string literals)

```ts
// src/domain.objects/BehaviorGathered.ts (inline)
export type BehaviorGatheredStatus =
  | 'wish'
  | 'vision'
  | 'criteria'
  | 'active'
  | 'review'
  | 'delivered';

export type BehaviorMeasuredPriorityLevel = 'p0' | 'p1' | 'p3' | 'p5';

export type BehaviorTriagedUrgencyLevel = 'now' | 'soon' | 'later';

export type BehaviorWorkstreamRank = `r${number}`;
```

---

## 4. domain operations implementation

### 4.1 cache-critical pattern

the following operations are cache-critical and wrapped with `withSimpleCacheOnDisk`:

| operation | cache key | rationale |
|-----------|-----------|-----------|
| `getOneBehaviorGathered` | `RefByUnique<BehaviorGathered>` | contentHash invalidates on file change |
| `getOneBehaviorDeptraced` | `RefByUnique<BehaviorGathered>` | deps derived from gathered content |
| `getOneBehaviorMeasured` | `RefByUnique<BehaviorGathered>` | scores derived from gathered + deps |
| `getAllBehaviorTriaged` | `RefByUnique<BehaviorGathered>[]` | collective state from all measured |
| `getAllBehaviorPrioritized` | `RefByUnique<BehaviorGathered>[]` | composite of triage + outputs |
| `getAllBehaviorCoordinated` | `RefByUnique<BehaviorGathered>[]` | workstreams from prioritized |

**note**: `getAllBehaviorGathered` is NOT cached - it scans sources and computes the contentHashes that enable caching for all downstream operations. it must always run fresh to detect changes.

all cached operations use the private/public pattern:

```ts
// src/domain.operations/behavior/dispatch/gather/getOneBehaviorGathered.ts
const _getOneBehaviorGathered = async (
  input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
  context: BehaviorDispatchContext,
): Promise<BehaviorGathered> => {
  // lookup gathered.json from .gathered/latest/{org}/{repo}/{name}/
  // if contentHash matches input ref ‚Üí return hydrated BehaviorGathered
  // if contentHash differs ‚Üí failfast (stale ref, must re-gather)
};

export const getOneBehaviorGathered = withSimpleCacheOnDisk(
  _getOneBehaviorGathered,
  { procedure: { name: 'getOneBehaviorGathered', version: 'v1' }, ... },
);

// test boundaries:
// - unit: _getOneBehaviorGathered (mock fs, test lookup logic)
// - integration: getOneBehaviorGathered (real fs, test cache hit/miss)
//   - [case] contentHash matches ‚Üí returns hydrated entity
//   - [case] contentHash differs ‚Üí failfast with clear error
//   - [case] behavior not in .gathered/latest/ ‚Üí failfast
//   - [case] cache hit ‚Üí skips file read
```

```ts
// src/domain.operations/behavior/dispatch/deptrace/getOneBehaviorDeptraced.ts
const _getOneBehaviorDeptraced = async (
  input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
  context: BehaviorDispatchContext,
): Promise<BehaviorDeptraced> => {
  // hydrate gathered via getOneBehaviorGathered
  // parse depends_on from criteria file
  // resolve each dep against .gathered/latest/ ‚Üí failfast if missing
  // compute transitive closure of dependencies
  // return BehaviorDeptraced with direct + transitive deps
};

export const getOneBehaviorDeptraced = withSimpleCacheOnDisk(
  _getOneBehaviorDeptraced,
  { procedure: { name: 'getOneBehaviorDeptraced', version: 'v1' }, ... },
);

// test boundaries:
// - unit: _getOneBehaviorDeptraced (mock getOneBehaviorGathered, test dep parsing)
// - integration: getOneBehaviorDeptraced (real fs, test full pipeline)
//   - [case] no dependencies ‚Üí empty arrays
//   - [case] direct deps only ‚Üí populated direct, empty transitive
//   - [case] transitive deps ‚Üí both arrays populated
//   - [case] missing dependency ‚Üí failfast with behavior names in error (blocker.37)
//   - [case] circular dependency ‚Üí detected and reported
//   - [case] cache hit ‚Üí skips computation
```

```ts
// src/domain.operations/behavior/dispatch/measure/getOneBehaviorMeasured.ts
const _getOneBehaviorMeasured = async (
  input: { by: { unique: RefByUnique<typeof BehaviorGathered> } },
  context: BehaviorDispatchContext,
): Promise<BehaviorMeasured> => {
  // hydrate gathered via getOneBehaviorGathered
  // hydrate deptraced via getOneBehaviorDeptraced
  // compute gain.leverage (direct + transitive time savings)
  // compute gain.yieldage (direct + transitive value)
  // compute cost.attend (complexity √ó time)
  // compute cost.expend (direct costs)
  // compute effect = gain.composite - cost.composite
  // assign priority level (p0/p1/p3/p5) based on effect
  // return BehaviorMeasured with all dimensions
};

export const getOneBehaviorMeasured = withSimpleCacheOnDisk(
  _getOneBehaviorMeasured,
  { procedure: { name: 'getOneBehaviorMeasured', version: 'v1' }, ... },
);

// test boundaries:
// - unit: _getOneBehaviorMeasured (mock upstream, test scoring formulas)
// - unit: computeBehaviorMeasuredGainLeverage (isolated formula tests)
// - unit: computeBehaviorMeasuredGainYieldage (isolated formula tests)
// - unit: computeBehaviorMeasuredCostAttend (isolated formula tests)
// - unit: computeBehaviorMeasuredCostExpend (isolated formula tests)
// - unit: assignBehaviorMeasuredPriority (threshold tests)
// - integration: getOneBehaviorMeasured (real fs, test full pipeline)
//   - [case] high effect ‚Üí p0 assignment
//   - [case] low effect ‚Üí p5 assignment
//   - [case] transitive deps boost leverage
//   - [case] cache hit ‚Üí skips computation
```

```ts
// src/domain.operations/behavior/dispatch/triage/getAllBehaviorTriaged.ts
const _getAllBehaviorTriaged = async (
  input: { over: { behaviors: RefByUnique<typeof BehaviorGathered>[] }; config: BehaviorDispatchConfig },
  context: BehaviorDispatchContext,
): Promise<{ behaviors: BehaviorTriaged[]; stats: { ... } }> => {
  // for each behavior ref ‚Üí getOneBehaviorMeasured
  // compute readiness for each (unblocked=now, 1-hop=soon, 2+-hop=later)
  // compute bandwidth for each (based on config.constraints.maxConcurrency)
  // decision = min(readiness, bandwidth)
  // sort by priority level, then by effect
  // return triaged behaviors with stats (counts by bucket)
};

export const getAllBehaviorTriaged = withSimpleCacheOnDisk(
  _getAllBehaviorTriaged,
  { procedure: { name: 'getAllBehaviorTriaged', version: 'v1' }, ... },
);

// test boundaries:
// - unit: _getAllBehaviorTriaged (mock getOneBehaviorMeasured, test triage logic)
// - unit: computeBehaviorTriagedReadiness (hop distance tests)
// - unit: computeBehaviorTriagedBandwidth (capacity limit tests)
// - integration: getAllBehaviorTriaged (real fs, test collective behavior)
//   - [case] unblocked behavior ‚Üí decision=now
//   - [case] blocked by 1 hop ‚Üí decision=soon
//   - [case] blocked by 2+ hops ‚Üí decision=later
//   - [case] bandwidth exceeded ‚Üí demoted to soon/later
//   - [case] empty input ‚Üí empty output with zero stats
//   - [case] cache hit on unchanged refs ‚Üí skips computation
```

```ts
// src/domain.operations/behavior/dispatch/prioritize/getAllBehaviorPrioritized.ts
const _getAllBehaviorPrioritized = async (
  input: { over: { behaviors: RefByUnique<typeof BehaviorGathered>[] }; config: BehaviorDispatchConfig },
  context: BehaviorDispatchContext,
): Promise<{ behaviors: BehaviorTriaged[]; outputs: { ... } }> => {
  // call getAllBehaviorTriaged
  // render prioritization.md (human-readable sorted list)
  // render prioritization.json (machine-readable)
  // render dependencies.md (dependency graph visualization)
  // archive prior outputs if changed
  // return triaged behaviors + output paths
};

export const getAllBehaviorPrioritized = withSimpleCacheOnDisk(
  _getAllBehaviorPrioritized,
  { procedure: { name: 'getAllBehaviorPrioritized', version: 'v1' }, ... },
);

// test boundaries:
// - unit: _getAllBehaviorPrioritized (mock getAllBehaviorTriaged, test rendering)
// - unit: renderBehaviorTriagedPrioritizationMd (output format tests)
// - integration: getAllBehaviorPrioritized (real fs, test file outputs)
//   - [case] outputs written to correct paths
//   - [case] md contains all behaviors sorted by priority
//   - [case] json is valid and parseable
//   - [case] dependencies.md shows graph structure
//   - [case] archive created on change
//   - [case] idempotent on unchanged input
// - acceptance: contract/cli/getAllBehaviorPrioritized
//   - [case] full pipeline from config ‚Üí outputs
//   - [case] CLI renders with nature emojis
```

```ts
// src/domain.operations/behavior/dispatch/coordinate/getAllBehaviorCoordinated.ts
const _getAllBehaviorCoordinated = async (
  input: { over: { behaviors: RefByUnique<typeof BehaviorGathered>[] }; config: BehaviorDispatchConfig },
  context: BehaviorDispatchContext,
): Promise<{ workstreams: BehaviorWorkstream[]; outputs: { ... } }> => {
  // call getAllBehaviorTriaged (or reuse from prioritized)
  // group behaviors into workstreams by dependency chains
  // rank workstreams by highest-priority behavior in each
  // render coordination.md (workstream map with deliverables)
  // render coordination.json (machine-readable)
  // archive prior outputs if changed
  // return workstreams + output paths
};

export const getAllBehaviorCoordinated = withSimpleCacheOnDisk(
  _getAllBehaviorCoordinated,
  { procedure: { name: 'getAllBehaviorCoordinated', version: 'v1' }, ... },
);

// test boundaries:
// - unit: _getAllBehaviorCoordinated (mock getAllBehaviorTriaged, test grouping)
// - unit: groupBehaviorWorkstreams (dependency chain clustering)
// - unit: rankBehaviorWorkstreams (priority-based ranking)
// - integration: getAllBehaviorCoordinated (real fs, test file outputs)
//   - [case] independent behaviors ‚Üí separate workstreams
//   - [case] dependent chain ‚Üí single workstream with order
//   - [case] diamond deps ‚Üí correctly merged
//   - [case] workstreams ranked by highest priority
//   - [case] outputs written correctly
//   - [case] idempotent on unchanged input
// - acceptance: contract/cli/getAllBehaviorCoordinated
//   - [case] full pipeline from config ‚Üí outputs
//   - [case] CLI renders with nature emojis
```

### 4.2 contract vs operation separation

**contract.cli** (in `contract/cli/`) are user-facing, agnostic of contentHash:

```ts
// src/contract/cli/getAllBehaviorPrioritized.ts
import { RefByUnique } from 'domain-objects';

import { BehaviorGathered } from '../../domain.objects/BehaviorGathered';
import { loadBehaviorDispatchConfig } from '../../domain.operations/behavior/dispatch/loadBehaviorDispatchConfig';
import { genBehaviorDispatchContext } from '../../domain.operations/behavior/dispatch/genBehaviorDispatchContext';
import { getAllBehaviorGathered } from '../../domain.operations/behavior/dispatch/gather/getAllBehaviorGathered';
import { getAllBehaviorPrioritized as getAllBehaviorPrioritizedOp } from '../../domain.operations/behavior/dispatch/prioritize/getAllBehaviorPrioritized';

/**
 * .what = contract.cli for prioritize skill - gathers then prioritizes
 * .why = user-facing entry point that handles gather + versioned operation
 */
const main = async () => {
  // load config
  const configPath = process.argv.includes('--config')
    ? process.argv[process.argv.indexOf('--config') + 1]
    : './rhachet.dispatch.yml';
  const config = await loadBehaviorDispatchConfig({ path: configPath });

  // generate context
  const context = await genBehaviorDispatchContext({ config });

  // gather latest refs (agnostic of prior contentHash)
  const { behaviors: gathered } = await getAllBehaviorGathered(
    { by: { sources: config.sources } },
    context,
  );

  // convert to refs for downstream operation
  const refs = gathered.map((g) =>
    RefByUnique.as<typeof BehaviorGathered>({
      behavior: g.behavior,
      contentHash: g.contentHash,
    }),
  );

  // call operation with versioned refs (enables caching)
  const result = await getAllBehaviorPrioritizedOp(
    { over: { behaviors: refs }, config },
    context,
  );

  // render CLI output
  console.log('ü¶´ prioritize');
  console.log(`‚îú‚îÄ üå≤ gathered ${gathered.length} behaviors`);
  console.log(`‚îú‚îÄ üèïÔ∏è triaged by urgency`);
  for (const behavior of result.behaviors) {
    console.log(`‚îÇ  ‚îî‚îÄ [${behavior.decision}] ${behavior.gathered.behavior.name}`);
  }
  console.log('');
  console.log('üåä output');
  console.log(`‚îú‚îÄ ${result.outputs.prioritizationMd}`);
  console.log(`‚îú‚îÄ ${result.outputs.prioritizationJson}`);
  console.log(`‚îî‚îÄ ${result.outputs.dependenciesMd}`);
};

main();
```

**operations** (in `domain.operations/`) take versioned refs:

```ts
// src/domain.operations/behavior/dispatch/prioritize/getAllBehaviorPrioritized.ts

const _getAllBehaviorPrioritized = async (
  input: {
    over: { behaviors: RefByUnique<typeof BehaviorGathered>[] };
    config: BehaviorDispatchConfig;
  },
  context: BehaviorDispatchContext,
): Promise<{ behaviors: BehaviorTriaged[]; outputs: { ... } }> => {
  // ... implementation
};

export const getAllBehaviorPrioritized = withSimpleCacheOnDisk(
  _getAllBehaviorPrioritized,
  { procedure: { name: 'getAllBehaviorPrioritized', version: 'v1' }, ... },
);
```

---

## 5. skill implementation

### 5.1 shell wrapper pattern

skill .sh files invoke contract/cli directly:

```bash
#!/usr/bin/env bash
######################################################################
# .what = gather behaviors from configured sources
# .why  = collects behaviors for downstream prioritization
#
# usage:
#   gather.sh                          # use ./rhachet.dispatch.yml
#   gather.sh --config path/to/config  # use custom config
######################################################################
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"
npx tsx "$REPO_ROOT/src/contract/cli/getAllBehaviorGathered.ts" "$@"
```

```bash
#!/usr/bin/env bash
######################################################################
# .what = prioritize behaviors by effect and urgency
# .why  = produces prioritization.md with sorted behaviors
######################################################################
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"
npx tsx "$REPO_ROOT/src/contract/cli/getAllBehaviorPrioritized.ts" "$@"
```

```bash
#!/usr/bin/env bash
######################################################################
# .what = coordinate behaviors into workstreams
# .why  = produces coordination.md with ranked workstreams
######################################################################
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"
npx tsx "$REPO_ROOT/src/contract/cli/getAllBehaviorCoordinated.ts" "$@"
```

---

## 6. testing strategy

### 6.1 test hierarchy

```
unit tests        ‚Üí isolated logic, mocked dependencies, fast
integration tests ‚Üí real dependencies, real file system, no mocks
acceptance tests  ‚Üí black-box contract tests, CLI invocation
```

### 6.2 unit tests (per atomic operation)

each operation file has a collocated `.test.ts` file:

```ts
// src/domain.operations/behavior/computeBehaviorGatheredContentHash.test.ts
import { given, when, then } from 'test-fns';
import { computeBehaviorGatheredContentHash } from './computeBehaviorGatheredContentHash';

describe('computeBehaviorGatheredContentHash', () => {
  given('[case1] a behavior directory with multiple files', () => {
    const mockContext = {
      // mock file system
      enumFilesRecursive: jest.fn().mockResolvedValue(['a.md', 'b.md']),
      readFile: jest.fn()
        .mockResolvedValueOnce('content a')
        .mockResolvedValueOnce('content b'),
    };

    when('[t0] hash is computed', () => {
      then('hash is deterministic for same content', async () => {
        const hash1 = await computeBehaviorGatheredContentHash(
          { dir: '/path/to/behavior' },
          mockContext,
        );
        const hash2 = await computeBehaviorGatheredContentHash(
          { dir: '/path/to/behavior' },
          mockContext,
        );
        expect(hash1).toEqual(hash2);
      });

      then('hash changes when content changes', async () => {
        const hash1 = await computeBehaviorGatheredContentHash(
          { dir: '/path/to/behavior' },
          mockContext,
        );
        mockContext.readFile.mockResolvedValueOnce('content a modified');
        const hash2 = await computeBehaviorGatheredContentHash(
          { dir: '/path/to/behavior' },
          mockContext,
        );
        expect(hash1).not.toEqual(hash2);
      });
    });
  });

  given('[case2] files in different order', () => {
    when('[t0] hash is computed', () => {
      then('hash is same regardless of enumeration order', async () => {
        // ... test deterministic ordering
      });
    });
  });
});
```

**unit test coverage requirements**:

| operation | test cases |
|-----------|-----------|
| `computeBehaviorGatheredContentHash` | determinism, content change detection, file ordering |
| `parseBehaviorDeptracedDependencies` | no deps, single dep, multiple deps, malformed input |
| `computeBehaviorDeptracedTransitiveDeps` | linear chain, diamond deps, no deps, circular deps |
| `computeBehaviorMeasuredGainLeverage` | direct leverage, transitive leverage, zero leverage |
| `computeBehaviorMeasuredGainYieldage` | deterministic yield, probabilistic yield, zero yield |
| `computeBehaviorMeasuredGainComposite` | time-to-cash conversion, sum of dimensions |
| `computeBehaviorMeasuredCostAttend` | hours √ó complexity |
| `computeBehaviorMeasuredCostExpend` | direct + indirect |
| `computeBehaviorMeasuredCostComposite` | time-to-cash conversion, sum of dimensions |
| `computeBehaviorMeasuredReverseDeps` | graph inversion, no deps, all deps |
| `assignBehaviorMeasuredPriority` | p0/p1/p3/p5 thresholds |
| `computeBehaviorTriagedReadiness` | unblocked=now, 1-hop=soon, 2+-hop=later, paused=later |
| `computeBehaviorTriagedBandwidth` | capacity limits, overflow behavior |
| `groupBehaviorWorkstreams` | independent behaviors, dependent chains |
| `rankBehaviorWorkstreams` | priority-based ranking, effect tie-breaking |
| `findsertBehaviorDispatchDir` | creates if missing, idempotent if exists |
| `archiveBehaviorIfChanged` | archives on change, skips if unchanged |

### 6.3 integration tests (per boundary)

integration tests verify real file system operations:

```ts
// src/domain.operations/behavior/getOneBehaviorDeptraced.integration.test.ts
import { given, when, then, useBeforeAll } from 'test-fns';
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';

describe('getOneBehaviorDeptraced', () => {
  const testDir = useBeforeAll(async () => {
    const dir = path.join(os.tmpdir(), `deptrace-test-${Date.now()}`);
    await fs.mkdir(dir, { recursive: true });
    return dir;
  });
  afterAll(async () => fs.rm(testDir, { recursive: true, force: true }));

  given('[case1] behavior A depends on behavior B', () => {
    const scene = useBeforeAll(async () => {
      // create .gathered/latest/ structure
      const gatheredDir = path.join(testDir, '.gathered/latest');
      await fs.mkdir(path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-a'), { recursive: true });
      await fs.mkdir(path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-b'), { recursive: true });

      // write behavior A with dependency on B
      await fs.writeFile(
        path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-a/2.criteria.md'),
        'depends_on: v2025_01_01.feature-b',
      );

      // write .gathered.json for A
      await fs.writeFile(
        path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-a/.gathered.json'),
        JSON.stringify({ behavior: { org: 'myorg', repo: 'myrepo', name: 'v2025_01_01.feature-a' }, contentHash: 'abc123' }),
      );

      return { gatheredDir };
    });

    when('[t0] deptrace is computed for A', () => {
      then('A.dependsOnDirect includes B', async () => {
        const context = await genBehaviorDispatchContext({
          config: { output: testDir },
        });
        const result = await getOneBehaviorDeptraced(
          { by: { unique: { behavior: { org: 'myorg', repo: 'myrepo', name: 'v2025_01_01.feature-a' }, contentHash: 'abc123' } } },
          context,
        );
        expect(result.dependsOnDirect).toContainEqual({
          org: 'myorg',
          repo: 'myrepo',
          name: 'v2025_01_01.feature-b',
        });
      });
    });
  });

  given('[case2] behavior A depends on non-existent behavior C', () => {
    const scene = useBeforeAll(async () => {
      // create only A, not C
      const gatheredDir = path.join(testDir, '.gathered/latest');
      await fs.mkdir(path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-a-bad'), { recursive: true });

      await fs.writeFile(
        path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-a-bad/2.criteria.md'),
        'depends_on: v2025_01_01.feature-c-missing',
      );

      await fs.writeFile(
        path.join(gatheredDir, 'myorg/myrepo/v2025_01_01.feature-a-bad/.gathered.json'),
        JSON.stringify({ behavior: { org: 'myorg', repo: 'myrepo', name: 'v2025_01_01.feature-a-bad' }, contentHash: 'def456' }),
      );

      return { gatheredDir };
    });

    when('[t0] deptrace is computed for A', () => {
      then('operation fails fast with clear error', async () => {
        const context = await genBehaviorDispatchContext({
          config: { output: testDir },
        });
        await expect(
          getOneBehaviorDeptraced(
            { by: { unique: { behavior: { org: 'myorg', repo: 'myrepo', name: 'v2025_01_01.feature-a-bad' }, contentHash: 'def456' } } },
            context,
          ),
        ).rejects.toThrow(/dependency not found in .gathered\/latest\//);
      });

      then('error message includes missing behavior name', async () => {
        const context = await genBehaviorDispatchContext({
          config: { output: testDir },
        });
        const error = await getError(
          getOneBehaviorDeptraced(
            { by: { unique: { behavior: { org: 'myorg', repo: 'myrepo', name: 'v2025_01_01.feature-a-bad' }, contentHash: 'def456' } } },
            context,
          ),
        );
        expect(error.message).toContain('v2025_01_01.feature-c-missing');
      });

      then('error message includes dependent behavior name', async () => {
        const context = await genBehaviorDispatchContext({
          config: { output: testDir },
        });
        const error = await getError(
          getOneBehaviorDeptraced(
            { by: { unique: { behavior: { org: 'myorg', repo: 'myrepo', name: 'v2025_01_01.feature-a-bad' }, contentHash: 'def456' } } },
            context,
          ),
        );
        expect(error.message).toContain('v2025_01_01.feature-a-bad');
      });
    });
  });
});
```

**integration test coverage requirements**:

| boundary | test cases |
|----------|-----------|
| `getAllBehaviorGathered` | local repo scanning, file copying, contentHash computation |
| `getOneBehaviorGathered` | cache hit, cache miss, stale contentHash |
| `getOneBehaviorDeptraced` | dependency resolution, missing dep failfast (blocker.37), transitive computation |
| `getOneBehaviorMeasured` | full measurement pipeline, cache interaction |
| `getAllBehaviorTriaged` | collective triage, sorting, bandwidth limits |
| `getAllBehaviorPrioritized` | end-to-end pipeline, output file creation |
| `getAllBehaviorCoordinated` | workstream grouping, ranking, output files |
| `loadBehaviorDispatchConfig` | valid YAML, invalid YAML, missing file |
| `findsertBehaviorDispatchDir` | creates structure, idempotent |
| `archiveBehaviorIfChanged` | archives changed, skips unchanged |

### 6.4 acceptance tests (per caller interface)

acceptance tests are black-box tests against the contract layer:

```ts
// src/contract/cli/getAllBehaviorPrioritized.acceptance.test.ts
import { given, when, then, useBeforeAll } from 'test-fns';
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { getAllBehaviorPrioritized } from './getAllBehaviorPrioritized';

describe('getAllBehaviorPrioritized', () => {
  const testDir = useBeforeAll(async () => {
    const dir = path.join(os.tmpdir(), `prioritize-acpt-${Date.now()}`);
    await fs.mkdir(dir, { recursive: true });
    return dir;
  });
  afterAll(async () => fs.rm(testDir, { recursive: true, force: true }));

  given('[case1] rhachet.dispatch.yml with local repo containing behaviors', () => {
    const scene = useBeforeAll(async () => {
      // setup test repo with .behavior/ directories
      const repoDir = path.join(testDir, 'test-repo');
      await fs.mkdir(path.join(repoDir, '.git'), { recursive: true });
      await fs.mkdir(path.join(repoDir, '.behavior/v2025_01_01.feature-a'), { recursive: true });
      await fs.mkdir(path.join(repoDir, '.behavior/v2025_01_01.feature-b'), { recursive: true });

      // write behavior content
      await fs.writeFile(
        path.join(repoDir, '.behavior/v2025_01_01.feature-a/0.wish.md'),
        '# wish\nadd feature A',
      );
      await fs.writeFile(
        path.join(repoDir, '.behavior/v2025_01_01.feature-b/0.wish.md'),
        '# wish\nadd feature B',
      );

      // write config
      const config = {
        output: path.join(testDir, '.dispatch'),
        sources: {
          local: { repos: [{ uri: repoDir }] },
          remote: null,
        },
        criteria: {
          gain: { leverage: { weights: { author: 1.0, support: 0.5 } } },
          convert: { equate: { cash: { dollars: 150 }, time: { hours: 1 } } },
        },
        constraints: { maxConcurrency: 3 },
      };

      return { repoDir, config };
    });

    when('[t0] prioritize is invoked', () => {
      then('behaviors are gathered', async () => {
        const result = await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        expect(result.behaviors.length).toBeGreaterThan(0);
      });

      then('behaviors are triaged with urgency', async () => {
        const result = await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        for (const behavior of result.behaviors) {
          expect(['now', 'soon', 'later']).toContain(behavior.decision);
        }
      });

      then('prioritization.md is written', async () => {
        await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        const prioritizationMd = await fs.readFile(
          path.join(scene.config.output, 'prioritization.md'),
          'utf-8',
        );
        expect(prioritizationMd).toContain('v2025_01_01.feature-a');
      });

      then('prioritization.json is written', async () => {
        await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        const prioritizationJson = await fs.readFile(
          path.join(scene.config.output, 'prioritization.json'),
          'utf-8',
        );
        const data = JSON.parse(prioritizationJson);
        expect(Array.isArray(data)).toBe(true);
      });

      then('dependencies.md is written', async () => {
        await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        const dependenciesMd = await fs.readFile(
          path.join(scene.config.output, 'dependencies.md'),
          'utf-8',
        );
        expect(dependenciesMd).toContain('dependencies');
      });
    });

    when('[t1] prioritize is invoked again with unchanged sources', () => {
      then('output is identical (idempotent)', async () => {
        const result1 = await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        const result2 = await getAllBehaviorPrioritized(
          { by: scene.config },
          { log: console },
        );
        expect(result1.outputs.prioritizationMd).toEqual(result2.outputs.prioritizationMd);
      });
    });
  });

  given('[case2] rhachet.dispatch.yml does not exist', () => {
    when('[t0] prioritize is invoked', () => {
      then('fails fast with clear error', async () => {
        await expect(
          getAllBehaviorPrioritized(
            { by: { output: '/nonexistent' } as any },
            { log: console },
          ),
        ).rejects.toThrow();
      });
    });
  });
});
```

**acceptance test coverage requirements**:

| contract | test cases |
|----------|-----------|
| `getAllBehaviorGathered` | valid config, missing config, empty sources |
| `getAllBehaviorPrioritized` | full pipeline, output files created, idempotent |
| `getAllBehaviorCoordinated` | workstream output, coordination files created |
| CLI invocation | `npx rhachet run --skill prioritize`, exit codes |

### 6.5 critical test scenarios (must-have coverage)

these scenarios are explicitly called out in criteria as requiring test coverage:

| scenario | test type | criteria reference |
|----------|-----------|-------------------|
| behavior depends on behavior not yet gathered | integration | scope.4 usecase.4.10 / blocker.37 |
| error message includes behavior names | integration | scope.4 usecase.4.10 |
| circular dependency detection | unit + integration | scope.4 usecase.4.7 |
| cache hit on unchanged contentHash | integration | scope.12 usecase.12.2 |
| idempotent output for all skills | acceptance | scope.9 usecase.9.7 |
| archive on change, skip on unchanged | integration | scope.7 usecase.7.3 |

### 6.6 test execution commands

```bash
# unit tests only
npm run test:unit -- dispatcher

# integration tests (requires file system)
npm run test:integration -- dispatcher

# acceptance tests (black-box)
npm run test:acceptance -- dispatcher

# all tests with coverage
npm run test -- dispatcher --coverage

# specific test file
npm run test:integration -- getOneBehaviorDeptraced.integration.test.ts
```

---

## 7. implementation order

### 7.1 phase 0: brief research (per scope.2 criteria)

1. identify knowledge domains relevant to dispatcher skills (usecase.2.1)
   - prioritization concepts: leverage, yieldage, cost, effect, priority levels
   - coordination concepts: workstreams, ranking, urgency levels
   - caching concepts: content hash, cache invalidation
2. research industry best practices with citations (usecase.2.2)
   - reference: `3.1.research.domain._.v1.i1.md` for citation pattern
   - minimum: 3+ citations per major concept
   - sources: academic papers, industry frameworks (SAFe, RICE, WSJF)
3. create brief files with appropriate format tags (usecase.2.3)
   - [seed] = original definitions created for this domain (e.g., our specific leverage formula)
   - [article] = curated external knowledge with citations (e.g., industry prioritization frameworks)
   - [lesson] = distilled learnings from implementation experience
   - [demo] = worked examples showing patterns in action

### 7.2 phase 1: foundation (no tests yet)

1. create directory structure
2. implement domain objects (entities + literals)
3. implement `BehaviorDispatchConfig` and context types

### 7.3 phase 2: gather (test-driven)

1. **unit tests first**: `computeBehaviorGatheredContentHash.test.ts`
2. **implement**: `computeBehaviorGatheredContentHash.ts`
3. **unit tests**: `enumBehaviorDirs.test.ts`
4. **implement**: `enumBehaviorDirs.ts`
5. **unit tests**: `parseBehaviorDir.test.ts`
6. **implement**: `parseBehaviorDir.ts`
7. **integration tests**: `getAllBehaviorGathered.integration.test.ts`
8. **implement**: `getAllBehaviorGathered.ts`
9. **acceptance tests**: `getAllBehaviorGathered.acceptance.test.ts`
10. **implement contract.cli**: `contract/cli/getAllBehaviorGathered.ts`

### 7.4 phase 3: deptrace (test-driven)

1. **unit tests**: `parseBehaviorDeptracedDependencies.test.ts`
2. **implement**: `parseBehaviorDeptracedDependencies.ts`
3. **unit tests**: `computeBehaviorDeptracedTransitiveDeps.test.ts`
4. **implement**: `computeBehaviorDeptracedTransitiveDeps.ts`
5. **integration tests**: `getOneBehaviorDeptraced.integration.test.ts` (including blocker.37 failfast)
6. **implement**: `getOneBehaviorDeptraced.ts`
7. **unit tests**: `renderBehaviorDeptracedDependenciesMd.test.ts`
8. **implement**: `renderBehaviorDeptracedDependenciesMd.ts`

### 7.5 phase 4: measure (test-driven)

1. **unit tests**: `computeBehaviorMeasuredGainLeverage.test.ts`
2. **implement**: `computeBehaviorMeasuredGainLeverage.ts`
3. **unit tests**: `computeBehaviorMeasuredGainYieldage.test.ts`
4. **implement**: `computeBehaviorMeasuredGainYieldage.ts`
5. **unit tests**: `computeBehaviorMeasuredGainComposite.test.ts`
6. **implement**: `computeBehaviorMeasuredGainComposite.ts`
7. **unit tests**: `computeBehaviorMeasuredCostAttend.test.ts`
8. **implement**: `computeBehaviorMeasuredCostAttend.ts`
9. **unit tests**: `computeBehaviorMeasuredCostExpend.test.ts`
10. **implement**: `computeBehaviorMeasuredCostExpend.ts`
11. **unit tests**: `computeBehaviorMeasuredCostComposite.test.ts`
12. **implement**: `computeBehaviorMeasuredCostComposite.ts`
13. **unit tests**: `computeBehaviorMeasuredReverseDeps.test.ts`
14. **implement**: `computeBehaviorMeasuredReverseDeps.ts`
15. **unit tests**: `assignBehaviorMeasuredPriority.test.ts`
16. **implement**: `assignBehaviorMeasuredPriority.ts`
17. **integration tests**: `getOneBehaviorMeasured.integration.test.ts`
18. **implement**: `getOneBehaviorMeasured.ts`

### 7.6 phase 5: triage (test-driven)

1. **unit tests**: `computeBehaviorTriagedReadiness.test.ts`
2. **implement**: `computeBehaviorTriagedReadiness.ts`
3. **unit tests**: `computeBehaviorTriagedBandwidth.test.ts`
4. **implement**: `computeBehaviorTriagedBandwidth.ts`
5. **integration tests**: `getAllBehaviorTriaged.integration.test.ts`
6. **implement**: `getAllBehaviorTriaged.ts`
7. **unit tests**: `renderBehaviorTriagedPrioritizationMd.test.ts`
8. **implement**: `renderBehaviorTriagedPrioritizationMd.ts`

### 7.7 phase 6: coordinate (test-driven)

1. **unit tests**: `groupBehaviorWorkstreams.test.ts`
2. **implement**: `groupBehaviorWorkstreams.ts`
3. **unit tests**: `rankBehaviorWorkstreams.test.ts`
4. **implement**: `rankBehaviorWorkstreams.ts`
5. **integration tests**: `getAllBehaviorCoordinated.integration.test.ts`
6. **implement**: `getAllBehaviorCoordinated.ts`
7. **unit tests**: `renderBehaviorWorkstreamCoordinationMd.test.ts`
8. **implement**: `renderBehaviorWorkstreamCoordinationMd.ts`
9. **acceptance tests**: `getAllBehaviorCoordinated.acceptance.test.ts`
10. **implement contract.cli**: `contract/cli/getAllBehaviorCoordinated.ts`

### 7.8 phase 7: composite + role (test-driven)

1. **unit tests**: `archiveBehaviorIfChanged.test.ts`
2. **implement**: `archiveBehaviorIfChanged.ts`
3. **integration tests**: `getAllBehaviorPrioritized.integration.test.ts`
4. **implement**: `getAllBehaviorPrioritized.ts`
5. **acceptance tests**: `getAllBehaviorPrioritized.acceptance.test.ts`
6. **implement contract.cli**: `contract/cli/getAllBehaviorPrioritized.ts`
7. **unit tests**: `getDispatcherRole.test.ts`
8. **implement**: `getDispatcherRole.ts`
9. **implement skills**: shell wrappers invoking contract/cli

---

## 8. dependencies

### 8.1 external packages

```json
{
  "dependencies": {
    "domain-objects": "^x.x.x",
    "with-simple-cache": "^x.x.x",
    "simple-on-disk-cache": "^x.x.x",
    "helpful-errors": "^x.x.x",
    "rhachet-artifact-git": "^x.x.x",
    "yaml": "^x.x.x",
    "zod": "^x.x.x"
  },
  "devDependencies": {
    "test-fns": "^x.x.x"
  }
}
```

### 8.2 internal dependencies

- `rhachet-artifact-git` for `GitFile`, `GitDir` types
- existing role infrastructure from `behaver` role patterns

---

## 9. risk areas

### 9.1 high risk: brain.repl integration for measure

- leverage and yieldage scoring require AI judgment
- risk: inconsistent or expensive inference
- mitigation: aggressive caching via contentHash

### 9.2 medium risk: transitive dependency computation

- risk: cycles, large graphs, performance
- mitigation: detect cycles early, memoize traversal

### 9.3 medium risk: remote repo fetching

- risk: network failures, auth issues, rate limits
- mitigation: defer to phase 1.5, local-only MVP first

### 9.4 low risk: file system operations

- risk: permissions, disk space
- mitigation: fail fast with clear errors

---

## 10. success metrics

- [ ] brief research phase complete (scope.2 criteria)
  - [ ] knowledge domains identified (usecase.2.1)
  - [ ] citations included for all claims (usecase.2.2)
  - [ ] format tags assigned based on content type (usecase.2.3)
- [ ] all unit tests pass
- [ ] all integration tests pass
- [ ] all acceptance tests pass
- [ ] blocker.37 (missing dep failfast) has test coverage
- [ ] cache reduces re-execution time by >80% on unchanged inputs
- [ ] idempotent output for all skills
- [ ] CLI renders with nature emojis (ü¶´, üå≤, üèïÔ∏è, üåä)
