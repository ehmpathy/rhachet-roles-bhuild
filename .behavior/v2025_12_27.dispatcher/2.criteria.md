# depth.terms = vocabulary and definitions


## scope.1 = ubiquitous language

### usecase.1.1 = measurement terms

given('dispatcher role terminology')
  when('measurement terms are used')
    then('"yieldage" is used for effective gain (direct + dependent/transitive)')
      sothat('effective gain has one canonical term')
    then('"leverage" is used for efficiency gain (reduced cost, faster delivery, lower maintenance)')
      sothat('efficiency gain has one canonical term')
    then('"cost" is used for resource expenditure (multi-dimensional: time, money, trust, focus, skill, trade, repute, etc)')
      sothat('resource expenditure has one canonical term')

given('terminology appears in skill outputs')
  when('prioritization or coordination is rendered')
    then('yieldage, leverage, and cost labels are used in scores')
      sothat('output terms match input terms')
    then('no synonyms (impact, value, weight) are substituted')
      sothat('users learn one vocabulary')

given('dispatcher role briefs')
  when('terminology knowledge is documented')
    then('brief exists for yieldage (effective gain measurement)')
      sothat('yieldage term is formally defined with examples')
    then('brief exists for yieldageDistribution (probabilistic yield model)')
      sothat('uncertain yield is modeled as { yieldage, probability }[] with examples')
    then('brief exists for leverage (efficiency gain measurement)')
      sothat('leverage term is formally defined with examples')
    then('brief exists for cost (expenditure measurement)')
      sothat('cost term is formally defined with examples')


---


# depth.domain = business logic and contracts


## scope.2 = dispatcher role briefs

### usecase.2.1 = discover relevant knowledge domains

given('dispatcher role with gather, deptrace, measure, triage, coordinate skills (atomic) and prioritize skill (composite)')
  when('brief research is initiated')
    then('all knowledge domains relevant to the skills are identified')
      sothat('no relevant knowledge is missed')
    then('domains are enumerated via analysis of skill requirements')
      sothat('discovery is systematic, not ad-hoc')

given('a candidate knowledge domain')
  when('relevance is assessed')
    then('domain is included if it informs gather skill decisions')
      sothat('gather skill has required knowledge')
    then('domain is included if it informs deptrace skill decisions')
      sothat('deptrace skill has required knowledge')
    then('domain is included if it informs measure skill decisions')
      sothat('measure skill has required knowledge')
    then('domain is included if it informs triage skill decisions')
      sothat('triage skill has required knowledge')
    then('domain is included if it informs coordinate skill decisions')
      sothat('coordinate skill has required knowledge')
    then('domain is included if it informs throughput maximization under resource constraints')
      sothat('optimization knowledge is available')


### usecase.2.2 = research best practices with evidence

given('a relevant knowledge domain')
  when('brief is researched')
    then('industry best practices are gathered')
      sothat('established patterns are leveraged')
    then('metrics are included where available')
      sothat('claims are quantifiable')
    then('citations are included for all claims')
      sothat('practices are grounded in evidence, not opinion')

given('research is complete for a domain')
  when('brief is written')
    then('brief distills knowledge into actionable guidance')
      sothat('knowledge is usable, not abstract')
    then('brief connects knowledge to dispatcher skill behaviors')
      sothat('briefs are practical, not just theoretical')


### usecase.2.3 = follow established knowledge distillation patterns

given('dispatcher role briefs')
  when('brief format is reviewed')
    then('briefs follow rhachet-roles-bhrain/src/roles/thinker/briefs/knowledge patterns')
      sothat('format is standardized across roles')
    then('briefs are organized under .agent/**/briefs/ structure')
      sothat('briefs are discoverable via convention')

given('brief file is created')
  when('file name is chosen')
    then('file name follows rhachet-roles-bhrain knowledge brief conventions')
      sothat('names are standardized')
    then('format tag is included in brackets ([article], [catalog], [demo], [lesson], [seed])')
      sothat('briefs are categorized by content type')

given('briefs are complete')
  when('coverage is reviewed')
    then('all knowledge domains from usecase.2.1 have briefs')
      sothat('no discovered domain is left undocumented')


---


## scope.3 = gather skill

### usecase.3.1 = gather output contract

given('sources have been scanned')
  when('gather skill writes output')
    then('each behavior directory is COPIED to {output}/.gathered/{org}/{repo}/{behaviorName}/')
      sothat('behaviors are organized by source origin')
    then('entire .behavior/{name}/ directory is copied recursively (all files, all subdirs)')
      sothat('all behavior artifacts are preserved')
    then('output is deterministic given same sources')
      sothat('gather results are reproducible and cacheable')

given('a copied behavior directory')
  when('provenance is needed')
    then('.gathered.json file exists in the copied directory')
      sothat('provenance is always available')
    then('.gathered.json contains: sourceType, sourcePath, org, repo, gatheredAt, contentHash')
      sothat('downstream skills can trace origin and detect changes')
    then('contentHash is computed once at gather time')
      sothat('downstream skills reuse it without recomputation')

given('gather output directory structure')
  when('structure is examined')
    then('structure is: {output}/.gathered/{org}/{repo}/{behaviorName}/')
      sothat('behaviors are browsable as normal directories')
    then('org = github org or local parent directory name')
      sothat('multi-org sources are separated')
    then('repo = repository name')
      sothat('multi-repo sources are separated')
    then('behaviorName = directory name from .behavior/{behaviorName}/')
      sothat('behavior identity is preserved from source')


### usecase.3.2 = gather from local sources

given('a rhachet.dispatch.yml with local.repos enumerated')
  when('gather skill scans local.repos')
    then('each path must be a git repo (contains .git/)')
      sothat('only valid repos are processed')
    then('all .behavior/*/ directories are discovered in each repo')
      sothat('all behaviors in repo are found')

given('a local.repos path that is not a git repo')
  when('gather skill validates sources')
    then('skill fails fast with clear error: "source is not a git repo: {path}"')
      sothat('misconfigured sources are caught immediately')

given('a local git repo at ~/code/myorg/myrepo with .behavior/v2025_01_01.feature-x/')
  when('gather skill copies the behavior')
    then('destination is {output}/.gathered/myorg/myrepo/v2025_01_01.feature-x/')
      sothat('path reflects source structure')
    then('all files from source are copied to destination')
      sothat('full behavior is captured')
    then('.gathered.json is added with sourceType="local.repo"')
      sothat('source type is recorded for traceability')


### usecase.3.3 = gather from remote sources

given('a rhachet.dispatch.yml with remote git repo URLs')
  when('gather skill scans remote.repos')
    then('repo is cloned/fetched to temp location')
      sothat('remote content is accessible locally')
    then('.behavior/*/ directories are discovered')
      sothat('all behaviors in repo are found')
    then('each behavior is copied to {output}/.gathered/{org}/{repo}/{behaviorName}/')
      sothat('output structure matches local gather')
    then('.gathered.json is added with sourceType="remote.repo"')
      sothat('source type distinguishes remote from local')

given('a remote repo with PRs labeled "behavior"')
  when('gather skill scans remote.repos with pr_labels=["behavior"]')
    then('PRs with label are fetched')
      sothat('in-flight behaviors in PRs are included')
    then('.behavior/*/ from each PR branch is copied')
      sothat('PR behavior content is captured')
    then('.gathered.json includes prNumber and prBranch')
      sothat('PR origin is traceable')

given('a remote repo with issues labeled "behavior.wish"')
  when('gather skill scans remote.repos with issue_labels=["behavior.wish"]')
    then('issues with label are fetched')
      sothat('wishes declared as issues are discoverable')
    then('synthetic behavior directory is created: {behaviorName}/0.wish.md')
      sothat('issue becomes a behavior with standard structure')
    then('0.wish.md contains issue title and body')
      sothat('wish content is preserved')
    then('.gathered.json includes issueNumber with sourceType="remote.issue"')
      sothat('issue origin is traceable')

given('a remote source that cannot be reached')
  when('gather skill attempts to fetch')
    then('skill fails fast with clear error')
      sothat('misconfigured or unavailable sources are caught immediately')


### usecase.3.4 = capture behavior status

given('a behavior with status=delivered declared in behavior docs')
  when('gather skill processes the behavior')
    then('behavior directory IS copied to output')
    then('.gathered.json includes status="delivered"')
      sothat('completed work is preserved for reference and dependency resolution')

given('a behavior with status=paused declared in behavior docs')
  when('gather skill processes the behavior')
    then('behavior directory IS copied to output')
    then('.gathered.json includes status="paused"')
      sothat('paused work remains visible but deprioritized')

given('a behavior with no status declared')
  when('gather skill processes the behavior')
    then('behavior directory IS copied to output')
    then('.gathered.json includes status="active"')
      sothat('active work is the default assumption')


### usecase.3.5 = gather cache and idempotency

given('a remote repo previously fetched')
  when('gather skill runs again')
    then('repo is only refetched if remote HEAD has changed')
      sothat('expensive network calls are skipped when repo unchanged')
    then('change detection uses git remote HEAD hash')
      sothat('detection is fast (no full clone needed)')

given('a local repo previously scanned')
  when('gather skill runs again')
    then('behaviors are only recopied if content hash changed')
      sothat('unchanged behaviors skip copy')
    then('content hash uses efficient stat-based detection per usecase.12.2')
      sothat('hash avoids reading unchanged files')

given('unchanged sources since last run')
  when('gather skill runs')
    then('output is identical')
      sothat('gather is idempotent')


---


## scope.4 = deptrace skill

### usecase.4.1 = deptrace skill purpose

given('dispatcher needs to understand behavior relationships')
  when('deptrace skill is explained')
    then('deptrace = "dependency trace"')
    then('purpose is to trace what each behavior depends on (blockers)')
      sothat('prioritize skill knows what must complete before this behavior can start')
    then('each behavior deptrace is self-contained')
      sothat('deptrace is cacheable per behavior independent of other behaviors')


### usecase.4.2 = deptrace skill input/output contracts

given('gathered output exists at {output}/.gathered/')
  when('deptrace skill reads input')
    then('all gathered behaviors are loaded as the basket')
    then('deptrace infers dependencies via analysis of behavior content')
      sothat('dependencies are detected without explicit declaration')

given('behaviors have been deptraced')
  when('deptrace skill writes output')
    then('deptraced behaviors are written to {output}/.deptraced/')
      sothat('deptrace results are persisted')
    then('dependencies.md renders the dependency tree per behavior')
      sothat('blocker relationships are human-readable')
    then('each BehaviorDeptraced record includes:')
      then('behaviorRef = reference to the behavior')
        sothat('record links back to source behavior')
      then('dependsOnDirect = behaviors this directly depends on')
        sothat('immediate blockers are known')
      then('dependsOnTransitive = all upstream behaviors (direct + indirect)')
        sothat('full blocker chain is visible')


### usecase.4.3 = deptrace per behavior (parallelizable)

given('a gathered basket of behaviors')
  when('deptrace skill processes each behavior')
    then('deptraceOneBehavior receives (basket, subject)')
      sothat('operation has full context')
    then('subject behavior is analyzed against the full basket')
      sothat('cross-behavior dependencies are detected')
    then('each behavior can be deptraced independently')
      sothat('no order constraints exist')
    then('operations are parallelizable across behaviors')
      sothat('throughput is maximized')


### usecase.4.4 = resolve direct dependencies

given('deptrace infers behavior A depends on "v2025_01_01.feature-b"')
given('behavior B exists in basket with behaviorName = "v2025_01_01.feature-b"')
  when('deptrace skill resolves dependencies for A')
    then('B is added to A.dependsOnDirect')
      sothat('A knows its blocker')

given('deptrace infers behavior A depends on "repo-x/v2025_01_01.feature-c"')
given('behavior C exists in basket with repoPath that contains "repo-x" and behaviorName = "v2025_01_01.feature-c"')
  when('deptrace skill resolves dependencies for A')
    then('C is added to A.dependsOnDirect')
      sothat('cross-repo blocker is recorded')


### usecase.4.5 = compute transitive dependencies

given('behavior A depends on B')
given('behavior B depends on C')
given('behavior C has no dependencies')
  when('deptrace skill computes transitive dependencies for A')
    then('A.dependsOnDirect = [B]')
      sothat('direct blocker is known')
    then('A.dependsOnTransitive = [B, C]')
      sothat('full upstream chain is captured')


### usecase.4.6 = handle unresolved dependencies

given('deptrace infers behavior A depends on "v2025_01_01.feature-absent"')
given('no behavior in basket matches "v2025_01_01.feature-absent"')
  when('deptrace skill resolves dependencies for A')
    then('warning is emitted about unresolved dependency')
      sothat('unresolved dependency is surfaced immediately')
    then('A.dependsOnDirect includes placeholder with resolved=false')
      sothat('unresolved dependencies are visible but do not block deptrace')

given('a behavior with unresolved dependencies')
  when('deptrace output is rendered')
    then('unresolved dependencies are flagged in output')
      sothat('humans can investigate absent behaviors')


### usecase.4.7 = detect circular dependencies

given('behavior A depends on B')
given('behavior B depends on C')
given('behavior C depends on A')
  when('deptrace skill computes transitive dependencies')
    then('circular dependency is detected')
      sothat('cycle is identified before infinite loop occurs')
    then('all behaviors in cycle are flagged with circularDependency=true')
      sothat('each behavior in cycle is marked')
    then('warning is emitted with cycle list: A â†’ B â†’ C â†’ A')
      sothat('exact cycle path is visible')

given('behaviors with circular dependencies')
  when('deptrace output is rendered')
    then('circular dependencies are called out explicitly')
      sothat('humans are alerted to fix the cycle')
    then('cycle is broken at arbitrary point for transitive computation')
      sothat('deptrace completes despite cycles')


### usecase.4.8 = handle behaviors with no dependencies

given('deptrace infers behavior A has no dependencies')
  when('deptrace skill processes A')
    then('A.dependsOnDirect = []')
      sothat('no blockers is explicitly recorded')
    then('A.dependsOnTransitive = []')
      sothat('leaf behaviors are valid deptrace targets')


### usecase.4.9 = deptrace cache and idempotency

given('a behavior previously deptraced')
  when('deptrace skill runs again')
    then('behavior is only re-deptraced if gathered contentHash changed')
      sothat('expensive inference is skipped when behavior unchanged')
    then('contentHash is read from .gathered.json (computed at gather time)')
      sothat('no hash recomputation needed')

given('deptrace infers dependencies via brain.repl')
  when('behavior content unchanged')
    then('cached inference result is reused')
      sothat('expensive brain.repl calls are skipped')

given('unchanged gathered input')
  when('deptrace skill runs')
    then('output is identical')
      sothat('deptrace is idempotent')
    then('order of behaviors in arrays is deterministic (sorted by behaviorRef)')
      sothat('deptrace output is cacheable')


---


## scope.5 = measure skill

### usecase.5.1 = measure skill contracts

given('gathered output exists at {output}/.gathered/')
given('deptraced output exists at {output}/.deptraced/')
  when('measure skill reads input')
    then('all gathered behaviors are loaded')
      sothat('behavior content is available for score computation')
    then('all deptraced behaviors are loaded')
      sothat('dependency context informs score computation')

given('behaviors have been scored')
  when('measure skill writes output')
    then('scored behaviors are written to {output}/.measured/')
      sothat('scores are persisted')
    then('each BehaviorMeasured includes:')
    then('  dimensions = { gain: { yieldage, leverage }, cost }')
      sothat('individual scores are visible')
    then('  decision = dimensions.gain.yieldage / dimensions.cost')
      sothat('single comparable value for triage decisions')
    then('  priority = p0 | p1 | p3 | p5')
      sothat('absolute priority label is assigned based on scores')

given('measure skill assigns priority label')
  when('priority is computed from dimensions')
    then('priority is absolute, not relative')
      sothat('multiple behaviors can share the same priority level')
    then('p0 (critical) = blocker dependency with no workaround')
      sothat('existential blockers are unmistakable')
    then('p1 (important) = high yieldage, required work')
      sothat('necessary work is clearly marked')
    then('p3 (desired) = moderate yieldage, wanted but not blocking')
      sothat('nice-to-haves are distinguishable')
    then('p5 (bonus) = low yieldage, stretch goals')
      sothat('optional work is clearly optional')


### usecase.5.2 = measure per behavior

given('a gathered basket and deptraced basket')
  when('measure skill processes each behavior')
    then('measureOneBehavior receives (gatheredBasket, deptracedBasket, subject)')
      sothat('operation has full context')
    then('subject behavior is scored via dependency context')
      sothat('transitive yieldage is computed')
    then('operations are parallelizable across behaviors')
      sothat('throughput is maximized')


### usecase.5.3 = measure behaviors against criteria

given('a rhachet.dispatch.yml with explicit measurement criteria')
  when('measure skill scores each behavior')
    then('yieldage score is calculated (effective gain)')
      sothat('work that produces large effective gain is prioritized')
    then('leverage score is calculated (efficiency gain)')
      sothat('work that increases efficiency is prioritized')
    then('cost estimate is calculated (multi-dimensional)')
      sothat('expensive work is weighed appropriately')

given('a behavior that unblocks three other behaviors')
  when('measure skill calculates yieldage')
    then('yieldage score includes the sum of dependent yieldage from unblocked behaviors')
      sothat('transitive effects are visible')

given('a behavior that reduces maintenance cost or increases delivery speed')
  when('measure skill calculates leverage')
    then('leverage score reflects the efficiency gain')
      sothat('work that makes the system more efficient is prioritized')

given('a behavior with no explicit criteria')
  when('measure skill scores')
    then('default score is applied')
      sothat('unmeasured work is still included')
    then('warning is emitted about absent criteria')
      sothat('unmeasured work is flagged for attention')


### usecase.5.4 = deterministic vs probabilistic measurement

given('a behavior with deterministic criteria')
  when('measure skill scores the behavior')
    then('scores are deterministic given same inputs')
      sothat('reproducibility is preserved where possible')

given('a behavior with criteria that require judgment')
  when('measure skill scores the behavior')
    then('brain.repl is invoked to score')
      sothat('probabilistic inference is explicit and controllable')

given('a behavior with uncertain yield')
  when('measure skill scores probabilistic yieldage')
    then('yieldageDistribution is modeled as { yieldage, probability }[]')
      sothat('yield uncertainty is explicit')
    then('each entry represents a possible yieldage outcome with its probability')
      sothat('best-case, worst-case, and likely-case are all visible')
    then('probabilities in distribution sum to 1.0')
      sothat('distribution is valid')
    then('failure probability is captured as { yieldage: 0, probability: P }')
      sothat('success probability is implicit (1 - P(yieldage=0))')

given('a behavior with uncertain yield')
  when('measure skill computes expected yieldage')
    then('yieldageExpected = sum of (yieldage Ã— probability) for each entry')
      sothat('expected value accounts for all outcomes, failure included')

given('a behavior with no uncertainty')
  when('measure skill scores')
    then('yieldageDistribution = [{ yieldage: X, probability: 1.0 }]')
      sothat('deterministic yield is a degenerate case of the distribution')


### usecase.5.5 = measure cache and idempotency

given('a behavior previously measured')
  when('measure skill runs again')
    then('behavior is only re-measured if gathered contentHash changed')
      sothat('expensive score computation is skipped when behavior unchanged')
    then('contentHash is read from .gathered.json (computed at gather time)')
      sothat('no hash recomputation needed')
    then('behavior is only re-measured if its deptrace result changed')
      sothat('dependency context changes trigger remeasure')

given('measure uses brain.repl for judgment')
  when('behavior content and deptrace unchanged')
    then('cached score is reused')
      sothat('expensive brain.repl calls are skipped')

given('unchanged gathered and deptraced input')
  when('measure skill runs')
    then('output is identical')
      sothat('measure is idempotent')

given('getOneMeasurement is called for a behavior')
  when('measurement exists in cache')
    then('cached measurement is returned')
      sothat('repeated calls are efficient')
      sothat('downstream skills can call getOneMeasurement without redundant computation')


---


## scope.6 = triage skill

### usecase.6.1 = triage skill contracts

given('measured output exists at {output}/.measured/')
  when('triage skill reads input')
    then('all scored behaviors are loaded')
      sothat('all behavior scores are available')
    then('dependency context from deptraced is available')
      sothat('blocker relationships inform urgency')

given('behaviors have been triaged by urgency')
  when('triage skill writes output')
    then('triaged behaviors are written to {output}/.triaged/')
      sothat('triage results are persisted')
    then('behaviors are grouped by urgency (now, soon, later)')
      sothat('temporal priority is clear')
    then('urgency assignment is deterministic given scores')
      sothat('triage is reproducible and cacheable')


### usecase.6.2 = triage.dimensions

given('triage evaluates each behavior across dimensions')
  when('triage assigns urgency')
    then('dimensions = { readiness, bandwidth }')
    then('decision = min(readiness, bandwidth)')
      sothat('lowest dimension wins (later < soon < now)')


### usecase.6.3 = triage.dimension=readiness

given('behavior A: unblocked, not paused')
  when('triage computes readiness')
    then('A.dimensions.readiness = "now"')
      sothat('ready work is actionable')

given('behavior A: blocked by B')
given('behavior B: decision = "now"')
  when('triage computes readiness')
    then('A.dimensions.readiness = "soon"')
      sothat('A is 1 hop from ready')

given('behavior A: blocked by B')
given('behavior B: decision = "soon" or "later"')
  when('triage computes readiness')
    then('A.dimensions.readiness = "later"')
      sothat('A is 2+ hops from ready')

given('behavior A: status=paused')
  when('triage computes readiness')
    then('A.dimensions.readiness = "later"')
      sothat('paused work is deferred regardless of blocking status')

given('behavior A: circularDependency=true')
  when('triage computes readiness')
    then('A is flagged with warning')
    then('A.dimensions.readiness = "later"')
      sothat('circular dependencies require human resolution')


### usecase.6.4 = triage.dimension=bandwidth

given('rhachet.dispatch.yml specifies constraints.maxConcurrency = N')
given('M behaviors have dimensions.readiness = "now"')
  when('triage computes bandwidth')
    then('behaviors are sorted by measurement.decision (descending)')
      sothat('highest-value behaviors are considered first')
    then('top N behaviors get dimensions.bandwidth = "now"')
      sothat('resource capacity is respected')
    then('remaining (M - N) behaviors get dimensions.bandwidth = "soon"')
      sothat('overflow work is deferred until capacity frees')

given('behavior has dimensions.readiness = "soon" or "later"')
  when('triage computes bandwidth')
    then('dimensions.bandwidth = dimensions.readiness')
      sothat('non-ready work inherits readiness as bandwidth')


### usecase.6.5 = triage output readability

given('triage output exists at {output}/.triaged/')
  when('user reads triage.md')
    then('behaviors are grouped by urgency (now, soon, later)')
      sothat('temporal priority is scannable')
    then('each behavior shows source repo, path, and scores')
      sothat('context is visible without drill-down')
    then('dependency relationships are rendered visibly')
      sothat('blockers are clear')


### usecase.6.6 = triage idempotency

given('unchanged measured input')
  when('triage skill runs')
    then('output is identical')
      sothat('triage is idempotent')
    then('triage is deterministic (no brain.repl, no network)')
      sothat('triage is fast enough to not need caching')


---


## scope.7 = prioritize composite skill

### usecase.7.1 = prioritize skill composition

given('prioritize is a composite skill')
  when('prioritize skill is explained')
    then('prioritize composes: gather â†’ deptrace â†’ measure â†’ triage')
      sothat('full pipeline is encapsulated')
    then('each subskill runs in sequence, output of one feeds input of next')
      sothat('data flows through pipeline correctly')

given('user wants to run the full prioritization pipeline')
  when('prioritize skill is invoked')
    then('gather skill runs first => .gathered/')
      sothat('behaviors are collected')
    then('deptrace skill runs second (.gathered/ => .deptraced/)')
      sothat('dependencies are traced')
    then('measure skill runs third (.gathered/ + .deptraced/ => .measured/)')
      sothat('behaviors are scored')
    then('triage skill runs fourth (.measured/ => .triaged/)')
      sothat('behaviors are assigned urgency buckets')


### usecase.7.2 = prioritize skill output

given('prioritize composite skill completes successfully')
  when('output is examined')
    then('all intermediate outputs exist (.gathered/, .deptraced/, .measured/, .triaged/)')
      sothat('each stage is inspectable')
    then('prioritization.md summarizes the final triaged output')
      sothat('human-readable summary is available')

given('user wants to re-run only part of the pipeline')
  when('intermediate outputs already exist')
    then('user can invoke individual subskills directly')
      sothat('incremental runs are supported')


### usecase.7.3 = output archiving on change

given('prioritize skill produces new output')
given('prior output files exist (prioritization.md, dependencies.md)')
  when('output would overwrite prior files')
    then('prior files are moved to {output}/.archive/')
      sothat('history is preserved')
    then('archived files are named {filename}.{isoTimestamp}.bak.md')
      sothat('archives are timestamped and sortable')
    then('new output files are written')
      sothat('current state is available at canonical paths')

given('prioritize skill produces unchanged output')
given('prior output files exist')
  when('output matches prior files exactly')
    then('no archive is created')
      sothat('unchanged runs do not pollute archive')
    then('prior files are retained as-is')
      sothat('file timestamps reflect actual change time')

given('coordinate skill produces new output')
given('prior coordination.md exists')
  when('output would overwrite prior file')
    then('prior file is moved to {output}/.archive/coordination.{isoTimestamp}.bak.md')
      sothat('coordination history is preserved')


---


## scope.8 = coordinate skill - workstream groups

### usecase.8.1 = coordinate concurrent workstreams

given('triaged behaviors in "now" and "soon" urgency levels')
  when('coordinate skill runs')
    then('independent behaviors are grouped into parallel workstreams')
      sothat('work that can proceed simultaneously is identified')
    then('workstream count reflects available resources')
      sothat('coordination matches actual capacity')

given('two behaviors with no dependency relationship')
  when('coordinate skill assigns workstreams')
    then('behaviors can be in different parallel workstreams')
      sothat('parallelization is maximized')

given('behavior A depends on behavior B')
  when('coordinate skill assigns workstreams')
    then('A and B are in same workstream, B before A')
      sothat('dependencies are respected within workstreams')


### usecase.8.2 = workstream priority from behavior priorities

given('each behavior has priority label from measure skill (p0 | p1 | p3 | p5)')
  when('coordinate skill assigns workstream priority')
    then('workstream priority = highest priority among its behaviors')
      sothat('workstream inherits urgency from its most critical behavior')
    then('priority labels are used as-is from measure output')
      sothat('coordinate does not recompute priority')

given('workstream contains behaviors with p0, p1, and p3')
  when('workstream priority is computed')
    then('workstream priority = p0')
      sothat('critical behaviors elevate the entire workstream')


### usecase.8.3 = workstream rank (relative order)

given('workstreams have been assigned priority labels')
  when('coordinate skill ranks workstreams')
    then('rank = relative order of importance (1, 2, 3, ...)')
      sothat('user knows which workstream to address first')
    then('rank is assigned based on priority, then by total yieldage within priority')
      sothat('ties within priority level are broken by value')

given('multiple workstreams have same priority level')
  when('coordinate skill assigns rank')
    then('workstreams are sub-ranked by total yieldage of their behaviors')
      sothat('higher-value workstreams within same priority come first')

given('workstream A has priority=p0, workstream B has priority=p1')
  when('coordinate skill assigns rank')
    then('A.rank < B.rank')
      sothat('p0 workstreams always rank before p1 workstreams')


### usecase.8.4 = detect workstream bottlenecks

given('multiple parallel workstreams with a shared dependency')
  when('coordinate skill analyzes workstreams')
    then('bottleneck point is identified')
      sothat('shared blockers are surfaced')
    then('bottleneck is annotated with which workstreams converge')
      sothat('bottleneck impact scope is visible')

given('workstream 2 blocks on workstream 3 output')
  when('coordinate skill renders output')
    then('blocker relationship is declared explicitly')
      sothat('cross-workstream dependencies are clear')
    then('expected unblock time is estimated if possible')
      sothat('reviewers know when to context-switch')


### usecase.8.5 = answer "which blocked workstream to review first"

given('workstreams 2 and 3 are both blocked on human review')
  when('user queries which to prioritize')
    then('user looks at workstream rank')
      sothat('relative order is immediately clear')
    then('workstream with lower rank number is reviewed first')
      sothat('rank 1 before rank 2 before rank 3')

given('multiple workstreams blocked on same reviewer')
  when('coordinate output is rendered')
    then('workstreams are listed in rank order')
      sothat('optimal review order is clear')


### usecase.8.6 = coordination output format

given('coordination output exists')
  when('user reads coordination.md')
    then('workstreams are numbered and labeled')
      sothat('workstreams are identifiable')
    then('each workstream shows ordered behaviors with priorities')
      sothat('workstream contents are scannable')
    then('bottleneck points are called out explicitly')
      sothat('constraints are visible')
    then('blocked workstreams show which other workstream/behavior they await')
      sothat('dependencies between workstreams are clear')


### usecase.8.7 = coordinate idempotency

given('unchanged triaged input')
  when('coordinate skill runs')
    then('output is identical')
      sothat('coordinate is idempotent')
    then('coordinate is deterministic (no brain.repl, no network)')
      sothat('coordinate is fast enough to not need caching')


---


## scope.9 = skill invocation contracts

### usecase.9.1 = gather skill invocation

given('rhachet.dispatch.yml exists with valid sources and output path')
  when('`npx rhachet run --repo bhuild --skill gather` is invoked')
    then('skill reads ./rhachet.dispatch.yml by default')
      sothat('config path is conventional')
    then('--per-config overrides default config path if specified')
      sothat('alternate configs are supported')
    then('skill writes outputs to {output}/.gathered/')
      sothat('gathered data is persisted')
    then('markdown summary is written to {output}/gathered.md')
      sothat('human-readable summary is available')
    then('json data is written to {output}/gathered.json')
      sothat('machine-readable data is available')

given('rhachet.dispatch.yml does not exist at specified path')
  when('gather skill is invoked')
    then('skill fails fast with clear error')
      sothat('misconfiguration is caught immediately')

given('output directory from config does not exist')
  when('gather skill is invoked')
    then('output directory is created')
      sothat('first-run succeeds without manual dir creation')


### usecase.9.2 = deptrace skill invocation

given('gathered output exists at {config.output}/.gathered/')
  when('`npx rhachet run --repo bhuild --skill deptrace` is invoked')
    then('skill reads gathered behaviors from input')
      sothat('gathered data is consumed')
    then('skill writes outputs to {output}/.deptraced/')
      sothat('deptraced data is persisted')
    then('markdown summary is written to {output}/dependencies.md')
      sothat('human-readable dependency tree is available')
    then('json data is written to {output}/deptraced.json')
      sothat('machine-readable data is available')

given('gathered output does not exist at specified path')
  when('deptrace skill is invoked')
    then('skill fails fast with clear error')
      sothat('misconfiguration is caught immediately')


### usecase.9.3 = measure skill invocation

given('gathered output exists at {config.output}/.gathered/')
given('deptraced output exists at {config.output}/.deptraced/')
  when('`npx rhachet run --repo bhuild --skill measure` is invoked')
    then('skill reads gathered and deptraced behaviors from input')
      sothat('both data sources are consumed')
    then('skill writes outputs to {output}/.measured/')
      sothat('measured data is persisted')
    then('json data is written to {output}/measured.json')
      sothat('machine-readable data is available')

given('gathered or deptraced output does not exist at specified path')
  when('measure skill is invoked')
    then('skill fails fast with clear error')
      sothat('misconfiguration is caught immediately')


### usecase.9.4 = triage skill invocation

given('measured output exists at {config.output}/.measured/')
  when('`npx rhachet run --repo bhuild --skill triage` is invoked')
    then('skill reads measured behaviors from input')
      sothat('measured data is consumed')
    then('skill writes outputs to {output}/.triaged/')
      sothat('triaged data is persisted')
    then('markdown summary is written to {output}/triage.md')
      sothat('human-readable summary is available')
    then('json data is written to {output}/triage.json')
      sothat('machine-readable data is available')

given('measured output does not exist at specified path')
  when('triage skill is invoked')
    then('skill fails fast with clear error')
      sothat('misconfiguration is caught immediately')


### usecase.9.5 = prioritize composite skill invocation

given('rhachet.dispatch.yml exists with valid sources and output path')
  when('`npx rhachet run --repo bhuild --skill prioritize` is invoked')
    then('skill composes: gather â†’ deptrace â†’ measure â†’ triage')
      sothat('full pipeline is encapsulated')
    then('each subskill runs in sequence')
      sothat('data flows correctly between stages')
    then('final output is triaged output at {output}/.triaged/')
      sothat('triaged result is the primary output')
    then('markdown summary is written to {output}/prioritization.md')
      sothat('human-readable summary is available')

given('any subskill fails during composite execution')
  when('prioritize composite skill runs')
    then('execution halts at failed subskill')
      sothat('partial results are preserved')
    then('error clearly identifies which subskill failed')
      sothat('debug is straightforward')


### usecase.9.6 = coordinate skill invocation

given('triaged output exists at {config.output}/.triaged/')
  when('`npx rhachet run --repo bhuild --skill coordinate` is invoked')
    then('skill reads triaged behaviors from input')
      sothat('triaged data is consumed')
    then('skill writes coordination outputs')
      sothat('coordination data is persisted')
    then('workstream map is written to {output}/coordination.md')
      sothat('human-readable workstream map is available')
    then('workstream data is written to {output}/coordination.json')
      sothat('machine-readable data is available')


### usecase.9.7 = idempotent execution

given('unchanged sources since last run')
  when('gather skill runs again')
    then('output is identical')
      sothat('gather is idempotent')

given('unchanged gathered input since last run')
  when('deptrace skill runs again')
    then('output is identical')
      sothat('deptrace is idempotent')

given('unchanged deptraced input since last run')
  when('measure skill runs again')
    then('output is identical')
      sothat('measure is idempotent')

given('unchanged measured input since last run')
  when('triage skill runs again')
    then('output is identical')
      sothat('triage is idempotent')

given('unchanged triaged input since last run')
  when('coordinate skill runs again')
    then('output is identical')
      sothat('coordinate is idempotent')

given('unchanged sources since last run')
  when('prioritize composite skill runs again')
    then('output is identical')
      sothat('prioritize composite is idempotent')


### usecase.9.8 = CLI output format

given('any skill is invoked')
  when('skill produces CLI output')
    then('output uses tree structure with branch characters (â”œâ”€, â””â”€, â”‚)')
      sothat('hierarchy is visually clear')
    then('output uses nature emojis: ðŸ¦« (beaver) for skill start, ðŸŒ² (pine) for steps, ðŸ•ï¸ (campsite) for archived, ðŸŒŠ (ocean) for output')
      sothat('output is visually scannable and zen')

given('a skill step is in progress')
  when('step is rendered')
    then('spinner is shown on first sub-branch')
      sothat('user knows step is running')
    then('spinner becomes âœ“ with timing when complete (e.g., "âœ“ done in 1.2s")')
      sothat('user knows step finished and how long it took')

given('behaviors have changed since last run')
  when('change summary is rendered')
    then('+ prefix indicates created behaviors')
      sothat('new behaviors are distinguishable')
    then('~ prefix indicates updated behaviors')
      sothat('modified behaviors are distinguishable')
    then('change details use format: ~ behaviorName (.attribute = oldValue â†’ newValue)')
      sothat('what changed is explicit')

given('prior output files exist and new output differs')
  when('archiving is rendered')
    then('ðŸ•ï¸ archived section lists archived files')
      sothat('user knows what was preserved')

given('output files are written')
  when('output is rendered')
    then('ðŸŒŠ output section lists written files')
      sothat('user can open output files')
    then('if unchanged, output shows "(unchanged)" but still lists files')
      sothat('user can still open unchanged files')


### usecase.9.9 = step-specific output metrics

given('gather step completes')
  when('output is rendered')
    then('shows "X repos scanned"')
      sothat('source count is visible')
    then('shows "X behaviors found"')
      sothat('total behavior count is visible')
    then('shows "X behaviors changed"')
      sothat('change scope is clear')

given('deptrace step completes')
  when('output is rendered')
    then('shows "X behaviors traced"')
      sothat('work done is visible')
    then('shows "X new, Y cached"')
      sothat('cache effectiveness is visible')

given('measure step completes')
  when('output is rendered')
    then('shows "X behaviors measured"')
      sothat('work done is visible')
    then('shows "X new, Y cached"')
      sothat('cache effectiveness is visible')

given('triage step completes')
  when('output is rendered')
    then('shows "X behaviors triaged"')
      sothat('work done is visible')
    then('shows "X now, Y soon, Z later"')
      sothat('urgency distribution is visible')
    then('shows urgency changes when behaviors move buckets (e.g., ".urgency = soon â†’ now")')
      sothat('unblocked work is highlighted')

given('coordinate step completes')
  when('output is rendered')
    then('shows "X behaviors grouped into Y workstreams"')
      sothat('grouping result is visible')
    then('shows "X bottleneck detected" if bottlenecks exist')
      sothat('constraints are surfaced')


---


## scope.10 = coordination adjustments

### usecase.10.1 = manual coordination adjustments

given('coordinate output exists')
  when('user wants to adjust workstream groups')
    then('coordination.json is human-editable')
      sothat('manual adjustments are possible')
    then('coordinate skill respects edits when re-run')
      sothat('hybrid automated+manual workflow is supported')


### usecase.10.2 = interactive mode is out of scope

given('wish mentioned interactive mode for hand-tuning')
  when('scope is evaluated')
    then('interactive mode is explicitly out of scope for this behavior')
      sothat('scope is bounded to automated prioritization and coordination')
    then('users who need to hand-tune can edit output files directly')
      sothat('manual override is still possible via file editing')


---


# depth.infra = cache, storage, parallel execution


## scope.11 = output directory initialization

### usecase.11.1 = findsertDispatchDir operation

given('any dispatcher skill is invoked')
  when('skill needs to write to output directory')
    then('findsertDispatchDir is called first')
      sothat('output directory is guaranteed to exist')
    then('operation creates {output}/ directory if it does not exist')
      sothat('first-run succeeds without manual dir creation')
    then('operation creates {output}/readme.md if it does not exist')
      sothat('users understand output structure and cache behavior')
    then('readme.md explains cache directories, archive behavior, and output files')
      sothat('users can invalidate cache and navigate outputs')

given('findsertDispatchDir is called multiple times')
  when('output directory already exists')
    then('operation is idempotent (no-op if directory and readme exist)')
      sothat('repeated calls are safe and fast')


---


## scope.12 = cache implementation

### usecase.12.1 = cache mechanism

given('any skill implements cache')
  when('cache mechanism is chosen')
    then('with-simple-cache is used for cache logic')
      sothat('cache logic is standardized')
    then('simple-on-disk-cache is used for cache storage')
      sothat('cache is consistent across skills')


### usecase.12.2 = efficient content hash computation (gather-time only)

given('gather skill computes contentHash for each behavior')
  when('hash is computed')
    then('unix native stat metadata is used first (mtime, size, inode)')
      sothat('hash avoids reading file contents when metadata unchanged')
    then('full content hash is computed only if stat metadata changed')
      sothat('expensive file reads are skipped for unchanged files')

given('a behavior directory needs content hash')
  when('hash is computed at gather time')
    then('git ls-files + git ls-tree is used if directory is git-tracked')
      sothat('git native hashing is leveraged')
    then('fallback to stat-based hash for non-git directories')
      sothat('non-git sources are still supported')

given('hash computation performance')
  when('large directories are hashed')
    then('hash is O(file count) for stat check, not O(file size)')
      sothat('large files do not slow cache checks')
    then('only changed files trigger content read')
      sothat('incremental changes are fast')

given('downstream skills need content hash')
  when('deptrace or measure checks cache')
    then('contentHash is read from .gathered.json')
      sothat('no recomputation occurs after gather')


### usecase.12.3 = parallel execution

given('multiple behaviors to process')
  when('skill supports parallel execution')
    then('work is decomposed per behavior')
      sothat('work units are independent')
    then('work runs concurrently (up to configured parallelism)')
      sothat('throughput is maximized via parallel execution')
    then('deptrace and measure skills support parallel execution')
      sothat('expensive operations are parallelized')
