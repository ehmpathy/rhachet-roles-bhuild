# execution plan: blocker.7, blocker.8, blocker.9 resolution

## blockers addressed

- **blocker.7**: propagate cost.horizon and upfront/recurrent model to implementations
- **blocker.8**: add integration tests for measure operations with brain.repl
- **blocker.9**: add integration tests for each domain operation with `.then.repeatedly()`

---

## skill classification per criteria.md

### deterministic skills (no brain.repl)
- **gather**: output is deterministic given same sources (usecase.3.1)
- **triage**: deterministic, no brain.repl, no network (usecase.6.6)
- **prioritize**: composite orchestrator of gather → deptrace → measure → triage
- **coordinate**: deterministic, no brain.repl, no network (usecase.8.7)

### creative skills (use brain.repl via claude-code cli)
- **deptrace**: infers dependencies via brain.repl (usecase.4.9)
- **measure**: brain.repl invoked to score behaviors requiring judgment (usecase.5.4)
  - leverage (time gained) via brain.repl
  - yieldage (cash gained) via brain.repl
  - attend (time cost) via brain.repl
  - expend (cash cost) via brain.repl

---

## phase 1: update domain objects

### 1.1 update BehaviorDispatchConfig
- add `cost: { horizon: number }` field
- default: 24 weeks

### 1.2 update BehaviorMeasuredCostAttend
- replace `hours`, `complexity` with `upfront`, `recurrent`
- composite formula: `(upfront ÷ cost.horizon) + recurrent`
- units: mins (upfront), mins/wk (recurrent), mins/wk (composite)

### 1.3 update BehaviorMeasuredCostExpend
- replace `direct`, `indirect` with `upfront`, `recurrent`
- composite formula: `(upfront ÷ cost.horizon) + recurrent`
- units: $$ (upfront), $$/wk (recurrent), $$/wk (composite)

---

## phase 2: create brain.repl infrastructure

### 2.1 create invokeBrainRepl adapter
- location: `src/infra/brain/invokeBrainRepl.ts`
- invokes claude-code CLI via `claude --print`
- accepts prompt string, returns structured response
- parses JSON from claude output via schema validation

### 2.2 update BehaviorDispatchContext
- add `brain: { repl: ... }` to context interface
- repl accepts `{ prompt: string; schema: ZodSchema<T> }` → `Promise<T>`

---

## phase 3: update deptrace operations (brain.repl)

### 3.1 update getOneBehaviorDeptraced
- use brain.repl to infer dependencies from behavior content
- analyze wish, criteria, blueprint to detect dependency references
- resolve refs against .gathered/latest/ basket

---

## phase 4: update measure operations (brain.repl)

### 4.1 update computeBehaviorMeasuredGainLeverage
- use brain.repl to analyze time gained
- consider author time saved and support time saved
- return leverage score in mins/wk

### 4.2 update computeBehaviorMeasuredGainYieldage
- use brain.repl to analyze cash gained
- model probabilistic yieldage as { yieldage, probability }[]
- compute expected yieldage from distribution

### 4.3 update computeBehaviorMeasuredCostAttend
- accept `config.cost.horizon` in input
- use brain.repl to analyze:
  - upfront time (one-time, in minutes)
  - recurrent time (per week, in mins/wk)
- compute composite: `(upfront / horizon) + recurrent`

### 4.4 update computeBehaviorMeasuredCostExpend
- accept `config.cost.horizon` in input
- use brain.repl to analyze:
  - upfront cost (one-time, in $$)
  - recurrent cost (per week, in $$/wk)
- compute composite: `(upfront / horizon) + recurrent`

### 4.5 update computeBehaviorMeasuredCostComposite
- deterministic: no brain.repl
- update to use mins/wk for attend, $$/wk for expend
- convert attend.composite (mins/wk) to $$/wk via hourly rate

### 4.6 update computeBehaviorMeasuredGainComposite
- deterministic: no brain.repl
- combine leverage and yieldage into gain(+$/wk)

### 4.7 update getOneBehaviorMeasured
- pass config.cost.horizon to attend/expend operations
- use async operations with brain.repl
- orchestrate all measure suboperations

---

## phase 5: add integration tests

### 5.1 test pattern
```ts
import { given, when, then, useBeforeAll } from 'test-fns';

describe('operationName', () => {
  given('[case1] scenario', () => {
    when('[t0] operation invoked', () => {
      then('expected outcome', async () => {
        // test logic
      }).then.repeatedly({
        criteria: process.env.CI ? 'SOME' : 'EVERY',
        attempts: 3,
      });
    });
  });
});
```

### 5.2 test files to create

#### deptrace (brain.repl)
- `getOneBehaviorDeptraced.integration.test.ts`

#### measure (brain.repl)
- `computeBehaviorMeasuredGainLeverage.integration.test.ts`
- `computeBehaviorMeasuredGainYieldage.integration.test.ts`
- `computeBehaviorMeasuredCostAttend.integration.test.ts`
- `computeBehaviorMeasuredCostExpend.integration.test.ts`
- `getOneBehaviorMeasured.integration.test.ts`

### 5.3 test scenarios
- verify brain.repl produces expected upfront/recurrent values
- verify composite calculation is correct
- verify relative priorities are sensible for example behaviors
- test against example repos with known behavior characteristics

---

## execution order

### phase 1: domain objects
1. [x] update BehaviorDispatchConfig (add cost.horizon)
2. [x] update BehaviorMeasuredCostAttend (upfront/recurrent model)
3. [x] update BehaviorMeasuredCostExpend (upfront/recurrent model)

### phase 2: brain.repl infrastructure
4. [x] create invokeBrainRepl adapter (src/infra/brain/)
5. [x] update BehaviorDispatchContext (add brain.repl)

### phase 3: deptrace operations (brain.repl)
6. [x] update getOneBehaviorDeptraced (use brain.repl to infer dependencies)

### phase 4: measure operations (brain.repl.imagine + deterministic)
7. [x] update computeBehaviorMeasuredGainLeverage (brain.repl.imagine)
8. [x] update computeBehaviorMeasuredGainYieldage (brain.repl.imagine direct, deterministic transitive)
9. [x] update computeBehaviorMeasuredCostAttend (brain.repl.imagine + cost.horizon)
10. [x] update computeBehaviorMeasuredCostExpend (brain.repl.imagine + cost.horizon)
11. [x] update computeBehaviorMeasuredCostComposite (deterministic, mins/wk → $$/wk)
12. [x] update computeBehaviorMeasuredGainComposite (deterministic)
13. [x] update getOneBehaviorMeasured (orchestrate, pass cost.horizon)

### phase 5: integration tests
14. [ ] add integration tests with .then.repeatedly() for deptrace
15. [ ] add integration tests with .then.repeatedly() for measure
16. [ ] run tests to verify

---

## status: IN PROGRESS (phase 5 - integration tests)
