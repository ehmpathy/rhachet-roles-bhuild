# blocker.1

is it clear that

leverage.author = add behavior w/ lever

leverage.support = fix behavior w/ lever

?

(please push back if disagree, btw)


# blocker.2

can we add a appendix section that distinguishes a couple high-gravity concepts away from leverage?

for me, initially, i kept thinking that "maintainability" and "evolvability" was a leverage dimension to measure.

rather, those are _levers_ that we want to leverage - not things to measure

i.e., maintainability = a lever, as it decreases support time

i.e., evolvability = a lever, as it decreases author time

# blocker.3

is
```
perX.Y.saved = enumerate(Y.byHand) - enumerate(Y.byTool)
perX.Y.added = enumerate(Y.addedByTool)
```
still relevant?


# blocker.4

elaborate or simplify this; cite a source with quote;
  ```
  energy = time × entropy rate

  where:
    energy = capacity to do work
    entropy rate = rate of state-space exploration
    time = the fundamental dimension
  ```

  in software terms:
  - **energy** = developer hours available
  - **entropy rate** = rate at which problems are solved
  - **time** = the irreducible constraint


# blocker.5

pullin this section from one of our earlier docs, for upfront visualization of the braoder concept of leverage

ensure its blended into our current definition coherently

except, ignore the part where it says its always a ratio. its not always a ratio, since you can always figure out the absolute value from the load - which we use in our calculations when reporting leverage so that its comparable.

the visualizations , wout=without terms, and physics backbone of use.effort vs arm.effort = super helpful though



      ## 0. core insight

      > **leverage = upfront investment → reduced adhoc cost**

      leverage transforms **when** effort is applied:
      - wout lever: effort applied as needed (adhoc cost per use)
      - with lever: effort applied ahead of time (mechanism investment)

      **how to increase leverage:**

      move the fulcrum closer to the load:
      ```
      low leverage:     ●───────────────────┬───────────────────●      (fulcrum centered)
                        use.effort          ▲                 load
                        force=high

      high leverage:    ●───────────────────────────┬───────────●      (fulcrum near load)
                        use.effort                  ▲         load
                        force=low
      ```

      move fulcrum → lengthens arm.effort → **less force needed to lift same load**

      i.e., **leverage investment = move fulcrum closer to load = create mechanisms that offload effort from your input into the lever arm → makes your effort.in more effective**

      **two types of effort:**
      - **arm.effort** = upfront invested mechanism that applies effort on your behalf (embedded in the lever)
      - **use.effort** = applied effort per use (adhoc force you exert each time)

      **the symmetry:**
      ```
      more arm.effort → less use.effort
      ```
      the mechanism holds embedded effort, so your use.effort becomes amplified.

      in software terms:
      - **lengthen arm.effort** = invest upfront in mechanisms that handle more
      - result: less use.effort (adhoc work) needed per use, same outcome achieved

      ```
      leverage = arm.effort / arm.load
      ```


      ---


      ## 1. the physics foundation

      all leverage concepts derive from archimedes' lever:

      ```
      ┌─────────────────────────────────────────────────────────────┐
      │                                                             │
      │     effort                                    load          │
      │       ↓                                        ↓            │
      │       ●────────────────────┬──────────────────●             │
      │       │                    │                  │             │
      │       │◄─── effort_arm ───►│◄── load_arm ────►│             │
      │                            ▲                                │
      │                         fulcrum                             │
      │                                                             │
      └─────────────────────────────────────────────────────────────┘
      ```

      **archimedes' law:**
      ```
      effort × effort_arm = load × load_arm
      ```

      **leverage formula:**
      ```
      leverage = effort_arm / load_arm
      ```

      **interpretation:**
      - leverage = 2.0 → half the effort moves the same load
      - leverage = 5.0 → 1/5th the effort moves the same load
      - leverage = 10.0 → 1/10th the effort moves the same load


      ---


be consistent with arm.effort vs use.effort and arm.load vs use.load
