# domain terms distillation: leverage (v2)

this document distills ubiquitous language terms for "leverage" grounded in fundamental physics, enabling intuitive, symmetric, and expressive domain vocabulary.


---


## 1. the physics foundation

all leverage concepts derive from archimedes' lever:

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│     effort                                    load          │
│       ↓                                        ↓            │
│       ●────────────────────┬──────────────────●             │
│       │                    │                  │             │
│       │◄─── effort_arm ───►│◄── load_arm ────►│             │
│                            ▲                                │
│                         fulcrum                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**archimedes' law:**
```
effort × effort_arm = load × load_arm
```

**leverage formula:**
```
leverage = effort_arm / load_arm
```

**interpretation:**
- leverage = 2.0 → half the effort moves the same load
- leverage = 5.0 → 1/5th the effort moves the same load
- leverage = 10.0 → 1/10th the effort moves the same load


---


## 2. fundamental atomic concepts


### 2.1. concept: lever

**what it is:**
a mechanism that transforms input into output with a ratio determined by geometry.

**physics definition:**
> "a rigid body able to rotate about a fixed point (fulcrum), used to transmit force"

**cross-domain manifestations:**

| domain | lever equivalent | what it transforms |
|--------|-----------------|-------------------|
| physics | rigid bar + fulcrum | force → force (amplified) |
| software | tool / abstraction | effort → outcome (amplified) |
| finance | debt | equity → assets (amplified) |
| biology | enzyme | time → reaction (accelerated) |
| economics | spending | dollars → GDP (multiplied) |

**atomic insight:**
> a lever is any mechanism that produces disproportionate output from input


### 2.2. concept: arm

**what it is:**
the distance from fulcrum to where force is applied (effort_arm) or where force is produced (load_arm).

**physics definition:**
> "the perpendicular distance from the line of action of a force to the axis of rotation"

**the key insight:**
> arm length determines leverage ratio — not force magnitude

**cross-domain manifestations:**

| domain | effort_arm (lengthen for more leverage) | load_arm (shorten for more leverage) |
|--------|----------------------------------------|-------------------------------------|
| physics | distance from fulcrum to effort point | distance from fulcrum to load point |
| software | scope of what mechanism handles | cost to invoke/use mechanism |
| finance | total assets controlled | equity required |
| biology | reactions catalyzed | catalyst concentration |
| economics | downstream spending enabled | initial spending |

**atomic insight:**
> arm = the reach of a mechanism; longer reach on effort side = more leverage


### 2.3. concept: ratio

**what it is:**
leverage is always a ratio of output to input, or arm lengths.

**physics definition:**
> "mechanical advantage = output_force / input_force = effort_arm / load_arm"

**cross-domain manifestations:**

| source | numerator | denominator | ratio name |
|--------|-----------|-------------|------------|
| physics | output_force | input_force | mechanical_advantage |
| physics | effort_arm | load_arm | mechanical_advantage |
| v1: ICSE 2021 | dependencies_code | own_code | technical_leverage |
| v1: ROI | gains - costs | costs | roi |
| v1: platform eng | developers_supported | platform_team_size | platform_leverage |
| v2: finance | total_assets | shareholders_equity | financial_leverage |
| v2: economics | GDP_change | spending_change | fiscal_multiplier |
| v2: biology | reaction_rate_with | reaction_rate_without | catalytic_efficiency |
| v3: human seed | effort_before | effort_after | leverage |

**atomic insight:**
> leverage is ALWAYS a ratio — never an absolute value


### 2.4. concept: conservation

**what it is:**
leverage transforms input distribution, but total work is conserved.

**physics definition:**
> "work_in = work_out; effort × effort_distance = load × load_distance"

**implications:**

| gain | cost | source |
|------|------|--------|
| less force required | more distance traveled | physics |
| less equity required | more debt obligations | finance |
| less time required | more catalyst needed | biology |
| less effort required | mechanism must exist | software |

**atomic insight:**
> leverage doesn't create value — it transforms how value is applied


### 2.5. concept: cascade

**what it is:**
leverage compounds when outputs become inputs to subsequent levers.

**cross-domain manifestations:**

| domain | cascade mechanism | amplification pattern |
|--------|------------------|----------------------|
| physics | chained levers | output_1 → input_2 → output_2 |
| biology | enzyme cascades | 1 enzyme → many copies of next |
| ecology | trophic cascades | predator → prey → plants |
| economics | multiplier effect | $1 spent → $5 GDP |
| software | composable tools | tool_1 output → tool_2 input |

**atomic insight:**
> leverage.total = leverage_1 × leverage_2 × ... × leverage_n (when chained)


---


## 3. term mappings by source


### 3.1. v1 (software industry) terms

| v1 term | physics equivalent | our term |
|---------|-------------------|----------|
| technical_leverage | mechanical_advantage | leverage (ratio) |
| borrowed_assets | load lifted by lever | outcome amplified |
| own_assets | effort applied | input invested |
| force_multiplier | mechanical_advantage | leverage |
| throughput | output rate | outcome / time |
| velocity | output rate | outcome / time |
| inner_loop | direct work | load moved |
| outer_loop | overhead | friction (load_arm lengthener) |


### 3.2. v2 (cross-domain) terms

| v2 term | physics mapping | our term |
|---------|----------------|----------|
| mechanical_advantage | = effort_arm / load_arm | leverage |
| effort_arm | distance from fulcrum to effort | arm.effort |
| load_arm | distance from fulcrum to load | arm.load |
| financial_leverage | assets / equity | leverage (finance domain) |
| operating_leverage | fixed_costs / variable_costs | leverage (operations domain) |
| fiscal_multiplier | GDP_change / spending_change | leverage (economics domain) |
| catalytic_efficiency | kcat / Km | leverage (biology domain) |
| keystone_species | disproportionate ecological impact | high-leverage entity |
| trophic_cascade | chained ecological effects | cascade |
| leverage_point | place where small change → big effect | high-leverage intervention |


### 3.3. v3 (human seed) terms

| v3 term | physics mapping | our term |
|---------|----------------|----------|
| faster | less time for same outcome | leverage.faster |
| simpler | less thought for same outcome | leverage.simpler |
| safer | less risk for same outcome | leverage.safer |
| observable | less debug time for same diagnosis | leverage.observable |
| readable | less parse time for same understanding | leverage.readable |
| composable | less friction for same integration | leverage.composable |
| reusable | less dev cost for same solution | leverage.reusable |
| evolvable | less refactor cost for same adaptation | leverage.evolvable |
| effort_arm | scope of what mechanism handles | arm.effort |
| load_arm | cost to use mechanism | arm.load |
| mechanism_scope | = effort_arm | arm.effort |
| mechanism_cost | = load_arm | arm.load |


---


## 4. proposed ubiquitous language


### 4.1. core terms (from physics)

| term | definition | formula |
|------|------------|---------|
| **lever** | a mechanism that transforms input into amplified output | — |
| **arm.effort** | reach of what the mechanism handles (lengthen for more leverage) | — |
| **arm.load** | cost required to use the mechanism (shorten for more leverage) | — |
| **leverage** | ratio of arm lengths; amplification factor | `arm.effort / arm.load` |
| **cascade** | chained levers where output feeds next input | `leverage_1 × leverage_2 × ...` |


### 4.2. leverage dimensions (the 8 axes)

grounded in physics: each dimension is a specific type of "effort reduced for same outcome"

| dimension | what effort is reduced | arm.effort (lengthen) | arm.load (shorten) |
|-----------|----------------------|----------------------|-------------------|
| **leverage.faster** | time | automation scope | invocation cost |
| **leverage.simpler** | thought cycles | complexity hidden | knowledge required |
| **leverage.safer** | risk exposure | failure modes covered | effort to be correct |
| **leverage.observable** | debug time | state visibility | query complexity |
| **leverage.readable** | comprehension time | meaning density | tokens to parse |
| **leverage.composable** | integration effort | integration potential | integration friction |
| **leverage.reusable** | development cost | usecases addressed | build investment |
| **leverage.evolvable** | refactor cost | change isolation | coupling touched |


### 4.3. measurement terms

| term | definition | formula |
|------|------------|---------|
| **leverage.X** | leverage on dimension X | `effort_before / effort_after` |
| **leverage.total** | aggregate leverage across dimensions | `f(leverage.faster, ..., leverage.evolvable)` |
| **gain.X** | improvement in leverage on dimension X | `leverage.X.after - leverage.X.before` |
| **leverage.cascade** | product of chained leverages | `∏ leverage_i` |


### 4.4. intervention terms

| term | definition | physics analogy |
|------|------------|-----------------|
| **lengthen arm.effort** | increase scope of what mechanism handles | move effort point farther from fulcrum |
| **shorten arm.load** | decrease cost to use mechanism | move load point closer to fulcrum |
| **add lever** | introduce new mechanism | add lever to chain |
| **cascade** | chain mechanisms so output feeds input | compound levers |


---


## 5. the unified formula

all leverage reduces to the same physics pattern:

```
leverage = arm.effort / arm.load
         = scope / cost
         = effort_before / effort_after
         = effort_wout_mechanism / effort_with_mechanism
```

**equivalences:**

| framing | numerator | denominator |
|---------|-----------|-------------|
| arm-based | arm.effort | arm.load |
| scope-based | mechanism_scope | mechanism_cost |
| effort-based | effort_before | effort_after |
| counterfactual | effort_wout | effort_with |

**all framings are equivalent** — they describe the same ratio from different perspectives.


---


## 6. dimension-specific formulas


### 6.1. leverage.faster

```
leverage.faster = time_wout / time_with
                = time_before_automation / time_after_automation
```

**arm mapping:**
- arm.effort = scope of automation (how much work handled per invocation)
- arm.load = invocation cost (commands, setup, prerequisites)


### 6.2. leverage.simpler

```
leverage.simpler = thought_cycles_wout / thought_cycles_with
                 = cognitive_load_before / cognitive_load_after
```

**arm mapping:**
- arm.effort = complexity hidden by abstraction
- arm.load = knowledge required to use


### 6.3. leverage.safer

```
leverage.safer = risk_wout / risk_with
               = risk_surface_before / risk_surface_after
```

**arm mapping:**
- arm.effort = failure modes covered by guard rails
- arm.load = effort to stay on correct path


### 6.4. leverage.observable

```
leverage.observable = debug_time_wout / debug_time_with
                    = investigation_effort_before / investigation_effort_after
```

**arm mapping:**
- arm.effort = system state exposed by instrumentation
- arm.load = effort to access that visibility


### 6.5. leverage.readable

```
leverage.readable = comprehension_time_wout / comprehension_time_with
                  = parse_effort_before / parse_effort_after
```

**arm mapping:**
- arm.effort = meaning conveyed per token
- arm.load = tokens required to parse


### 6.6. leverage.composable

```
leverage.composable = friction_wout / friction_with
                    = integration_friction_counterfactual / integration_friction_actual
```

**arm mapping:**
- arm.effort = integration potential (downstream usecases)
- arm.load = integration friction (glue code, adapters)


### 6.7. leverage.reusable

```
leverage.reusable = dev_cost_wout / dev_cost_with
                  = (usecases × cost_each_wout) / (usecases × cost_each_with)
```

**arm mapping:**
- arm.effort = usecases addressed by solution
- arm.load = development investment required


### 6.8. leverage.evolvable

```
leverage.evolvable = refactor_cost_wout / refactor_cost_with
                   = change_cost_before / change_cost_after
```

**arm mapping:**
- arm.effort = change isolated by boundaries
- arm.load = touchpoints requiring update


---


## 7. cascade formulas


### 7.1. chained leverage

when tools are composed, leverage multiplies:

```
leverage.cascade = leverage_1 × leverage_2 × ... × leverage_n
```

**example:**
```
domain-objects (5x) → dao-generator (3x) → type-safety (2x)
leverage.cascade = 5 × 3 × 2 = 30x
```


### 7.2. composability as gate

composability determines how much leverage transfers through the chain:

```
leverage.effective = composability_1 × composability_2 × ... × leverage.cascade
```

if any composability_i → 0, the chain breaks.


---


## 8. summary: the ubiquitous language


### 8.1. core vocabulary

| term | meaning |
|------|---------|
| **lever** | mechanism that amplifies input |
| **arm.effort** | reach of mechanism (lengthen for more leverage) |
| **arm.load** | cost of mechanism (shorten for more leverage) |
| **leverage** | amplification ratio = arm.effort / arm.load |
| **cascade** | chained levers, multiplicative |


### 8.2. dimension vocabulary

| term | measures |
|------|----------|
| **leverage.faster** | time amplification |
| **leverage.simpler** | cognitive amplification |
| **leverage.safer** | risk reduction |
| **leverage.observable** | debug time amplification |
| **leverage.readable** | comprehension amplification |
| **leverage.composable** | integration amplification |
| **leverage.reusable** | development cost amplification |
| **leverage.evolvable** | change cost amplification |


### 8.3. measurement vocabulary

| term | meaning |
|------|---------|
| **leverage.X** | leverage on dimension X |
| **gain.X** | improvement in leverage.X |
| **leverage.total** | aggregate across dimensions |
| **leverage.cascade** | product of chained leverages |


### 8.4. intervention vocabulary

| term | meaning |
|------|---------|
| **lengthen arm.effort** | increase mechanism scope |
| **shorten arm.load** | decrease mechanism cost |
| **add lever** | introduce new mechanism |
| **cascade** | chain mechanisms |


---


## 9. design principles


### 9.1. why physics-grounded terms

1. **universal truth** — physics laws are invariant across domains
2. **intuition** — everyone understands levers from childhood
3. **precision** — formulas are unambiguous
4. **composability** — terms combine naturally (arm.effort, leverage.faster)
5. **symmetry** — all dimensions follow same pattern


### 9.2. why `leverage.X` notation

1. **namespace clarity** — `leverage.faster` not `faster_leverage`
2. **autocomplete** — type `leverage.` to see all dimensions
3. **symmetry** — consistent pattern across all 8 dimensions
4. **readability** — `leverage.faster = 3.0` reads naturally


### 9.3. why `arm.effort` and `arm.load`

1. **physics fidelity** — matches archimedes' original terminology
2. **action clarity** — "lengthen arm.effort" vs "increase scope"
3. **visual intuition** — can picture the lever diagram
4. **dual nature** — two ways to increase leverage (lengthen effort, shorten load)


---


## 10. usage examples


### 10.1. describing a tool

```
declapract provides leverage.simpler = 10x
- arm.effort = all best practices applied automatically
- arm.load = one command invocation
- mechanism hides massive complexity (long arm.effort)
- mechanism costs almost nothing to use (short arm.load)
```


### 10.2. measuring an improvement

```
adding RefByUnique to domain-objects:
- leverage.composable.before = 2x
- leverage.composable.after = 10x
- gain.composable = 8x
```


### 10.3. analyzing a cascade

```
domain-objects → dao-generator → type-safety:
- leverage.composable of domain-objects = 5x
- leverage.faster of dao-generator = 3x
- leverage.safer of type-safety = 2x
- leverage.cascade = 5 × 3 × 2 = 30x
```


### 10.4. prioritizing work

```
behavior A: gain.faster = 2x, gain.composable = 5x
behavior B: gain.faster = 4x, gain.composable = 1x

behavior A provides more leverage.cascade potential
(higher composability enables downstream multiplication)
```


---


## 11. open questions

1. **weighting dimensions**: how to compute leverage.total from individual dimensions?
2. **measurement units**: should arm lengths be unitless or have domain-specific units?
3. **bounds**: what are the carnot-like limits on software leverage?
4. **risk**: how to factor in that high leverage = high dependency exposure?

