# domain distillation: dispatcher role

distills the declastruct domain.objects and domain.operations that enable fulfillment of the dispatcher wish/vision/criteria.

---

## 1. usecases and contracts

### 1.1 gather skill usecases

#### usecase: gather behaviors from sources

```ts
/**
 * .what = discovers all behaviors from configured sources
 * .why = must enumerate all candidate work before prioritization
 */
export const gatherBehaviors: (
  input: {
    sources: BehaviorSource[];
  },
  context: BhuildDispatcherContext,
) => Promise<{
  behaviors: BehaviorGathered[];
}>;
```

#### usecase: save gathered output

```ts
/**
 * .what = persists gathered behaviors to disk
 * .why = produces inspectable output for downstream skills
 */
export const saveGatheredBehaviors: (
  input: {
    behaviors: BehaviorGathered[];
    outputDir: string;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  jsonPath: string;
}>;
```

### 1.2 deptrace skill usecases

#### usecase: deptrace one behavior

```ts
/**
 * .what = identifies dependencies for a single behavior
 * .why = must know dependency graph before measuring yieldage
 *
 * note: parallelizable - each behavior can be deptraced independently
 */
export const deptraceOneBehavior: (
  input: {
    behaviorsGathered: BehaviorGathered[];  // the full basket
    subject: BehaviorGathered;               // the behavior to deptrace
  },
  context: BhuildDispatcherContext,
) => Promise<{
  deptraced: BehaviorDeptraced;
}>;
```

#### usecase: save deptraced output

```ts
/**
 * .what = persists deptraced behaviors to disk
 * .why = produces inspectable output for downstream skills
 *
 * note: also produces dependencies.md with human-readable dependency tree
 */
export const saveDeptracedBehaviors: (
  input: {
    deptraced: BehaviorDeptraced[];
    outputDir: string;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  jsonPath: string;
  dependenciesMdPath: string;
}>;
```

### 1.3 prioritize skill usecases

#### usecase: measure one behavior

```ts
/**
 * .what = scores a single behavior for yieldage, leverage, and cost
 * .why = quantifies value to enable prioritization
 *
 * note: parallelizable - each behavior can be measured independently
 * note: depends on deptrace output to calculate dependent yieldage
 */
export const measureOneBehavior: (
  input: {
    behaviorsGathered: BehaviorGathered[];   // the full basket
    behaviorsDeptraced: BehaviorDeptraced[]; // dependency graphs for all
    subject: BehaviorGathered;                // the behavior to measure
    criteria: BehaviorMeasurementCriteria;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  measured: BehaviorMeasured;
}>;
```

#### usecase: triage behaviors into urgency buckets

```ts
/**
 * .what = assigns each behavior to now/soon/later urgency bucket
 * .why = segments work by temporal urgency for coordination
 *
 * note: triage is fully deterministic (no brain.repl)
 * note: dimensions = { readiness, bandwidth }
 * note: decision = min(readiness, bandwidth)
 */
export const triageBehaviors: (
  input: {
    behaviorsGathered: BehaviorGathered[];
    behaviorsMeasured: BehaviorMeasured[];
    behaviorsDeptraced: BehaviorDeptraced[];
    maxConcurrency: number;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  triaged: BehaviorTriaged[];
  byDecision: {
    now: BehaviorTriaged[];
    soon: BehaviorTriaged[];
    later: BehaviorTriaged[];
  };
}>;
```

#### usecase: save prioritization decisions

```ts
/**
 * .what = persists prioritization to md and json files
 * .why = produces human-readable and machine-usable output
 */
export const savePrioritizationDecisions: (
  input: {
    triaged: BehaviorTriaged[];
    byDecision: { now: BehaviorTriaged[]; soon: BehaviorTriaged[]; later: BehaviorTriaged[] };
    behaviorsDeptraced: BehaviorDeptraced[];
    outputDir: string;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  mdPath: string;
  jsonPath: string;
}>;
```

### 1.4 coordinate skill usecases

#### usecase: assign behaviors to workstreams

```ts
/**
 * .what = partitions behaviors into parallel execution lanes
 * .why = maximizes throughput via parallelization
 */
export const assignBehaviorsToWorkstreams: (
  input: {
    triaged: BehaviorTriaged[];
    behaviorsDeptraced: BehaviorDeptraced[];
    resourceConstraints: BehaviorResourceConstraints;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  workstreams: BehaviorWorkstream[];
}>;
```

#### usecase: detect workstream bottlenecks

```ts
/**
 * .what = finds convergence points where streams block on each other
 * .why = makes bottlenecks visible for review prioritization
 */
export const detectWorkstreamBottlenecks: (
  input: {
    workstreams: BehaviorWorkstream[];
    behaviorsDeptraced: BehaviorDeptraced[];
  },
  context: BhuildDispatcherContext,
) => Promise<{
  bottlenecks: BehaviorWorkstreamBottleneck[];
}>;
```

#### usecase: save coordination decisions

```ts
/**
 * .what = persists stream map to md and json files
 * .why = produces human-readable and machine-usable coordination
 */
export const saveCoordinationDecisions: (
  input: {
    workstreams: BehaviorWorkstream[];
    bottlenecks: BehaviorWorkstreamBottleneck[];
    outputDir: string;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  mdPath: string;
  jsonPath: string;
}>;
```

---

## 2. context

### BhuildDispatcherContext

```ts
/**
 * .what = shared context for all dispatcher operations
 * .why = single context reduces fragmentation and promotes reuse
 */
export interface BhuildDispatcherContext {
  /**
   * cache for content-addressed storage
   */
  cache: SimpleOnDiskCache;

  /**
   * brain.repl for probabilistic scoring
   */
  brain: BrainRepl;

  /**
   * logging methods
   */
  log: LogMethods;
}
```

---

## 3. domain.objects

### 3.1 entities (identity matters, lifecycle exists)

#### BehaviorSource

```ts
import { DomainEntity } from 'domain-objects';

/**
 * .what = a location from which behaviors are gathered
 * .why = enables multi-source behavior discovery
 */
export interface BehaviorSource {
  /**
   * uuid of this source (generated)
   */
  uuid?: string;

  /**
   * type of source
   */
  type: 'local.dir' | 'remote.repo' | 'remote.org' | 'remote.pr' | 'remote.issue';

  /**
   * path or url to the source
   */
  path: string;

  /**
   * for remote sources: authentication method if private
   */
  auth: null | { method: 'ssh' | 'token'; ref: string };

  /**
   * for remote sources with labels: which labels to filter by
   */
  labels: null | string[];

  /**
   * content hash of last successful fetch (for cache invalidation)
   */
  lastContentHash: null | string;

  /**
   * timestamp of last successful fetch
   */
  lastFetchedAt: null | string;
}

export class BehaviorSource
  extends DomainEntity<BehaviorSource>
  implements BehaviorSource
{
  public static primary = ['uuid'] as const;
  public static unique = ['type', 'path'] as const;
}
```

#### BehaviorGathered

```ts
import { DomainEntity, DomainLiteral } from 'domain-objects';

/**
 * .what = a file within a behavior directory
 * .why = captures full file content for downstream processing
 */
export interface BehaviorGatheredFile {
  /**
   * relative path within behavior directory (e.g., "3.1.research.domain.md")
   */
  relativePath: string;

  /**
   * full text content of the file
   */
  content: string;
}

export class BehaviorGatheredFile
  extends DomainLiteral<BehaviorGatheredFile>
  implements BehaviorGatheredFile {}

/**
 * .what = a behavior discovered from a source
 * .why = represents a unit of work to be prioritized
 *
 * note: contains FULL CONTENT of all behavior files, not just paths
 */
export interface BehaviorGathered {
  /**
   * uuid of this behavior (generated)
   */
  uuid?: string;

  /**
   * reference to the source this behavior was gathered from
   */
  sourceRef: { type: BehaviorSource['type']; path: string };

  /**
   * path to the git repo containing this behavior
   */
  repoPath: string;

  /**
   * path to the behavior directory (e.g., .behavior/v2025_01_01.feature-x/)
   */
  behaviorPath: string;

  /**
   * parsed behavior name from directory (e.g., v2025_01_01.feature-x)
   */
  behaviorName: string;

  /**
   * status flag if declared in behavior
   */
  status: 'active' | 'paused' | 'done';

  /**
   * FULL TEXT CONTENT of 0.wish.md (not a path)
   */
  wish: null | string;

  /**
   * FULL TEXT CONTENT of 1.vision.md (not a path)
   */
  vision: null | string;

  /**
   * FULL TEXT CONTENT of 2.criteria.md (not a path)
   */
  criteria: null | string;

  /**
   * ENTIRE .behavior/{name}/ directory contents
   *
   * note: every file in the directory, recursively:
   *       - 0.wish.md, 1.vision.md, 2.criteria.md
   *       - 3.x.*.md research and distillation docs
   *       - execution logs, feedback files
   *       - nested subdirectories
   *       - any other files present
   */
  files: BehaviorGatheredFile[];

  /**
   * declared dependencies (behavior names this behavior depends on)
   */
  dependsOn: string[];

  /**
   * content hash for cache invalidation (hash of all files)
   */
  contentHash: string;

  /**
   * timestamp when gathered
   */
  gatheredAt: string;
}

export class BehaviorGathered
  extends DomainEntity<BehaviorGathered>
  implements BehaviorGathered
{
  public static primary = ['uuid'] as const;
  public static unique = ['repoPath', 'behaviorPath'] as const;
  public static nested = {
    files: BehaviorGatheredFile,
  };
}
```

#### BehaviorDeptraced

```ts
import { DomainEntity } from 'domain-objects';

/**
 * .what = dependency trace for a single behavior
 * .why = identifies what this behavior depends on (blockers)
 *
 * note: deptrace only tracks dependsOn* (not dependedBy*)
 * note: blockee computation (what depends on this) is computed at measure time via graph inversion
 */
export interface BehaviorDeptraced {
  /**
   * uuid of this deptrace (generated)
   */
  uuid?: string;

  /**
   * reference to the behavior that was deptraced
   */
  behaviorRef: { repoPath: string; behaviorPath: string };

  /**
   * behaviors this behavior directly depends on (blockers)
   *
   * note: resolved=false indicates dependency declared but not found in basket
   */
  dependsOnDirect: Array<{
    repoPath: string;
    behaviorPath: string;
    resolved: boolean;
  }>;

  /**
   * behaviors this behavior transitively depends on (all upstream)
   */
  dependsOnTransitive: Array<{
    repoPath: string;
    behaviorPath: string;
    resolved: boolean;
  }>;

  /**
   * whether this behavior is part of a circular dependency
   */
  circularDependency: boolean;

  /**
   * if circularDependency=true, the cycle this behavior is part of
   */
  circularDependencyCycle: null | Array<{ repoPath: string; behaviorPath: string }>;

  /**
   * content hash of behavior at time of deptrace (for cache)
   */
  behaviorContentHash: string;

  /**
   * timestamp when deptraced
   */
  deptracedAt: string;
}

export class BehaviorDeptraced
  extends DomainEntity<BehaviorDeptraced>
  implements BehaviorDeptraced
{
  public static primary = ['uuid'] as const;
  public static unique = ['behaviorRef', 'behaviorContentHash'] as const;
}
```

#### BehaviorMeasured

```ts
import { DomainEntity } from 'domain-objects';

/**
 * .what = scored assessment of a behavior
 * .why = quantifies value for prioritization
 *
 * note: dimensions = { gain: { yieldage, leverage }, cost }
 * note: decision = dimensions.gain.yieldage / dimensions.cost
 * note: priority is absolute label (p0/p1/p3/p5) assigned based on dimensions
 */
export interface BehaviorMeasured {
  /**
   * uuid of this measurement (generated)
   */
  uuid?: string;

  /**
   * reference to the behavior measured
   */
  behaviorRef: { repoPath: string; behaviorPath: string };

  /**
   * measurement dimensions
   */
  dimensions: {
    /**
     * gain dimensions (what completing this produces)
     */
    gain: {
      /**
       * yieldage = effective gain (direct + dependent)
       */
      yieldage: BehaviorMeasuredYieldage;
      /**
       * leverage = efficiency gain (reduced cost, faster delivery)
       */
      leverage: BehaviorMeasuredLeverage;
    };
    /**
     * cost = multi-dimensional expenditure
     */
    cost: BehaviorMeasuredCost;
  };

  /**
   * decision score: dimensions.gain.yieldage.expected / dimensions.cost.total
   *
   * note: higher score = more value per unit cost
   */
  decision: number;

  /**
   * absolute priority label based on dimensions
   *
   * note: p0 = critical (blocker with no workaround)
   * note: p1 = important (high yieldage, required work)
   * note: p3 = desired (moderate yieldage, wanted but not blocking)
   * note: p5 = bonus (low yieldage, stretch goals)
   */
  priority: BehaviorPriority;

  /**
   * content hash of behavior at time of measurement (for cache)
   */
  behaviorContentHash: string;

  /**
   * timestamp when measured
   */
  measuredAt: string;
}

export class BehaviorMeasured
  extends DomainEntity<BehaviorMeasured>
  implements BehaviorMeasured
{
  public static primary = ['uuid'] as const;
  public static unique = ['behaviorRef', 'behaviorContentHash'] as const;
  public static nested = {
    dimensions: {
      gain: {
        yieldage: BehaviorMeasuredYieldage,
        leverage: BehaviorMeasuredLeverage,
      },
      cost: BehaviorMeasuredCost,
    },
    priority: BehaviorPriority,
  };
}
```

#### BehaviorTriaged

```ts
import { DomainEntity } from 'domain-objects';

/**
 * .what = a behavior assigned to an urgency bucket
 * .why = represents work segmented by temporal urgency
 *
 * note: dimensions = { readiness, bandwidth }
 * note: decision = min(readiness, bandwidth) where later < soon < now
 * note: triage is fully deterministic (no brain.repl)
 */
export interface BehaviorTriaged {
  /**
   * uuid of this triaged behavior (generated)
   */
  uuid?: string;

  /**
   * reference to the gathered behavior
   */
  behaviorRef: { repoPath: string; behaviorPath: string };

  /**
   * reference to the measurement
   */
  measurementRef: { behaviorRef: BehaviorTriaged['behaviorRef']; behaviorContentHash: string };

  /**
   * triage dimensions
   */
  dimensions: {
    /**
     * readiness = when this behavior can be started based on blockers
     *
     * note: "now" = unblocked, not paused
     * note: "soon" = blocked by behavior(s) with decision="now"
     * note: "later" = blocked by behavior(s) with decision="soon" or "later", or paused, or circular
     */
    readiness: 'now' | 'soon' | 'later';

    /**
     * bandwidth = when this behavior can be started based on resource constraints
     *
     * note: "now" = within maxConcurrency limit
     * note: "soon" = ready but over maxConcurrency limit
     * note: "later" = inherits from readiness if not "now"
     */
    bandwidth: 'now' | 'soon' | 'later';
  };

  /**
   * decision = min(readiness, bandwidth)
   *
   * note: later < soon < now (lower value wins)
   * note: e.g., readiness="now" + bandwidth="soon" => decision="soon"
   */
  decision: 'now' | 'soon' | 'later';

  /**
   * reason for decision assignment
   */
  decisionReason: string;

  /**
   * rank within decision bucket (lower = higher priority)
   */
  rankInDecision: number;

  /**
   * whether this behavior is blocked by dependencies
   */
  isBlocked: boolean;

  /**
   * behaviors blocking this one (if blocked)
   */
  blockedBy: Array<{ repoPath: string; behaviorPath: string }>;

  /**
   * timestamp when triaged
   */
  triagedAt: string;
}

export class BehaviorTriaged
  extends DomainEntity<BehaviorTriaged>
  implements BehaviorTriaged
{
  public static primary = ['uuid'] as const;
  public static unique = ['behaviorRef'] as const;
}
```

#### BehaviorWorkstream

```ts
import { DomainEntity } from 'domain-objects';

/**
 * .what = a parallel execution lane for coordinated work
 * .why = enables throughput maximization via parallelization
 */
export interface BehaviorWorkstream {
  /**
   * uuid of this stream (generated)
   */
  uuid?: string;

  /**
   * stream number (1-indexed)
   */
  streamNumber: number;

  /**
   * behaviors in this stream, ordered by dependency
   */
  behaviorsInOrder: Array<{
    behaviorRef: { repoPath: string; behaviorPath: string };
    priorityLevel: BehaviorPriority;
    position: number;
  }>;

  /**
   * whether this stream is currently blocked
   */
  isBlocked: boolean;

  /**
   * if blocked: which stream this is blocked on
   */
  blockedOnStreamNumber: null | number;

  /**
   * if blocked: which behavior this is blocked on
   */
  blockedOnBehaviorRef: null | { repoPath: string; behaviorPath: string };

  /**
   * highest priority level in this stream (for ordering)
   */
  highestPriority: BehaviorPriority;

  /**
   * sum of yieldage in this stream (for review ordering)
   */
  totalYieldage: number;

  /**
   * timestamp when coordinated
   */
  coordinatedAt: string;
}

export class BehaviorWorkstream
  extends DomainEntity<BehaviorWorkstream>
  implements BehaviorWorkstream
{
  public static primary = ['uuid'] as const;
  public static unique = ['streamNumber'] as const;
  public static nested = {
    highestPriority: BehaviorPriority,
  };
}
```

---

### 3.2 literals (value objects, identity via all properties)

#### BehaviorMeasuredYieldage

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = effective gain measurement with probabilistic distribution
 * .why = quantifies what work produces (direct + dependent) with uncertainty
 *
 * note: yieldageDistribution models uncertain yields as { yieldage, probability }[]
 * note: failure probability is captured as { yieldage: 0, probability: P }
 * note: deterministic yield is a degenerate case: [{ yieldage: X, probability: 1.0 }]
 */
export interface BehaviorMeasuredYieldage {
  /**
   * direct yieldage of this behavior alone (expected value)
   */
  direct: number;

  /**
   * dependent/transitive yieldage from behaviors this unblocks (expected value)
   */
  dependent: number;

  /**
   * probabilistic yield distribution for direct yieldage
   *
   * note: each entry = { yieldage, probability }
   * note: probabilities must sum to 1.0
   * note: failure = { yieldage: 0, probability: P }
   * note: deterministic = [{ yieldage: X, probability: 1.0 }]
   */
  distribution: Array<{
    yieldage: number;
    probability: number;
  }>;

  /**
   * expected yieldage = sum of (yieldage × probability) for each entry in distribution
   *
   * note: this is the weighted average across all possible outcomes
   * note: used as the primary score for prioritization
   */
  expected: number;

  /**
   * total = expected + dependent
   *
   * note: dependent yieldage is added after expected value calculation
   */
  total: number;
}

export class BehaviorMeasuredYieldage
  extends DomainLiteral<BehaviorMeasuredYieldage>
  implements BehaviorMeasuredYieldage {}
```

#### BehaviorMeasuredLeverage

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = efficiency gain measurement
 * .why = quantifies how work makes future work faster/cheaper
 */
export interface BehaviorMeasuredLeverage {
  /**
   * reduction in cost for future work
   */
  costReduction: number;

  /**
   * increase in speed for future work
   */
  speedIncrease: number;

  /**
   * reduction in maintenance burden
   */
  maintenanceReduction: number;

  /**
   * total = costReduction + speedIncrease + maintenanceReduction
   */
  total: number;
}

export class BehaviorMeasuredLeverage
  extends DomainLiteral<BehaviorMeasuredLeverage>
  implements BehaviorMeasuredLeverage {}
```

#### BehaviorMeasuredCost

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = multi-dimensional expenditure measurement
 * .why = quantifies resources required for work
 */
export interface BehaviorMeasuredCost {
  /**
   * time cost (person-days or similar)
   */
  time: number;

  /**
   * money cost (dollars or similar)
   */
  money: number;

  /**
   * trust cost (relationship capital)
   */
  trust: number;

  /**
   * focus cost (attention/context-switching)
   */
  focus: number;

  /**
   * skill cost (expertise required)
   */
  skill: number;

  /**
   * trade cost (opportunity cost of alternatives)
   */
  trade: number;

  /**
   * repute cost (reputation risk)
   */
  repute: number;

  /**
   * total = weighted sum (default: simple sum)
   */
  total: number;
}

export class BehaviorMeasuredCost
  extends DomainLiteral<BehaviorMeasuredCost>
  implements BehaviorMeasuredCost {}
```

#### BehaviorMeasurementCriteria

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = criteria for measuring behaviors
 * .why = enables configurable measurement
 */
export interface BehaviorMeasurementCriteria {
  /**
   * weights for yieldage calculation
   */
  yieldageWeights: {
    directWeight: number;
    dependentWeight: number;
  };

  /**
   * weights for leverage calculation
   */
  leverageWeights: {
    costReductionWeight: number;
    speedIncreaseWeight: number;
    maintenanceReductionWeight: number;
  };

  /**
   * weights for cost calculation
   */
  costWeights: {
    timeWeight: number;
    moneyWeight: number;
    trustWeight: number;
    focusWeight: number;
    skillWeight: number;
    tradeWeight: number;
    reputeWeight: number;
  };

  /**
   * thresholds for urgency bucket assignment
   */
  urgencyThresholds: {
    nowMinScore: number;
    soonMinScore: number;
  };
}

export class BehaviorMeasurementCriteria
  extends DomainLiteral<BehaviorMeasurementCriteria>
  implements BehaviorMeasurementCriteria {}
```

#### BehaviorPriority

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = urgency classification
 * .why = enables rapid assessment of importance
 *
 * note: only odd numbers are valid (p0, p1, p3, p5)
 */
export interface BehaviorPriority {
  /**
   * numeric level (0, 1, 3, 5)
   */
  level: 0 | 1 | 3 | 5;

  /**
   * semantic label
   */
  label: 'critical' | 'important' | 'desired' | 'bonus';
}

export class BehaviorPriority
  extends DomainLiteral<BehaviorPriority>
  implements BehaviorPriority {}
```

#### BehaviorWorkstreamBottleneck

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = a convergence point where streams block on each other
 * .why = makes bottlenecks visible
 */
export interface BehaviorWorkstreamBottleneck {
  /**
   * stream numbers that converge at this point
   */
  convergingStreamNumbers: number[];

  /**
   * the behavior that is the bottleneck
   */
  blockerBehaviorRef: { repoPath: string; behaviorPath: string };

  /**
   * estimated time until blocker resolves (if computable)
   */
  estimatedUnblockTime: null | string;
}

export class BehaviorWorkstreamBottleneck
  extends DomainLiteral<BehaviorWorkstreamBottleneck>
  implements BehaviorWorkstreamBottleneck {}
```

#### BehaviorContentHash

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = cache invalidation key via efficient stat-based detection
 * .why = enables content-addressed caching without reading file contents
 *
 * note: uses unix native stat metadata (mtime, size, inode) first
 * note: only reads file contents if stat metadata changed
 * note: leverages git ls-tree for git-tracked directories
 */
export interface BehaviorContentHash {
  /**
   * hash algorithm used
   */
  algorithm: 'stat+sha256';

  /**
   * the hash value (composite of stat metadata or full content hash)
   */
  value: string;

  /**
   * whether hash was computed from stat metadata only (fast path)
   * or required full content read (slow path)
   */
  mode: 'stat' | 'content';

  /**
   * files included in the hash
   */
  filesHashed: string[];

  /**
   * stat metadata used for fast-path detection
   * note: array of {path, mtime, size, inode} per file
   */
  statMetadata: Array<{
    path: string;
    mtime: number;
    size: number;
    inode: number;
  }>;
}

export class BehaviorContentHash
  extends DomainLiteral<BehaviorContentHash>
  implements BehaviorContentHash {}
```

#### BehaviorResourceConstraints

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = constraints on available resources
 * .why = enables resource-constrained scheduling
 */
export interface BehaviorResourceConstraints {
  /**
   * maximum number of parallel streams (e.g., human reviewers)
   */
  maxParallelStreams: number;

  /**
   * maximum behaviors in "now" urgency bucket (WIP limit)
   */
  maxBehaviorsInNow: number;
}

export class BehaviorResourceConstraints
  extends DomainLiteral<BehaviorResourceConstraints>
  implements BehaviorResourceConstraints {}
```

---

### 3.3 events (temporal facts, immutable)

#### BehaviorGatheredEvent

```ts
import { DomainEvent } from 'domain-objects';

/**
 * .what = emitted when a behavior is discovered
 */
export interface BehaviorGatheredEvent {
  behaviorRef: { repoPath: string; behaviorPath: string };
  sourceRef: { type: BehaviorSource['type']; path: string };
  gatheredAt: string;
}

export class BehaviorGatheredEvent
  extends DomainEvent<BehaviorGatheredEvent>
  implements BehaviorGatheredEvent
{
  public static unique = ['behaviorRef', 'gatheredAt'] as const;
}
```

#### BehaviorDeptracedEvent

```ts
import { DomainEvent } from 'domain-objects';

/**
 * .what = emitted when dependency trace completes for a behavior
 *
 * note: only tracks dependsOn* (not dependedBy*)
 */
export interface BehaviorDeptracedEvent {
  behaviorRef: { repoPath: string; behaviorPath: string };
  dependsOnDirectCount: number;
  dependsOnTransitiveCount: number;
  deptracedAt: string;
}

export class BehaviorDeptracedEvent
  extends DomainEvent<BehaviorDeptracedEvent>
  implements BehaviorDeptracedEvent
{
  public static unique = ['behaviorRef', 'deptracedAt'] as const;
}
```

#### BehaviorMeasuredEvent

```ts
import { DomainEvent } from 'domain-objects';

/**
 * .what = emitted when measurement completes for a behavior
 */
export interface BehaviorMeasuredEvent {
  behaviorRef: { repoPath: string; behaviorPath: string };
  measurementRef: { behaviorRef: object; behaviorContentHash: string };
  measuredAt: string;
}

export class BehaviorMeasuredEvent
  extends DomainEvent<BehaviorMeasuredEvent>
  implements BehaviorMeasuredEvent
{
  public static unique = ['behaviorRef', 'measuredAt'] as const;
}
```

#### BehaviorTriagedEvent

```ts
import { DomainEvent } from 'domain-objects';

/**
 * .what = emitted when a behavior is assigned to an urgency bucket
 */
export interface BehaviorTriagedEvent {
  behaviorRef: { repoPath: string; behaviorPath: string };
  urgency: 'now' | 'soon' | 'later';
  rankInUrgency: number;
  triagedAt: string;
}

export class BehaviorTriagedEvent
  extends DomainEvent<BehaviorTriagedEvent>
  implements BehaviorTriagedEvent
{
  public static unique = ['behaviorRef', 'triagedAt'] as const;
}
```

#### BehaviorWorkstreamCoordinatedEvent

```ts
import { DomainEvent } from 'domain-objects';

/**
 * .what = emitted when streams are coordinated
 */
export interface BehaviorWorkstreamCoordinatedEvent {
  streamCount: number;
  bottleneckCount: number;
  coordinatedAt: string;
}

export class BehaviorWorkstreamCoordinatedEvent
  extends DomainEvent<BehaviorWorkstreamCoordinatedEvent>
  implements BehaviorWorkstreamCoordinatedEvent
{
  public static unique = ['coordinatedAt'] as const;
}
```

---

## 4. domain.operations

### 4.1 gather skill operations

```
src/domain.operations/dispatch/gather/
├── scanLocalSources.ts          # discovers behaviors in local git repos
├── scanRemoteSources.ts         # discovers behaviors from remote repos/orgs
├── parseDispatchYml.ts          # parses rhachet.dispatch.yml config
├── parseBehaviorDocs.ts         # extracts wish/vision/criteria from behavior dir
├── computeContentHashEfficient.ts # stat-based hash (avoids reading unchanged files)
├── filterCompletedBehaviors.ts  # excludes behaviors with status=done
├── gatherBehaviors.ts           # orchestrates gather phase (entry point)
└── saveGatheredBehaviors.ts     # persists gathered output
```

#### computeContentHashEfficient.ts

```ts
/**
 * .what = computes content hash using efficient stat-based detection
 * .why = avoids reading file contents when metadata unchanged
 *
 * note: uses unix native stat (mtime, size, inode) for fast-path
 * note: leverages git ls-tree for git-tracked directories
 * note: only reads file contents if stat metadata changed
 */
export const computeContentHashEfficient: (
  input: {
    path: string;
    previousHash: BehaviorContentHash | null;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  hash: BehaviorContentHash;
  changed: boolean;
}>;
```

#### gatherBehaviors.ts (entry point)

```ts
/**
 * .what = orchestrates the gather skill
 * .why = discovers all behaviors from configured sources
 */
export const gatherBehaviors: (
  input: {
    dispatchYmlPath: string;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  behaviors: BehaviorGathered[];
  sources: BehaviorSource[];
}>;
```

### 4.2 deptrace skill operations

```
src/domain.operations/dispatch/deptrace/
├── resolveDependencyRefs.ts     # resolves behavior names to refs
├── computeTransitiveDeps.ts     # computes transitive closure
├── deptraceOneBehavior.ts       # deptraces a single behavior (parallelizable)
├── deptraceBehaviors.ts         # orchestrates deptrace skill (entry point)
├── saveDeptracedBehaviors.ts    # persists deptraced output
└── renderDependenciesMd.ts      # renders dependencies.md (dependency tree)
```

note: deptrace does not compute reverse dependencies (dependedBy*). reverse dependencies are computed at measure time via graph inversion when calculating dependent yieldage.

#### deptraceBehaviors.ts (entry point)

```ts
/**
 * .what = orchestrates the deptrace skill
 * .why = identifies dependencies for all gathered behaviors
 */
export const deptraceBehaviors: (
  input: {
    behaviors: BehaviorGathered[];
    parallelism: number;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  deptraced: BehaviorDeptraced[];
}>;
```

### 4.3 prioritize skill operations

#### 4.3.1 measure phase

```
src/domain.operations/dispatch/measure/
├── computeReverseDeps.ts        # inverts dependency graph (who depends on this?)
├── measureYieldage.ts           # calculates effective gain (direct + dependent)
├── measureLeverage.ts           # calculates efficiency gain
├── measureCost.ts               # calculates multi-dimensional cost
├── computeDecision.ts           # computes decision = yieldage.expected / cost.total
├── assignPriority.ts            # assigns p0/p1/p3/p5 based on dimensions
├── measureOneBehavior.ts        # measures a single behavior (parallelizable)
└── measureBehaviors.ts          # orchestrates measure phase (entry point)
```

note: computeReverseDeps inverts the deptrace graph to find what depends on each behavior. this enables dependent yieldage calculation.

#### measureBehaviors.ts (entry point)

```ts
/**
 * .what = orchestrates the measure phase of prioritize skill
 * .why = scores each behavior for prioritization
 *
 * note: depends on deptrace output to calculate dependent yieldage
 */
export const measureBehaviors: (
  input: {
    behaviors: BehaviorGathered[];
    deptraced: BehaviorDeptraced[];
    criteria: BehaviorMeasurementCriteria;
    parallelism: number;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  measured: BehaviorMeasured[];
}>;
```

#### 4.3.2 triage phase

```
src/domain.operations/dispatch/triage/
├── computeReadiness.ts          # determines readiness dimension (now/soon/later based on blockers)
├── computeBandwidth.ts          # determines bandwidth dimension (now/soon/later based on maxConcurrency)
├── computeDecision.ts           # computes decision = min(readiness, bandwidth)
├── identifyBlockedBehaviors.ts  # finds behaviors with unresolved deps
├── rankWithinDecision.ts        # assigns rank within each decision bucket
└── triageBehaviors.ts           # orchestrates triage phase (entry point)
```

note: triage is fully deterministic (no brain.repl). fast enough to not need caching.

#### triageBehaviors.ts (entry point)

```ts
/**
 * .what = orchestrates the triage phase of prioritize skill
 * .why = assigns each behavior to now/soon/later bucket
 *
 * note: triage is fully deterministic (no brain.repl)
 * note: dimensions = { readiness, bandwidth }
 * note: decision = min(readiness, bandwidth)
 */
export const triageBehaviors: (
  input: {
    behaviors: BehaviorGathered[];
    measured: BehaviorMeasured[];
    deptraced: BehaviorDeptraced[];
    maxConcurrency: number;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  triaged: BehaviorTriaged[];
  byDecision: {
    now: BehaviorTriaged[];
    soon: BehaviorTriaged[];
    later: BehaviorTriaged[];
  };
}>;
```

### 4.4 coordinate skill operations

```
src/domain.operations/dispatch/coordinate/
├── assignBehaviorsToWorkstreams.ts  # partitions into parallel lanes
├── orderByDependency.ts             # topological sort within stream
├── assignPriorityLevel.ts           # assigns p0/p1/p3/p5 labels
├── detectWorkstreamBottlenecks.ts   # finds convergence points
├── rankWorkstreamsByReviewPriority.ts # ranks streams for human review
└── coordinateWorkstreams.ts         # orchestrates coordinate phase (entry point)
```

#### coordinateWorkstreams.ts (entry point)

```ts
/**
 * .what = orchestrates the coordinate skill
 * .why = groups behaviors into parallel streams with priorities
 */
export const coordinateWorkstreams: (
  input: {
    triaged: BehaviorTriaged[];
    deptraced: BehaviorDeptraced[];
    resourceConstraints: BehaviorResourceConstraints;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  workstreams: BehaviorWorkstream[];
  bottlenecks: BehaviorWorkstreamBottleneck[];
}>;
```

### 4.5 output operations

```
src/domain.operations/dispatch/output/
├── findsertDispatchDir.ts           # creates output dir + readme.md (idempotent)
├── renderGatheredJson.ts            # renders gathered.json
├── renderPrioritizationMd.ts        # renders prioritization.md
├── renderPrioritizationJson.ts      # renders prioritization.json
├── renderCoordinationMd.ts          # renders coordination.md
├── renderCoordinationJson.ts        # renders coordination.json
├── saveGatheredBehaviors.ts         # writes gathered files
├── savePrioritizationDecisions.ts   # writes prioritization files
└── saveCoordinationDecisions.ts     # writes coordination files
```

#### findsertDispatchDir.ts

```ts
/**
 * .what = creates output directory and readme.md if they don't exist
 * .why = ensures output structure is initialized before any skill writes
 *
 * note: idempotent - safe to call multiple times
 * note: called by all skills before writing output
 */
export const findsertDispatchDir: (
  input: {
    outputDir: string;
  },
  context: BhuildDispatcherContext,
) => Promise<{
  created: boolean;
  readmePath: string;
}>;
```

### 4.6 skill entry points

```
src/domain.operations/dispatch/skills/
├── gather.ts                    # npx rhachet run --skill gather
├── deptrace.ts                  # npx rhachet run --skill deptrace
├── prioritize.ts                # npx rhachet run --skill prioritize
└── coordinate.ts                # npx rhachet run --skill coordinate
```

#### gather.ts

```ts
/**
 * .what = entry point for gather skill
 * .why = discovers behaviors and outputs to .dispatch/.gathered/
 *
 * note: calls findsertDispatchDir before writing output
 */
export const gather: (
  input: {
    source: string;  // path to rhachet.dispatch.yml
    output: string;  // path to output directory
  },
  context: BhuildDispatcherContext,
) => Promise<{
  gatheredJsonPath: string;
  behaviorCount: number;
}>;
```

#### deptrace.ts

```ts
/**
 * .what = entry point for deptrace skill
 * .why = identifies dependency graphs and outputs to .dispatch/.deptraced/
 *
 * note: expects gathered output at {input}/.gathered/gathered.json
 * note: produces dependencies.md with human-readable dependency tree
 * note: calls findsertDispatchDir before writing output
 */
export const deptrace: (
  input: {
    input: string;   // path to gathered output directory
    output: string;  // path to output directory
  },
  context: BhuildDispatcherContext,
) => Promise<{
  deptracedJsonPath: string;
  dependenciesMdPath: string;
  behaviorCount: number;
}>;
```

#### prioritize.ts

```ts
/**
 * .what = entry point for prioritize skill
 * .why = orchestrates measure → triage → output
 *
 * note: expects gathered output at {input}/.gathered/gathered.json
 * note: expects deptraced output at {input}/.deptraced/deptraced.json
 * note: calls findsertDispatchDir before writing output
 */
export const prioritize: (
  input: {
    input: string;   // path to gathered+deptraced output directory
    output: string;  // path to output directory
  },
  context: BhuildDispatcherContext,
) => Promise<{
  prioritizationMdPath: string;
  prioritizationJsonPath: string;
  behaviorCount: number;
  byDecision: { now: number; soon: number; later: number };
}>;
```

#### coordinate.ts

```ts
/**
 * .what = entry point for coordinate skill
 * .why = orchestrates stream grouping → bottleneck detection → output
 *
 * note: expects prioritization output at {input}/prioritization.json
 * note: calls findsertDispatchDir before writing output
 */
export const coordinate: (
  input: {
    input: string;   // path to prioritization output directory
    output: string;  // path to output directory
  },
  context: BhuildDispatcherContext,
) => Promise<{
  coordinationMdPath: string;
  coordinationJsonPath: string;
  streamCount: number;
  bottleneckCount: number;
}>;
```

---

## 5. access.daos

### 5.1 cache dao (via simple-on-disk-cache)

```
src/access/daos/dispatchCache/
├── index.ts                     # exports dao interface
├── getBehaviorGathered.ts       # retrieves cached gathered behavior
├── setBehaviorGathered.ts       # caches gathered behavior
├── getBehaviorDeptraced.ts      # retrieves cached deptrace
├── setBehaviorDeptraced.ts      # caches deptrace
├── getBehaviorMeasured.ts       # retrieves cached measurement
├── setBehaviorMeasured.ts       # caches measurement
└── invalidateByContentHash.ts   # invalidates stale cache entries
```

#### index.ts

```ts
/**
 * .what = cache dao for dispatcher artifacts
 * .why = enables content-addressed caching via with-simple-cache
 */
export const daoDispatchCache = {
  /**
   * get cached gathered behavior by content hash
   */
  getBehaviorGathered: (
    input: { contentHash: string },
    context: BhuildDispatcherContext,
  ) => Promise<BehaviorGathered | null>,

  /**
   * cache a gathered behavior
   */
  setBehaviorGathered: (
    input: { behavior: BehaviorGathered },
    context: BhuildDispatcherContext,
  ) => Promise<void>,

  /**
   * get cached deptrace by behavior content hash
   */
  getBehaviorDeptraced: (
    input: { behaviorContentHash: string },
    context: BhuildDispatcherContext,
  ) => Promise<BehaviorDeptraced | null>,

  /**
   * cache a deptrace
   */
  setBehaviorDeptraced: (
    input: { deptraced: BehaviorDeptraced },
    context: BhuildDispatcherContext,
  ) => Promise<void>,

  /**
   * get cached measurement by behavior content hash
   */
  getBehaviorMeasured: (
    input: { behaviorContentHash: string },
    context: BhuildDispatcherContext,
  ) => Promise<BehaviorMeasured | null>,

  /**
   * cache a measurement
   */
  setBehaviorMeasured: (
    input: { measured: BehaviorMeasured },
    context: BhuildDispatcherContext,
  ) => Promise<void>,
};
```

### 5.2 source dao (for dispatch.yml config)

```
src/access/daos/dispatchSource/
├── index.ts                     # exports dao interface
├── parseFromYml.ts              # parses sources from rhachet.dispatch.yml
└── validateSource.ts            # validates source configuration
```

---

## 6. directory structure summary

```
src/
├── domain.objects/
│   └── dispatch/
│       ├── BehaviorSource.ts
│       ├── BehaviorGathered.ts
│       ├── BehaviorDeptraced.ts
│       ├── BehaviorMeasured.ts
│       ├── BehaviorMeasuredYieldage.ts
│       ├── BehaviorMeasuredLeverage.ts
│       ├── BehaviorMeasuredCost.ts
│       ├── BehaviorMeasurementCriteria.ts
│       ├── BehaviorTriaged.ts
│       ├── BehaviorWorkstream.ts
│       ├── BehaviorWorkstreamBottleneck.ts
│       ├── BehaviorPriority.ts
│       ├── BehaviorContentHash.ts
│       ├── BehaviorResourceConstraints.ts
│       └── events/
│           ├── BehaviorGatheredEvent.ts
│           ├── BehaviorDeptracedEvent.ts
│           ├── BehaviorMeasuredEvent.ts
│           ├── BehaviorTriagedEvent.ts
│           └── BehaviorWorkstreamCoordinatedEvent.ts
│
├── domain.operations/
│   └── dispatch/
│       ├── gather/
│       ├── deptrace/
│       ├── measure/
│       ├── triage/
│       ├── coordinate/
│       ├── output/
│       └── skills/
│           ├── gather.ts
│           ├── deptrace.ts
│           ├── prioritize.ts
│           └── coordinate.ts
│
├── access/
│   └── daos/
│       ├── dispatchCache/
│       └── dispatchSource/
│
└── domain.roles/
    └── dispatcher/
        ├── briefs/
        └── skills/
            ├── gather/
            │   ├── gather.sh
            │   └── gather.ts
            ├── deptrace/
            │   ├── deptrace.sh
            │   └── deptrace.ts
            ├── prioritize/
            │   ├── prioritize.sh
            │   └── prioritize.ts
            └── coordinate/
                ├── coordinate.sh
                └── coordinate.ts
```

---

## 7. key design decisions

### 7.1 cache via content hash

per criteria usecase.10.1 and usecase.11.1:
- all gather, deptrace, and measure results are cached by content hash
- cache is implemented via `with-simple-cache` + `simple-on-disk-cache`
- stale entries are detected by comparing content hash to current file hash
- cache is invisible to contracts (implementation detail)

### 7.2 parallel processing

per criteria usecase.11.2:
- deptrace and measure are decomposed per behavior
- `deptraceOneBehavior` and `measureOneBehavior` are parallelizable
- parallelism is configurable via input parameter
- contracts make parallelizability explicit

### 7.3 deterministic vs probabilistic

per criteria usecase.4.3:
- gather skill = fully deterministic
- deptrace skill = fully deterministic
- prioritize skill:
  - measure phase = probabilistic (invokes brain.repl for scoring)
  - triage phase = deterministic (given measurements)
- coordinate skill = deterministic (given triage results)

### 7.4 skill output contracts

per criteria scope.3-5:
- each skill writes to a distinct output directory
- `.gathered/` → `.deptraced/` → `.prioritized/` → `.coordinated/`
- each skill output is inspectable and reproducible
- prioritize internally runs measure → triage phases, outputs combined result

### 7.5 odd priority levels only

per criteria usecase.6.2:
- only p0, p1, p3, p5 are valid
- p0 = critical (blocker with no workaround)
- p1 = important (required work)
- p3 = desired (wanted but non-blocker)
- p5 = bonus (stretch goal)

### 7.6 single context pattern

all operations use `BhuildDispatcherContext`:
- reduces context fragmentation across operations
- promotes consistent dependency injection
- simplifies testing (one context to mock)
- enables easy addition of new context dependencies

### 7.7 NounAdj treestruct naming

all domain objects follow `$noun.$adj` namespace pattern:
- `Behavior*` prefix groups all behavior-related objects
- `BehaviorMeasured*` prefix groups measurement sub-types
- `BehaviorWorkstream*` prefix groups stream sub-types
- enables IDE autocomplete grouping and alphasort symmetry

### 7.8 skill decomposition

per blocker.8 feedback (extended):
- gather is a standalone skill, outputs to `.gathered/`
- deptrace is a standalone skill, consumes gathered output, outputs to `.deptraced/`
- prioritize consumes gathered + deptraced output, outputs to `.prioritized/`
- coordinate consumes prioritization output, outputs to `.coordinated/`
- each skill has clear input/output contracts
- skill pipeline: gather → deptrace → prioritize → coordinate

### 7.9 deptrace before measure

per blocker.1 feedback:
- deptrace identifies dependency graphs
- measure uses dependency graphs to compute dependent yieldage
- separation enables independent caching and parallelism

### 7.10 deptrace only tracks dependsOn* (not dependedBy*)

per criteria usecase.4.2:
- deptrace produces dependsOnDirect and dependsOnTransitive only
- reverse dependencies (what depends on this) are computed at measure time
- graph inversion during measure enables dependent yieldage calculation
- simplifies deptrace caching (each behavior's deptrace is self-contained)

### 7.11 yieldageDistribution for probabilistic yields

per criteria usecase.5.4:
- yieldageDistribution models uncertain yields as { yieldage, probability }[]
- failure probability is captured as { yieldage: 0, probability: P }
- yieldageExpected = weighted sum of all distribution entries
- deterministic yield is degenerate case: [{ yieldage: X, probability: 1.0 }]

### 7.12 triage is fully deterministic

per criteria usecase.6.6:
- triage uses dimensions = { readiness, bandwidth }
- decision = min(readiness, bandwidth)
- no brain.repl invocation during triage
- triage is fast enough to not need caching

### 7.13 contentHash computed at gather time only

per criteria usecase.12.2:
- contentHash is computed once during gather
- stored in .gathered.json for each behavior
- downstream skills (deptrace, measure) read from .gathered.json
- no recomputation of hash after gather phase

### 7.14 findsertDispatchDir for output initialization

per criteria usecase.11.1:
- findsertDispatchDir creates output directory if it doesn't exist
- creates readme.md explaining cache behavior and output structure
- called by all skills before writing output
- idempotent (no-op if directory and readme already exist)

### 7.15 interactive mode is out of scope

per criteria usecase.10.2:
- interactive mode for hand-tuning is explicitly out of scope
- users can manually edit output files (coordination.json, etc.) for overrides
- coordinate skill respects manual edits when re-run
