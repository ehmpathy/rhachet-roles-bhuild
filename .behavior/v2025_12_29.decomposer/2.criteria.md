# usecase.1 = review skill detects when decomposition is needed

given('a behavior directory with wish, criteria, and research artifacts')
  when('review.decomposition skill is invoked')
    then('skill measures token count of criteria + research + distill docs')
      sothat('context window pressure is quantified')
    then('skill analyzes domain breadth across research artifacts')
      sothat('bounded context violations are detected')

given('a behavior where criteria + research + distill exceeds 30% of context window')
  when('reviewed for decomposition need')
    then('feedback flags as hazard: "behavior artifacts consume >30% context window"')
    then('feedback recommends decomposition to enable focused execution')
      sothat('builders have 70%+ headroom for overhead and thought and execution')

given('a behavior with research spanning multiple distinct domains')
  when('reviewed for decomposition need')
    then('feedback flags as hazard: "multiple bounded contexts detected in research"')
    then('feedback identifies which domains could become separate sub-behaviors')
      sothat('separation of concerns is enforced')

given('a behavior where criteria + research + distill is under 30% of context window')
  when('reviewed for decomposition need')
    then('feedback confirms no decomposition needed')
    then('feedback reports actual context consumption percentage')
      sothat('builders proceed with confidence and awareness')


# usecase.2 = decompose --mode plan proposes sub-behaviors

given('a behavior that needs decomposition')
  when('decompose skill is invoked with --mode plan')
    then('skill analyzes criteria for natural boundaries')
      sothat('decomposition follows domain structure')
    then('skill proposes sub-behavior names based on domain concepts')
      sothat('naming is consistent with ubiquitous language')
    then('skill identifies dependencies between proposed sub-behaviors')
      sothat('execution order is clear')

given('a behavior with independent usecases')
  when('decompose --mode plan is invoked')
    then('proposed sub-behaviors have minimum dependencies on each other')
      sothat('parallelism is maximized and throughput is optimized')

given('a behavior with sequential usecases')
  when('decompose --mode plan is invoked')
    then('proposed sub-behaviors declare explicit dependency order')
      sothat('builders know which to implement first')

given('a behavior with shared concepts across usecases')
  when('decompose --mode plan is invoked')
    then('shared concepts are identified as candidates for shared contracts')
      sothat('composability and reuse are maximized')

given('decompose --mode plan output')
  when('plan is emitted')
    then('output includes proposed sub-behavior names')
    then('output includes which criteria usecases map to which sub-behavior')
    then('output includes dependency graph between sub-behaviors')
    then('output includes identified shared contracts')
      sothat('plan is actionable and reviewable')


# usecase.3 = decompose --mode apply creates sub-behaviors

given('a decomposition plan file produced by --mode plan')
  when('decompose skill is invoked with --mode apply --plan {plan-file}')
    then('each proposed sub-behavior gets init.behavior invoked')
      sothat('sub-behavior directories are created with standard structure')
    then('sub-behavior directories are named per the plan')
      sothat('naming is consistent with the approved plan')

given('--mode apply invoked without --plan flag')
  when('skill is invoked')
    then('skill fails fast with error: "--plan required, produce one via --mode plan"')
      sothat('decomposition is always deliberate and reviewed')

given('--mode apply invoked with --plan pointing to non-existent file')
  when('skill is invoked')
    then('skill fails fast with error: "plan file not found"')
      sothat('typos and missing plans are caught immediately')

given('a behavior with 0.wish.md')
  when('decompose --mode apply is invoked')
    then('wish content is decomposed into each sub-behavior 0.wish.md')
      sothat('each sub-behavior has its scoped wish')

given('a behavior with 1.vision.md that has content')
  when('decompose --mode apply is invoked')
    then('vision content is decomposed into each sub-behavior 1.vision.md')
      sothat('vision guidance carries forward')

given('a behavior with empty 1.vision.md')
  when('decompose --mode apply is invoked')
    then('sub-behaviors get empty 1.vision.md files')
      sothat('structure is preserved but no content is forced')

given('a behavior with 2.criteria.md')
  when('decompose --mode apply is invoked')
    then('criteria is NOT copied to sub-behaviors')
    then('sub-behaviors get template 2.criteria.md for regeneration')
      sothat('criteria are re-derived fresh from decomposed wish/vision')

given('a behavior with research files (3.1.research.*.md)')
  when('decompose --mode apply is invoked')
    then('research files are NOT copied to sub-behaviors')
      sothat('research is re-conducted for new scope')

given('a behavior with blueprint files (3.3.blueprint.*.md)')
  when('decompose --mode apply is invoked')
    then('blueprint files are NOT copied to sub-behaviors')
      sothat('blueprints are re-derived from new criteria')

given('a behavior with roadmap files (4.1.roadmap.*.md)')
  when('decompose --mode apply is invoked')
    then('roadmap files are NOT copied to sub-behaviors')
      sothat('roadmaps are re-planned for new scope')


# usecase.4 = z.decomposed.md reference is created

given('decompose --mode apply completes successfully')
  when('sub-behaviors are created')
    then('z.decomposed.md is created in the parent behavior directory')
      sothat('future travelers know this behavior was decomposed')

given('z.decomposed.md content')
  when('file is written')
    then('file lists all sub-behaviors that were created')
    then('file includes timestamp of decomposition')
    then('file includes which sub-behavior owns which original usecases')
    then('file includes dependency graph between sub-behaviors')
      sothat('decomposition is traceable and reversible')


# usecase.5 = skill invocation interface

given('rhachet cli')
  when('npx rhachet run --repo bhuild --skill review.decomposition --for.behavior {name}')
    then('review skill executes for the specified behavior')
      sothat('invocation is consistent with rhachet conventions')

given('rhachet cli')
  when('npx rhachet run --repo bhuild --skill decompose --for.behavior {name} --mode plan')
    then('decompose skill runs in plan mode')
      sothat('decomposition can be reviewed before applying')

given('rhachet cli')
  when('npx rhachet run --repo bhuild --skill decompose --for.behavior {name} --mode apply --plan {plan-file}')
    then('decompose skill runs in apply mode with the specified plan')
      sothat('approved plan is executed')

given('missing required flag --for.behavior')
  when('skill is invoked')
    then('skill fails fast with usage guidance')
      sothat('user knows what arguments are required')

given('--for.behavior matches zero behaviors')
  when('skill is invoked')
    then('skill fails fast with clear error')
      sothat('user knows to check behavior name')

given('--for.behavior matches multiple behaviors')
  when('skill is invoked')
    then('skill fails fast listing ambiguous matches')
      sothat('user can disambiguate')


# usecase.6 = boundary: behavior without criteria

given('a behavior with only 0.wish.md (no criteria)')
  when('review.decomposition is invoked')
    then('skill fails fast: "criteria required for decomposition analysis"')
      sothat('decomposition is based on concrete requirements, not just wishes')

given('a behavior with only 0.wish.md')
  when('decompose --mode plan is invoked')
    then('skill fails fast: "criteria required for decomposition planning"')
      sothat('sub-behaviors can be properly scoped')


# usecase.7 = boundary: already-decomposed behavior

given('a behavior with existing z.decomposed.md')
  when('decompose --mode plan is invoked')
    then('skill warns: "behavior already decomposed"')
    then('skill shows existing sub-behaviors')
      sothat('duplicate decomposition is prevented')

given('a behavior with existing z.decomposed.md')
  when('decompose --mode apply is invoked')
    then('skill fails fast: "behavior already decomposed, remove z.decomposed.md to re-decompose"')
      sothat('accidental re-decomposition is prevented')


# usecase.8 = boundary: sub-behavior naming conflicts

given('decomposition plan with sub-behavior name that already exists')
  when('decompose --mode apply is invoked')
    then('skill fails fast: "sub-behavior {name} already exists"')
      sothat('existing behaviors are not overwritten')

given('decomposition plan reviewed')
  when('user wants to modify proposed names')
    then('plan file can be edited before --mode apply')
      sothat('users have control over final naming')


# usecase.9 = testability via integration test suite

given('src/domain.roles/behaver/skills/review.decomposition.integration.test.ts')
  when('test suite runs')
    then('tests invoke skill via subshell')
      sothat('skill is tested as users would invoke it')

given('src/domain.roles/behaver/skills/decompose.behavior.integration.test.ts')
  when('test suite runs')
    then('tests invoke skill via subshell')
      sothat('skill is tested as users would invoke it')

given('test suite with example.repo fixtures')
  when('fixture has behavior with many usecases')
    then('test proves review detects decomposition hazard')

given('test suite with example.repo fixtures')
  when('fixture has behavior with independent usecases')
    then('test proves plan proposes parallel sub-behaviors')

given('test suite with example.repo fixtures')
  when('fixture has behavior with sequential usecases')
    then('test proves plan includes dependency order')

given('test suite with example.repo fixtures')
  when('decompose --mode apply runs')
    then('test proves sub-behaviors are initialized')
    then('test proves wish is decomposed')
    then('test proves z.decomposed.md is created')
    then('test proves criteria/blueprint/roadmap are NOT copied')
