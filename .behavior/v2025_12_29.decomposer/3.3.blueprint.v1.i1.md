# blueprint: decomposer skills

## overview

implement two skills for the decomposer role ðŸ„ that enable behavior decomposition:

1. **review.decomposition** - analyzes behavior artifacts and flags when decomposition is needed
2. **decompose.behavior** - plans and applies decomposition into focused behaviors

### architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ contract/cli                                                        â”‚
â”‚   decompose.behavior.ts  â”€â”€â–¶ domain.operations                      â”‚
â”‚                               â”œâ”€â”€ compute*  (deterministic)         â”‚
â”‚                               â””â”€â”€ imagine*  (probabilistic)         â”‚
â”‚                                      â”‚                              â”‚
â”‚                                      â””â”€â”€â–¶ context.brain.repl.imagineâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²
         â”‚ dispatch
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ skills/                                                             â”‚
â”‚   decompose.behavior.sh  â”€â”€â–¶ npx tsx contract/cli/decompose...      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **shell skill** = thin dispatcher, argument parse only
- **contract/cli** = orchestrates domain operations, injects context with brain.repl
- **domain.operations** = two operation types:
  - `compute*` = deterministic computed work (token count, file I/O, validation)
  - `imagine*` = probabilistic creative work via `context.brain.repl.imagine({ role })`
- **context.brain.repl** = injected dependency for LLM invocation with role briefs

follows established patterns in:
- `src/domain.roles/behaver/skills/init.behavior.sh` - skill dispatch pattern (reference)
- `src/domain.operations/behavior/bind/` - domain operation structure
- `src/contract/cli/` - CLI entry point pattern


---

## file structure

```
src/
â”œâ”€â”€ contract/
â”‚   â””â”€â”€ cli/
â”‚       â”œâ”€â”€ decompose.behavior.ts                 # new: CLI entry point
â”‚       â””â”€â”€ review.decomposition.ts               # new: CLI entry point
â”‚
â”œâ”€â”€ domain.operations/
â”‚   â””â”€â”€ behavior/
â”‚       â””â”€â”€ decompose/
â”‚           â”œâ”€â”€ computeContextConsumption.ts      # deterministic: token count
â”‚           â”œâ”€â”€ computeContextConsumption.test.ts
â”‚           â”œâ”€â”€ imaginePlan.ts                    # probabilistic: generate plan via brain
â”‚           â”œâ”€â”€ imaginePlan.test.ts
â”‚           â”œâ”€â”€ computePlanFromFile.ts            # deterministic: parse plan file
â”‚           â”œâ”€â”€ computePlanFromFile.test.ts
â”‚           â”œâ”€â”€ applyPlan.ts                      # deterministic: execute decomposition
â”‚           â”œâ”€â”€ applyPlan.test.ts
â”‚           â””â”€â”€ applyPlan.integration.test.ts
â”‚
â”œâ”€â”€ domain.roles/
â”‚   â”œâ”€â”€ getRoleRegistry.ts                                    # update: add ROLE_DECOMPOSER
â”‚   â”œâ”€â”€ getRoleRegistry.readme.ts                             # update: add decomposer description
â”‚   â””â”€â”€ decomposer/                                           # new: ðŸ„ decomposer role
â”‚       â”œâ”€â”€ getDecomposerRole.ts                              # new: role definition
â”‚       â”œâ”€â”€ getDecomposerRole.readme.ts                       # new: role readme content
â”‚       â”œâ”€â”€ briefs/
â”‚       â”‚   â”œâ”€â”€ decompose/                                    # briefs for decompose skill
â”‚       â”‚   â”‚   â”œâ”€â”€ rule.require.contexts.bounded.md          # separation of concerns
â”‚       â”‚   â”‚   â”œâ”€â”€ rule.require.dependencies.directional.md  # dependency flow
â”‚       â”‚   â”‚   â”œâ”€â”€ rule.require.names.ubiquitous.md          # ubiquitous language
â”‚       â”‚   â”‚   â”œâ”€â”€ rule.require.wish.scoped.md               # wish decomposition
â”‚       â”‚   â”‚   â””â”€â”€ rule.require.vision.scoped.md             # vision decomposition
â”‚       â”‚   â”‚
â”‚       â”‚   â””â”€â”€ review/                                       # briefs for review skill
â”‚       â”‚       â”œâ”€â”€ rule.require.context.threshold.md         # 30% threshold
â”‚       â”‚       â””â”€â”€ rule.require.domain.bounded.md            # bounded context detection
â”‚       â”‚
â”‚       â””â”€â”€ skills/
â”‚           â”œâ”€â”€ decompose.behavior.sh             # new: thin dispatcher
â”‚           â”œâ”€â”€ decompose.behavior.integration.test.ts
â”‚           â”œâ”€â”€ review.decomposition.sh           # new: thin dispatcher
â”‚           â”œâ”€â”€ review.decomposition.integration.test.ts
â”‚           â””â”€â”€ .test/
â”‚               â””â”€â”€ assets/
â”‚                   â””â”€â”€ example.repo/
â”‚                       â”œâ”€â”€ valid-behavior/                   # fixture
â”‚                       â”œâ”€â”€ needs-decomposition/              # new: >30% context
â”‚                       â”‚   â””â”€â”€ .behavior/
â”‚                       â”‚       â””â”€â”€ v2025_01_01.large-feature/
â”‚                       â”‚           â”œâ”€â”€ 0.wish.md
â”‚                       â”‚           â”œâ”€â”€ 2.criteria.md
â”‚                       â”‚           â”œâ”€â”€ 3.1.research.domain._.v1.i1.md
â”‚                       â”‚           â””â”€â”€ 3.2.distill.domain._.v1.i1.md
â”‚                       â”œâ”€â”€ already-decomposed/               # new: has z.decomposed.md
â”‚                       â””â”€â”€ no-criteria/                      # new: no criteria
â”‚
â”œâ”€â”€ infra/
â”‚   â””â”€â”€ brain/
â”‚       â”œâ”€â”€ BrainReplContext.ts                   # new: context interface for DI
â”‚       â”œâ”€â”€ loadBriefs.ts                         # new: loads briefs from role dir
â”‚       â””â”€â”€ invokeBrainRepl.ts                    # new: brain.repl wrapper with briefs
â”‚
â””â”€â”€ domain.objects/
    â”œâ”€â”€ BehaviorPersisted.ts                              # new: behavior location
    â”œâ”€â”€ BehaviorDecompositionProposed.ts                  # new: proposed behavior in plan
    â”œâ”€â”€ BehaviorDecompositionPlan.ts                      # new: decomposition plan
    â””â”€â”€ BehaviorDecompositionContextAnalysis.ts           # new: context window analysis
```


---

## domain objects

### BehaviorPersisted

file: `src/domain.objects/BehaviorPersisted.ts`

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = a behavior that has been persisted to disk
 * .why = encapsulates where a behavior lives (path + name) as a cohesive domain concept
 */
interface BehaviorPersisted {
  /**
   * behavior name (e.g., "large-feature")
   */
  name: string;

  /**
   * absolute path to behavior directory
   */
  path: string;
}
class BehaviorPersisted
  extends DomainLiteral<BehaviorPersisted>
  implements BehaviorPersisted {}

export { BehaviorPersisted };
```

### BehaviorDecompositionProposed

file: `src/domain.objects/BehaviorDecompositionProposed.ts`

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = a proposed behavior within a decomposition plan
 * .why = captures the decomposed scope for a single behavior
 */
interface BehaviorDecompositionProposed {
  /**
   * proposed name for behavior directory
   */
  name: string;

  /**
   * behaviors this one depends on (by name)
   */
  dependsOn: string[];

  /**
   * decomposed content from parent behavior
   */
  decomposed: {
    /**
     * decomposed wish content
     */
    wish: string;

    /**
     * decomposed vision content (null if source vision was empty)
     */
    vision: string | null;
  };
}
class BehaviorDecompositionProposed
  extends DomainLiteral<BehaviorDecompositionProposed>
  implements BehaviorDecompositionProposed {}

export { BehaviorDecompositionProposed };
```

### BehaviorDecompositionContextAnalysis

file: `src/domain.objects/BehaviorDecompositionContextAnalysis.ts`

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = context window consumption analysis for behavior decomposition
 * .why = quantifies whether decomposition is needed based on artifact size
 */
interface BehaviorDecompositionContextAnalysis {
  usage: {
    characters: { quantity: number };
    tokens: { estimate: number };
    window: { percentage: number };
  };
  recommendation: 'DECOMPOSE_REQUIRED' | 'DECOMPOSE_UNNEEDED';
}
class BehaviorDecompositionContextAnalysis
  extends DomainLiteral<BehaviorDecompositionContextAnalysis>
  implements BehaviorDecompositionContextAnalysis {}

export { BehaviorDecompositionContextAnalysis };
```

### BehaviorDecompositionPlan

file: `src/domain.objects/BehaviorDecompositionPlan.ts`

```ts
import { DomainLiteral } from 'domain-objects';

import { BehaviorPersisted } from './BehaviorPersisted';
import { BehaviorDecompositionProposed } from './BehaviorDecompositionProposed';
import { BehaviorDecompositionContextAnalysis } from './BehaviorDecompositionContextAnalysis';

/**
 * .what = a plan to decompose a behavior into focused sub behaviors
 * .why = enables review before apply, supports iterative refinement
 */
interface BehaviorDecompositionPlan {
  /**
   * source behavior to decompose
   */
  behaviorSource: BehaviorPersisted;

  /**
   * proposed behaviors
   */
  behaviorsProposed: BehaviorDecompositionProposed[];

  /**
   * context window analysis
   */
  contextAnalysis: BehaviorDecompositionContextAnalysis;

  /**
   * timestamp of plan generation
   */
  generatedAt: string;
}
class BehaviorDecompositionPlan
  extends DomainLiteral<BehaviorDecompositionPlan>
  implements BehaviorDecompositionPlan {
  public static nested = {
    behaviorSource: BehaviorPersisted,
    behaviorsProposed: BehaviorDecompositionProposed,
    contextAnalysis: BehaviorDecompositionContextAnalysis,
  };
}

export { BehaviorDecompositionPlan };
```


---

## briefs

briefs provide domain knowledge to brain.repl for probabilistic operations. each skill loads its relevant briefs to guide LLM judgment.

### decompose/rule.require.contexts.bounded.md

```md
# contexts.bounded

# severity = blocker

## .what
each proposed behavior should represent a single bounded context - a cohesive domain with its own ubiquitous language and clear boundaries.

## .how
- look for natural seams in criteria where terminology shifts
- group criteria that share domain concepts together
- separate criteria that could evolve independently
- identify where one domain's output becomes another's input (dependency boundary)

## .signals.good
- criteria within a behavior use consistent terminology
- behaviors can be explained without reference to peer behaviors
- changes to one behavior rarely require changes to peers
- each behavior has a clear "job to be done"
```

### decompose/rule.require.dependencies.directional.md

```md
# dependencies.directional

# severity = blocker

## .what
dependencies between proposed behaviors must flow in one direction - no cycles allowed.

## .how
- identify which behaviors produce artifacts others consume
- producer behaviors have zero or fewer dependencies
- consumer behaviors depend on producers

## .principle.order
behaviors with fewer dependencies should be built first, enable parallel work on independent behaviors.
```

### decompose/rule.require.names.ubiquitous.md

```md
# names.ubiquitous

# severity = blocker

## .what
behavior names must reflect domain concepts via ubiquitous language.

## .how
- use noun phrases that describe the capability (e.g., "user-auth", "invoice-generation")
- avoid technical terms unless the domain is technical
- prefer hyphen-separated lowercase (kebab-case)
- names should be self-explanatory without the wish

## .anti-patterns
- generic names like "phase-1", "part-a"
- implementation details like "database-setup"
- unclear abbreviations
```

### decompose/rule.require.wish.scoped.md

```md
# wish.scoped

# severity = blocker

## .what
each proposed behavior needs a focused wish derived from the parent wish.

## .how
- extract the subset of parent wish relevant to this behavior's scope
- reframe in terms of this behavior's bounded context
- preserve the "why" motivation from parent
- make it self-contained (readable without parent context)

## .structure
scoped wish should answer:
1. what capability does this behavior enable?
2. why does this capability matter?
3. what is explicitly out of scope?
```

### decompose/rule.require.vision.scoped.md

```md
# vision.scoped

# severity = blocker

## .what
if parent has vision content, extract relevant guidance into each behavior.

## .how
- extract vision elements that apply to this behavior's scope
- adapt shared guidance to behavior's context
- if no vision elements apply, set to null (not empty text)
- preserve architectural constraints that span behaviors

## .when.null
set vision to null when:
- parent vision was empty
- no parent vision elements apply to this scope
- behavior is purely technical/infrastructural
```

### review/rule.require.context.threshold.md

```md
# context.threshold

# severity = blocker

## .what
behaviors that consume >30% of context window should be decomposed.

## .why
- 30% artifacts leaves 70% for execution headroom
- execution needs space for: tool calls, thought, code generation, iteration
- cramped context leads to: forgotten requirements, inconsistent output, missed edge cases

## .calculation
- sum chars from: criteria + research + distill files
- estimate tokens: chars / 4
- context window: 200k tokens (claude)
- threshold: 60k tokens (30%)
```

### review/rule.require.domain.bounded.md

```md
# domain.bounded

# severity = blocker

## .what
behaviors that span multiple distinct domains should be decomposed.

## .signals
- research files cover unrelated topics
- criteria use inconsistent terminology
- "and" appears frequently to connect unrelated capabilities
- different expertise required for different sections

## .action
flag as hazard when multiple bounded contexts detected, recommend decomposition to enforce separation of concerns.
```


---

## readme.md (update)

file: `readme.md`

update the registry example output to include decomposer and new emojis:

```md
## `readme --registry`
```sh
npx rhachet readme --registry bhuild
```

produces

```md
# ðŸ¦« bhuild role registry

This registry defines roles used to build systems and solutions.

---

## ðŸŒ² Behaver

Used to declare clear and testable behaviors that can be reliably built and verified.

---

## ðŸ’§ Dispatcher

Used to maximize prioritized throughput within a resource bandwidth.

---

## ðŸ„ Decomposer

Used to decompose large behaviors into focused, independent sub-behaviors.
```
```


---

## role registration

### getDecomposerRole.readme.ts

file: `src/domain.roles/decomposer/getDecomposerRole.readme.ts`

```ts
export const DECOMPOSER_ROLE_README = `
## ðŸ„ Decomposer

Used to analyze behaviors that have grown too large for effective execution
and decompose them into focused sub-behaviors that can be built independently.
`.trim();
```

### getDecomposerRole.ts

file: `src/domain.roles/decomposer/getDecomposerRole.ts`

```ts
import { Role } from 'rhachet';

import { DECOMPOSER_ROLE_README } from './getDecomposerRole.readme';

export const ROLE_DECOMPOSER: Role = Role.build({
  slug: 'decomposer',
  name: 'Decomposer',
  purpose: 'decompose large behaviors into focused sub-behaviors',
  readme: DECOMPOSER_ROLE_README,
  traits: [],
  skills: {
    dirs: [{ uri: __dirname + '/skills' }],
    refs: [],
  },
  briefs: {
    dirs: [{ uri: __dirname + '/briefs' }],
  },
  inits: {
    dirs: { uri: __dirname + '/inits' },
    exec: [],
  },
});
```

### getRoleRegistry.ts (update)

file: `src/domain.roles/getRoleRegistry.ts`

```ts
import { RoleRegistry } from 'rhachet';

import { ROLE_BEHAVER } from './behaver/getBehaverRole';
import { ROLE_DECOMPOSER } from './decomposer/getDecomposerRole';
import { BHUILD_REGISTRY_README } from './getRoleRegistry.readme';

/**
 * .what = returns the core registry of predefined roles and skills
 * .why =
 *   - enables CLI or thread logic to load available roles
 *   - avoids dynamic load or global mutation
 */
export const getRoleRegistry = (): RoleRegistry =>
  new RoleRegistry({
    slug: 'bhuild',
    readme: BHUILD_REGISTRY_README,
    roles: [ROLE_BEHAVER, ROLE_DECOMPOSER],
  });
```

### getRoleRegistry.readme.ts (update)

file: `src/domain.roles/getRoleRegistry.readme.ts`

```ts
export const BHUILD_REGISTRY_README = `
# ðŸ¦« bhuild role registry

This registry defines roles used to build systems and solutions.

---

## ðŸŒ² Behaver

Used to declare clear and testable behaviors that can be reliably built and verified.

---

## ðŸ’§ Dispatcher

Used to maximize prioritized throughput within a resource bandwidth.

---

## ðŸ„ Decomposer

Used to decompose large behaviors into focused, independent sub-behaviors.
  `.trim();
```


---

## infra

### BrainReplContext.ts

file: `src/infra/brain/BrainReplContext.ts`

```ts
/**
 * .what = brief content for brain.repl context
 * .why = provides domain knowledge to guide LLM judgment
 * .todo = liftout generalized into rhachet repo
 */
export interface BrainReplBrief {
  name: string;
  content: string;
}

/**
 * .what = role with briefs for brain.repl
 * .why = bundles domain knowledge for a specific skill invocation
 * .todo = liftout generalized into rhachet repo
 */
export interface BrainReplRole {
  briefs: BrainReplBrief[];
}

/**
 * .what = context interface for brain.repl dependency injection
 * .why = enables probabilistic operations to receive LLM access via context
 * .todo = liftout generalized into rhachet repo
 */
export interface BrainReplContext {
  imagine: (input: {
    prompt: string;
    role: BrainReplRole;
    outputFormat: 'json' | 'text';
  }) => Promise<string>;
}
```

### loadBriefs.ts

file: `src/infra/brain/loadBriefs.ts`

```ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';

import { BrainReplBrief } from './BrainReplContext';

/**
 * .what = loads brief files from a role's skill directory
 * .why = enables CLI to construct brain.repl context with domain knowledge
 * .todo = liftout generalized into rhachet repo
 */
export const loadBriefs = async (
  input: {
    roleDir: string;
    skillName: string;
  },
): Promise<BrainReplBrief[]> => {
  const briefsDir = path.join(input.roleDir, 'briefs', input.skillName);

  // find all markdown files in briefs directory
  const briefFiles = await glob('*.md', { cwd: briefsDir });

  // load each brief
  const briefs: BrainReplBrief[] = [];
  for (const file of briefFiles) {
    const content = await fs.readFile(path.join(briefsDir, file), 'utf-8');
    briefs.push({
      name: file.replace('.md', ''),
      content,
    });
  }

  return briefs;
};
```

### invokeBrainRepl.ts

file: `src/infra/brain/invokeBrainRepl.ts`

```ts
import { execSync } from 'child_process';

import { BrainReplRole } from './BrainReplContext';

/**
 * .what = invokes brain.repl claude-code with role briefs as context
 * .why = centralizes LLM invocation with consistent brief injection
 * .todo = liftout generalized into rhachet repo
 */
export const invokeBrainRepl = async (
  input: {
    prompt: string;
    role: BrainReplRole;
    outputFormat: 'json' | 'text';
  },
): Promise<string> => {
  // format briefs as system context
  const briefsFormatted = input.role.briefs
    .map((brief) => `<brief name="${brief.name}">\n${brief.content}\n</brief>`)
    .join('\n\n');

  // build full prompt with briefs
  const promptFull = `
<briefs>
${briefsFormatted}
</briefs>

<task>
${input.prompt}
</task>
`.trim();

  // invoke claude-code cli
  const output = execSync(
    `claude --print --output-format ${input.outputFormat} -p "${promptFull.replace(/"/g, '\\"')}"`,
    { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 },
  );

  return output;
};
```


---

## domain.operations

domain.operations contains two types of operations:
- **compute*** = deterministic computed work (pure functions, no external dependencies)
- **imagine*** = probabilistic creative work via `context.brain.repl.imagine({ role })`

### computeContextConsumption.ts

file: `src/domain.operations/behavior/decompose/computeContextConsumption.ts`

```ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';

import { BehaviorPersisted } from '../../../domain.objects/BehaviorPersisted';
import { BehaviorDecompositionContextAnalysis } from '../../../domain.objects/BehaviorDecompositionContextAnalysis';

/**
 * .what = computes token consumption of behavior artifacts
 * .why = quantifies whether decomposition is needed based on 30% threshold
 */
export const computeContextConsumption = async (
  input: { behavior: BehaviorPersisted },
): Promise<BehaviorDecompositionContextAnalysis> => {
  // gather artifact files
  const criteriaPath = path.join(input.behavior.path, '2.criteria.md');
  const researchFiles = await glob('3.1.research.*.md', { cwd: input.behavior.path });
  const distillFiles = await glob('3.2.distill.*.md', { cwd: input.behavior.path });

  // measure total chars
  let totalChars = 0;

  // criteria
  const criteriaFound = await fs.stat(criteriaPath).catch(() => null);
  if (criteriaFound) {
    const content = await fs.readFile(criteriaPath, 'utf-8');
    totalChars += content.length;
  }

  // research files
  for (const file of researchFiles) {
    const content = await fs.readFile(path.join(input.behavior.path, file), 'utf-8');
    totalChars += content.length;
  }

  // distill files
  for (const file of distillFiles) {
    const content = await fs.readFile(path.join(input.behavior.path, file), 'utf-8');
    totalChars += content.length;
  }

  // estimate tokens (chars / 4)
  const tokensEstimate = Math.ceil(totalChars / 4);

  // context window = 200k tokens (claude opus 4)
  const contextWindow = 200000;
  const windowPercentage = Math.ceil((tokensEstimate * 100) / contextWindow);

  // threshold = 30%
  const recommendation = windowPercentage > 30
    ? 'DECOMPOSE_REQUIRED' as const
    : 'DECOMPOSE_UNNEEDED' as const;

  return new BehaviorDecompositionContextAnalysis({
    usage: {
      characters: { quantity: totalChars },
      tokens: { estimate: tokensEstimate },
      window: { percentage: windowPercentage },
    },
    recommendation,
  });
};
```

### imaginePlan.ts

file: `src/domain.operations/behavior/decompose/imaginePlan.ts`

```ts
import * as fs from 'fs/promises';
import * as path from 'path';

import { BehaviorPersisted } from '../../../domain.objects/BehaviorPersisted';
import { BehaviorDecompositionPlan } from '../../../domain.objects/BehaviorDecompositionPlan';
import { computeContextConsumption } from './computeContextConsumption';
import { BrainReplContext, BrainReplRole } from '../../../infra/brain/BrainReplContext';

/**
 * .what = imagines a decomposition plan via brain.repl
 * .why = leverages LLM for creative boundary analysis while I/O remains deterministic
 */
export const imaginePlan = async (
  input: {
    behavior: BehaviorPersisted;
    role: BrainReplRole;
  },
  context: {
    brain: { repl: BrainReplContext };
  },
): Promise<BehaviorDecompositionPlan> => {
  // compute context consumption (deterministic)
  const contextAnalysis = await computeContextConsumption({
    behavior: input.behavior,
  });

  // read source artifacts for prompt
  const wishContent = await fs.readFile(
    path.join(input.behavior.path, '0.wish.md'),
    'utf-8',
  );
  const visionContent = await fs.readFile(
    path.join(input.behavior.path, '1.vision.md'),
    'utf-8',
  ).catch(() => '');
  const criteriaContent = await fs.readFile(
    path.join(input.behavior.path, '2.criteria.md'),
    'utf-8',
  );

  // build prompt for brain.repl
  const prompt = buildDecompositionPrompt({
    behaviorName: input.behavior.name,
    wishContent,
    visionContent,
    criteriaContent,
  });

  // invoke brain.repl for creative analysis (probabilistic)
  const brainOutput = await context.brain.repl.imagine({
    prompt,
    role: input.role,
    outputFormat: 'json',
  });

  // parse brain output into structured plan
  const planParsed = parseBrainOutput({ output: brainOutput });

  // construct domain object
  const plan = new BehaviorDecompositionPlan({
    behaviorSource: input.behavior,
    behaviorsProposed: planParsed.behaviorsProposed,
    contextAnalysis,
    generatedAt: new Date().toISOString(),
  });

  return plan;
};

/**
 * .what = builds prompt for brain.repl decomposition analysis
 * .why = structures the creative task for consistent output
 */
const buildDecompositionPrompt = (input: {
  behaviorName: string;
  wishContent: string;
  visionContent: string;
  criteriaContent: string;
}): string => {
  return `
analyze this behavior for decomposition into focused behaviors.

## source behavior: ${input.behaviorName}

### wish
${input.wishContent}

### vision
${input.visionContent || '(empty)'}

### criteria
${input.criteriaContent}

## task

1. identify natural boundaries in the criteria
2. propose behavior names based on domain concepts
3. identify dependencies between behaviors
4. decompose the wish into scoped wishes for each behavior
5. decompose the vision into scoped visions (or null if original was empty)

## output format (JSON)

{
  "behaviorsProposed": [
    {
      "name": "behavior-name",
      "dependsOn": [],
      "decomposed": {
        "wish": "decomposed wish...",
        "vision": "decomposed vision..." | null
      }
    }
  ]
}
`.trim();
};

/**
 * .what = parses brain output JSON into typed structure
 * .why = bridges probabilistic output to deterministic domain objects
 */
const parseBrainOutput = (input: { output: string }): {
  behaviorsProposed: BehaviorDecompositionPlan['behaviorsProposed'];
} => {
  // extract JSON from brain output
  const jsonMatch = input.output.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('brain output did not contain valid JSON');
  }
  return JSON.parse(jsonMatch[0]);
};

/**
 * .what = serializes plan to human-readable markdown
 * .why = enables review and manual edit before apply
 */
const serializePlanToMarkdown = (input: { plan: BehaviorDecompositionPlan }): string => {
  // ... markdown serialization logic
};
```

### computePlanFromFile.ts

file: `src/domain.operations/behavior/decompose/computePlanFromFile.ts`

```ts
import * as fs from 'fs/promises';

import { BehaviorDecompositionPlan } from '../../../domain.objects/BehaviorDecompositionPlan';

/**
 * .what = computes BehaviorDecompositionPlan from a JSON plan file
 * .why = enables deterministic plan consumption after review/edit
 */
export const computePlanFromFile = async (
  input: { planPath: string },
): Promise<BehaviorDecompositionPlan> => {
  // read JSON plan file
  const content = await fs.readFile(input.planPath, 'utf-8');
  const planRaw = JSON.parse(content);

  // construct domain object from JSON
  return new BehaviorDecompositionPlan(planRaw);
};
```

### applyPlan.ts

file: `src/domain.operations/behavior/decompose/applyPlan.ts`

```ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';

import { BehaviorDecompositionPlan } from '../../../domain.objects/BehaviorDecompositionPlan';

interface ApplyPlanOutput {
  behaviorSource: string;
  behaviorsCreated: Array<{ name: string; path: string }>;
  dependencyGraph: Record<string, string[]>;
  appliedAt: string;
  planFile: string;
}

/**
 * .what = applies a decomposition plan to create behaviors
 * .why = executes the reviewed plan deterministically
 */
export const applyPlan = async (
  input: {
    plan: BehaviorDecompositionPlan;
    planPath: string;
    targetDir: string;
  },
): Promise<ApplyPlanOutput> => {
  const behaviorsCreated: ApplyPlanOutput['behaviorsCreated'] = [];

  // validate no z.decomposed.md found
  const decomposedPath = path.join(input.plan.behaviorSource.path, 'z.decomposed.md');
  const decomposedFound = await fs.stat(decomposedPath).catch(() => null);
  if (decomposedFound) {
    throw new Error('behavior already decomposed, remove z.decomposed.md to re-decompose');
  }

  // create each proposed behavior
  for (const proposed of input.plan.behaviorsProposed) {
    // check behavior does not already exist
    const behaviorPattern = `*${proposed.name}`;
    const foundMatches = await glob(behaviorPattern, {
      cwd: path.join(input.targetDir, '.behavior'),
    });
    if (foundMatches.length > 0) {
      throw new Error(`behavior ${proposed.name} already exists`);
    }

    // invoke init.behavior via shell (reuse scaffold logic)
    execSync(
      `bash src/domain.roles/behaver/skills/init.behavior.sh --name "${proposed.name}" --dir "${input.targetDir}"`,
      { encoding: 'utf-8' },
    );

    // find created behavior directory
    const createdMatches = await glob(`*${proposed.name}`, {
      cwd: path.join(input.targetDir, '.behavior'),
    });
    const behaviorDir = path.join(input.targetDir, '.behavior', createdMatches[0]);

    // overwrite wish with decomposed content
    await fs.writeFile(
      path.join(behaviorDir, '0.wish.md'),
      `wish =\n\n${proposed.decomposed.wish}\n`,
    );

    // overwrite vision with decomposed content (or empty)
    await fs.writeFile(
      path.join(behaviorDir, '1.vision.md'),
      proposed.decomposed.vision ? `${proposed.decomposed.vision}\n` : '\n',
    );

    // 2.criteria.md already has template from init.behavior - leave as-is

    behaviorsCreated.push({
      name: proposed.name,
      path: behaviorDir,
    });
  }

  // build dependency graph
  const dependencyGraph: Record<string, string[]> = {};
  for (const proposed of input.plan.behaviorsProposed) {
    dependencyGraph[proposed.name] = proposed.dependsOn;
  }

  // write z.decomposed.md
  const output: ApplyPlanOutput = {
    behaviorSource: input.plan.behaviorSource.name,
    behaviorsCreated,
    dependencyGraph,
    appliedAt: new Date().toISOString(),
    planFile: path.basename(input.planPath),
  };

  await fs.writeFile(
    decomposedPath,
    serializeToMarkdown({ output }),
  );

  return output;
};

/**
 * .what = serializes output to z.decomposed.md format
 * .why = provides traceability for future travelers
 */
const serializeToMarkdown = (input: { output: ApplyPlanOutput }): string => {
  // ... markdown serialization logic
};
```


---

## contract/cli

### decompose.behavior.ts

file: `src/contract/cli/decompose.behavior.ts`

```ts
import { Command } from 'commander';
import * as fs from 'fs/promises';
import * as path from 'path';

import { BehaviorPersisted } from '../../domain.objects/BehaviorPersisted';
import { imaginePlan } from '../../domain.operations/behavior/decompose/imaginePlan';
import { computePlanFromFile } from '../../domain.operations/behavior/decompose/computePlanFromFile';
import { applyPlan } from '../../domain.operations/behavior/decompose/applyPlan';
import { resolveBehaviorDir } from '../../domain.operations/behavior/bind/getBoundBehaviorByBranch';
import { invokeBrainRepl } from '../../infra/brain/invokeBrainRepl';
import { loadBriefs } from '../../infra/brain/loadBriefs';
import { BrainReplRole } from '../../infra/brain/BrainReplContext';

const program = new Command();

program
  .name('decompose.behavior')
  .description('decompose a behavior into focused behaviors')
  .requiredOption('--for.behavior <name>', 'behavior name to decompose')
  .requiredOption('--mode <mode>', 'plan | apply')
  .option('--plan <path>', 'plan file path (required for --mode apply)')
  .option('--dir <path>', 'target directory', process.cwd())
  .action(async (options) => {
    // resolve behavior as domain object
    const behaviorPath = await resolveBehaviorDir({
      name: options['for.behavior'],
      targetDir: options.dir,
    });
    const behavior = new BehaviorPersisted({
      name: options['for.behavior'],
      path: behaviorPath,
    });

    // validate criteria found
    const criteriaPath = path.join(behavior.path, '2.criteria.md');
    const criteriaFound = await fs.stat(criteriaPath).catch(() => null);
    if (!criteriaFound) {
      console.error('error: criteria required for decomposition');
      process.exit(1);
    }

    if (options.mode === 'plan') {
      // load decomposer briefs for brain.repl
      const briefs = await loadBriefs({
        roleDir: 'src/domain.roles/decomposer',
        skillName: 'decompose',
      });
      const role = { briefs };

      // construct context with brain.repl dependency
      const context = {
        brain: {
          repl: {
            imagine: (input: { prompt: string; role: BrainReplRole; outputFormat: 'json' | 'text' }) =>
              invokeBrainRepl({
                prompt: input.prompt,
                role: input.role,
                outputFormat: input.outputFormat,
              }),
          },
        },
      };

      // invoke probabilistic plan generation (passes role explicitly)
      const plan = await imaginePlan(
        { behavior, role },
        context,
      );

      // write plan as JSON for deterministic consumption by --mode apply
      const planPath = path.join(behavior.path, 'z.plan.decomposition.v1.json');
      await fs.writeFile(planPath, JSON.stringify(plan, null, 2));

      console.log('plan generated:', planPath);
      console.log('context consumption:', plan.contextAnalysis.usage.window.percentage + '%');
      console.log('behaviors proposed:', plan.behaviorsProposed.length);

    } else if (options.mode === 'apply') {
      // validate --plan provided
      if (!options.plan) {
        console.error('error: --plan required for --mode apply');
        process.exit(1);
      }

      // compute plan from file (deterministic)
      const plan = await computePlanFromFile({ planPath: options.plan });

      // apply plan (deterministic)
      const output = await applyPlan({
        plan,
        planPath: options.plan,
        targetDir: options.dir,
      });

      console.log('decomposition complete!');
      console.log('behaviors created:', output.behaviorsCreated.length);
      for (const behavior of output.behaviorsCreated) {
        console.log('  -', behavior.name, ':', behavior.path);
      }

    } else {
      console.error('error: --mode must be "plan" or "apply"');
      process.exit(1);
    }
  });

program.parse();
```

### review.decomposition.ts

file: `src/contract/cli/review.decomposition.ts`

```ts
import { Command } from 'commander';
import * as fs from 'fs/promises';
import * as path from 'path';

import { BehaviorPersisted } from '../../domain.objects/BehaviorPersisted';
import { computeContextConsumption } from '../../domain.operations/behavior/decompose/computeContextConsumption';
import { resolveBehaviorDir } from '../../domain.operations/behavior/bind/getBoundBehaviorByBranch';

const program = new Command();

program
  .name('review.decomposition')
  .description('review behavior artifacts for decomposition need')
  .requiredOption('--for.behavior <name>', 'behavior name to review')
  .option('--dir <path>', 'target directory', process.cwd())
  .action(async (options) => {
    // resolve behavior as domain object
    const behaviorPath = await resolveBehaviorDir({
      name: options['for.behavior'],
      targetDir: options.dir,
    });
    const behavior = new BehaviorPersisted({
      name: options['for.behavior'],
      path: behaviorPath,
    });

    // validate criteria found
    const criteriaPath = path.join(behavior.path, '2.criteria.md');
    const criteriaFound = await fs.stat(criteriaPath).catch(() => null);
    if (!criteriaFound) {
      console.error('error: criteria required for decomposition analysis');
      process.exit(1);
    }

    // compute context consumption (deterministic)
    const analysis = await computeContextConsumption({ behavior });

    // emit results
    console.log('context analysis:');
    console.log('  characters:', analysis.usage.characters.quantity);
    console.log('  tokens:', analysis.usage.tokens.estimate);
    console.log('  window:', analysis.usage.window.percentage + '%');
    console.log('  recommendation:', analysis.recommendation);

    if (analysis.recommendation === 'DECOMPOSE_REQUIRED') {
      console.log('');
      console.log('HAZARD: behavior artifacts consume >' + '30% of context window');
      console.log('run: decompose.behavior --for.behavior', options['for.behavior'], '--mode plan');
    }
  });

program.parse();
```


---

## skill.1: review.decomposition.sh (thin dispatcher)

file: `src/domain.roles/decomposer/skills/review.decomposition.sh`

```sh
#!/usr/bin/env bash
######################################################################
# .what = review behavior artifacts for decomposition need
# .why  = thin dispatcher to contract/cli/review.decomposition.ts
######################################################################

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../../../.." && pwd)"

# dispatch to typescript CLI
exec npx tsx "$REPO_ROOT/src/contract/cli/review.decomposition.ts" "$@"
```


---

## skill.2: decompose.behavior.sh

### header

```sh
#!/usr/bin/env bash
######################################################################
# .what = decompose a behavior into focused behaviors
#
# .why  = enables breakdown of large behaviors into parallel,
#         independent behaviors for focused execution
#
# .how  = --mode plan: analyze criteria, propose behaviors,
#                      emit plan file for review
#         --mode apply: read plan file, init behaviors,
#                       decompose wish/vision, emit z.decomposed.md
#
# usage:
#   decompose.behavior.sh --for.behavior <name> --mode plan
#   decompose.behavior.sh --for.behavior <name> --mode apply --plan <file>
#
# examples:
#   decompose.behavior.sh --for.behavior large-feature --mode plan
#   decompose.behavior.sh --for.behavior large-feature --mode apply \
#     --plan .behavior/v2025_01_01.large-feature/z.plan.decomposition.v1.json
#
# guarantee:
#   - fail-fast if behavior not found
#   - fail-fast if criteria not found
#   - fail-fast if --mode apply without --plan
#   - fail-fast if already decomposed (z.decomposed.md found)
#   - fail-fast if behavior already exists
#   - idempotent: plan can be regenerated, apply is one-time
######################################################################
```

### --mode plan implementation

1. **resolve behavior and validate**
   - find behavior directory
   - verify 2.criteria.md exists
   - verify z.decomposed.md does NOT exist (warn if found)

2. **invoke claude code for analysis**
   - pass criteria + research + distill to claude
   - prompt asks to:
     - identify natural boundaries in criteria
     - propose behavior names
     - identify dependencies
     - decompose wish per behavior
     - decompose vision per behavior (if non-empty)

3. **emit plan file**
   - path: `$BEHAVIOR_DIR/z.plan.decomposition.v1.json`
   - JSON format for deterministic consumption by --mode apply
   - includes all BehaviorDecompositionPlan fields

### plan file format

```json
{
  "behaviorSource": {
    "name": "large-feature",
    "path": ".behavior/v2025_01_01.large-feature"
  },
  "behaviorsProposed": [
    {
      "name": "feature-auth",
      "dependsOn": [],
      "decomposed": {
        "wish": "enable user authentication and session management...",
        "vision": "(decomposed from parent vision if non-empty)"
      }
    },
    {
      "name": "feature-data",
      "dependsOn": ["feature-auth"],
      "decomposed": {
        "wish": "enable data persistence with cache invalidation...",
        "vision": "..."
      }
    }
  ],
  "contextAnalysis": {
    "usage": {
      "characters": { "quantity": 300000 },
      "tokens": { "estimate": 75000 },
      "window": { "percentage": 37 }
    },
    "recommendation": "DECOMPOSE_REQUIRED"
  },
  "generatedAt": "2025-12-29T10:00:00Z"
}
```

### --mode apply implementation

1. **validate inputs**
   - verify --plan file exists
   - parse plan file
   - verify z.decomposed.md does NOT exist

2. **for each proposed behavior in plan**
   - verify behavior directory does not exist
   - invoke init.behavior with --name
   - overwrite 0.wish.md with decomposed wish
   - overwrite 1.vision.md with decomposed vision (or empty)
   - 2.criteria.md gets template only (NOT copied from parent)

3. **emit z.decomposed.md**
   - path: `$BEHAVIOR_DIR/z.decomposed.md`
   - includes ApplyPlanOutput fields
   - serves as marker that behavior was decomposed

### z.decomposed.md format

```md
# decomposed

this behavior was decomposed into focused behaviors.

**applied_at:** 2025-12-29T10:30:00Z
**plan_file:** z.plan.decomposition.v1.json

## behaviors created

| name         | path                               |
| ------------ | ---------------------------------- |
| feature-auth | .behavior/v2025_12_29.feature-auth |
| feature-data | .behavior/v2025_12_29.feature-data |

## dependency graph

```
feature-auth
     â†“
feature-data
```

## next steps

1. cd to each behavior directory
2. regenerate criteria from decomposed wish/vision
3. proceed with normal bhuild thoughtroute
```


---

## tests

### deterministic components
- argument parse
- behavior directory resolution
- token count
- plan file parse
- behavior directory creation
- z.decomposed.md generation

### probabilistic components
- domain breadth analysis (llm-generated)
- criteria boundary detection (llm-generated)
- wish/vision decomposition (llm-generated)

### test coverage

**review.decomposition.integration.test.ts**

```ts
given('[case1] behavior with criteria + research + distill under 30%', () => {
  when('[t0] review.decomposition invoked', () => {
    then('reports actual context consumption percentage', ...);
    then('recommends no decomposition needed', ...);
  });
});

given('[case2] behavior with artifacts over 30%', () => {
  when('[t0] review.decomposition invoked', () => {
    then('flags hazard with percentage', ...);
    then('recommends decomposition', ...);
  });
});

given('[case3] behavior without criteria', () => {
  when('[t0] review.decomposition invoked', () => {
    then('fails fast with "criteria required for decomposition analysis"', ...);
  });
});
```

**decompose.behavior.integration.test.ts**

```ts
given('[case1] behavior that needs decomposition', () => {
  when('[t0] --mode plan invoked', () => {
    then('emits plan file to z.plan.decomposition.v1.json', ...);
    then('plan includes proposed behavior names', ...);
    then('plan includes dependency graph', ...);
  });

  when('[t1] --mode apply invoked with plan', () => {
    then('creates behavior directories via init.behavior', ...);
    then('behavior 0.wish.md contains decomposed wish', ...);
    then('behavior 1.vision.md contains decomposed vision or empty', ...);
    then('behavior 2.criteria.md contains template only', ...);
    then('creates z.decomposed.md in parent', ...);
  });
});

given('[case2] --mode apply without --plan flag', () => {
  when('[t0] skill invoked', () => {
    then('fails fast with "--plan required"', ...);
  });
});

given('[case3] behavior already decomposed', () => {
  when('[t0] --mode plan invoked', () => {
    then('warns "behavior already decomposed"', ...);
    then('shows behaviors found', ...);
  });

  when('[t1] --mode apply invoked', () => {
    then('fails fast with "remove z.decomposed.md to re-decompose"', ...);
  });
});

given('[case4] plan with behavior name conflict', () => {
  when('[t0] --mode apply invoked', () => {
    then('fails fast with "behavior {name} already exists"', ...);
  });
});
```

### test fixtures

**needs-decomposition fixture**
- 0.wish.md: complex multi-feature wish
- 2.criteria.md: criteria across multiple domains
- 3.1.research.domain._.v1.i1.md: 50k+ chars of research
- 3.2.distill.domain._.v1.i1.md: 20k+ chars of distillation
- total > 30% context window threshold

**already-decomposed fixture**
- 0.wish.md: original wish
- z.decomposed.md: marker from previous decomposition


---

## rollout

### phase 0: scaffold
- create review.decomposition.sh with argument parse
- create decompose.behavior.sh with argument parse
- create test fixtures

### phase 1: review.decomposition
- implement token count
- implement threshold check
- implement feedback output
- add integration tests

### phase 2: decompose --mode plan
- implement claude code prompt for analysis
- implement plan file generation
- add integration tests

### phase 3: decompose --mode apply
- implement plan file parse
- implement behavior creation via init.behavior
- implement wish/vision decomposition
- implement z.decomposed.md generation
- add integration tests

### phase 4: validation
- run against this decomposer behavior (meta-test)
- verify all criteria are satisfied
