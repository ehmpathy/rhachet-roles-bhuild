emit your response to the feedback into
- .behavior/v2025_12_29.decomposer/.ref.[feedback].v1.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---
---
---


# blocker.1

> update the blueprint to make the plan executable deterministically.
decompose.behavior.sh should dispatch to
contract/cli/decompose.behavior.ts which should invoke domain.operations
which know how to write a plan or read a plan, using brain.repl
claude-code cli under the hood for the probabilistic creative though
components


---

# blocker.2

> what briefs should decomposer brains have loaded for these skills, when
 they invoke brain.repl? ensure that we declare the briefs under
domain.roles/decomposer/briefs/decompose & /review - then ensure that we
pass those through in the context of the brain.repl.imagine() requests

---

# blocker.3

> make it clear in the blueprint that domain.operations will call both
  deterministic operations (compute* prefix) as well as probabalistic
  operations (imainge *) ; the probabalistic operations will then
  invokeBrainRepl via context; e.g., context.brain.repl.imagine({ ... })


---

# blocker.4

 `compute*` = deterministic logic -> `compute*` = deterministic computed
  work; that way its symmetric; also, dont forget to pass in the role: {
  briefs } for EVERY context.brain.repl.imagine() invocation; and dont
  forget to emit a json plan that can be subsequently deterministically
  leveraged as an input

---

# blocker.5

──────
> instead of
      behaviorDir: string;
      behaviorName: string;, we should have a BehaviorPersisted
  domain.literal which composes where a Behavior is Persisted (dir, name);
  then, use behavior: BehaviorPersisted instead of this bag of words tuple

  and make the terms { path, name }
────────────────────────────────────────────────────────────────────────────

---

# blocker.6

─────────────────────────────────────────────────────────────────────────────
> why is the domain object for BehaviorDecompositionProposed and
  BehaviorDecompositionPlan not clearly identified under domain.operations
────────────────────────────────────────────────────────────────────────────

---

# blocker.7

│           ├── index.ts                          # new: exports

no barrel exports. they're dangerous

---

# blocker.8


/**
 * .what = context window consumption analysis for behavior decomposition
 * .why = quantifies whether decomposition is needed based on artifact size
 */
interface BehaviorDecompositionContextAnalysis {
  tokensTotal: number;
  contextWindowPercent: number;
  recommendation: 'DECOMPOSE' | 'NO_DECOMPOSITION_NEEDED';
}

=>

usage: {
  characters: { quantity: number },
  tokens: { estimate: number },
  window: { percentage: number }
},
recommendation: "DECOMPOSE_REQUIRED" | "DECOMPOSE_UNEEDED"

---

# blocker.9


interface BehaviorDecompositionPlan {
  /**
   * source behavior being decomposed
   */
  behaviorSource: BehaviorPersisted;

  /**
   * proposed behaviors
   */
  behaviorsProposed: BehaviorDecompositionProposed[];

  /**
   * context window analysis
   */
  contextAnalysis: BehaviorDecompositionContextAnalysis;

  /**
   * timestamp of plan generation
   */
  generatedAt: string;
}

=>


interface BehaviorDecompositionPlan {
  /**
   * timestamp of plan generation
   */
  generatedAt: string;

  /**
   * source behavior being decomposed
   */
  source: BehaviorPersisted;

  /**
   * context window analysis
   */
  analysis: BehaviorDecompositionContextAnalysis;

  /**
   * proposed behaviors
   *
   * null if decomposition unneeded
   */
  proposals: BehaviorDecompositionProposed[] | null;
}
