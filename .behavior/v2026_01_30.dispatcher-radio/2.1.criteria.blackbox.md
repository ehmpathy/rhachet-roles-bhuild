# blackbox criteria: dispatcher radio

> experience boundaries for radio.task.push and radio.task.pull

---

# usecase.1 = push new task to gh.issues

given('inside a git repo with gh cli authenticated')
  when('radio.task.push --via gh.issues --title "fix flaky test" --description "timeout in ci"')
    then('output shows broadcast confirmation')
      sothat('user knows the task was sent')
    then('output shows created issue number')
      sothat('user can reference the task later')
    then('output shows pushed_by and pushed_at')
      sothat('audit trail is visible')
    then('output shows issue url')
      sothat('user can view the task in browser')

  when('radio.task.push --via gh.issues --title "update readme"')
    then('error: description is required')
      sothat('tasks always have context')

  when('radio.task.push --via gh.issues --description "no title"')
    then('error: title is required')
      sothat('tasks are always identifiable')

given('inside a git repo without gh cli authenticated')
  when('radio.task.push --via gh.issues --title "any task"')
    then('error: gh cli not authenticated')
      sothat('user knows to authenticate before broadcast')

given('outside any git repo')
  when('radio.task.push --via gh.issues --title "any task"')
    then('error: --repo required (not in a git repo)')
      sothat('user knows to specify repo explicitly')

  when('radio.task.push --via gh.issues --repo ehmpathy/acme-app --title "task" --description "desc"')
    then('task is created in specified repo')
      sothat('cross-repo dispatch works outside git context')


# usecase.2 = push new task to os.fileops (current repo)

given('inside a git repo with .radio/ symlink')
  when('radio.task.push --via os.fileops --title "local task" --description "offline work"')
    then('output shows task persisted to .radio/')
      sothat('user knows where the task lives')
    then('task file exists at ~/git/.radio/$owner/$repo/task.{exid}._.md')
      sothat('task is stored in global radio directory')
    then('task file is accessible via .radio/task.{exid}._.md symlink')
      sothat('local access works transparently')
    then('task file contains frontmatter with pushed_by and pushed_at')
      sothat('audit trail is preserved locally')
    then('status flag file exists at .radio/task.{exid}._.status=QUEUED.flag')
      sothat('status is queryable via glob')

given('inside a git repo without .radio/ symlink')
  when('radio.task.push --via os.fileops --title "first task" --description "bootstrap"')
    then('~/git/.radio/$owner/$repo/ directory is created')
      sothat('global radio directory is bootstrapped')
    then('~/git/.radio/readme.md is findserted')
      sothat('global radio dir is self-documented')
    then('~/git/.radio/$owner/$repo/readme.md is findserted')
      sothat('repo radio dir is self-documented')
    then('.radio/ symlink is created ‚Üí ~/git/.radio/$owner/$repo/')
      sothat('local access is linked to global')


# usecase.2b = push/pull task to other repo via os.fileops

given('inside a git repo (ehmpathy/acme-app)')
  when('radio.task.push --via os.fileops --repo ehmpathy/other-service --title "cross-repo task" --description "dispatch"')
    then('task is written to ~/git/.radio/ehmpathy/other-service/task.{exid}._.md')
      sothat('task is dispatched to target repo global dir')
    then('task is NOT accessible via current repo .radio/')
      sothat('cross-repo tasks stay in their own namespace')
    then('output shows path ~/git/.radio/ehmpathy/other-service/')
      sothat('user knows the task went to global radio for other repo')

given('inside a git repo (ehmpathy/acme-app)')
  when('radio.task.pull --via os.fileops --repo ehmpathy/other-service --list')
    then('tasks are read from ~/git/.radio/ehmpathy/other-service/')
      sothat('cross-repo pull uses global radio')
    then('tasks are NOT cached to current repo .radio/')
      sothat('other repo tasks stay in their global namespace')


# usecase.3 = claim task (QUEUED ‚Üí CLAIMED)

given('inside a git repo with task #142 in QUEUED status')
  when('radio.task.push --via gh.issues --exid 142 --status CLAIMED')
    then('output shows task claimed')
    then('output shows "üå≤ tree planted at {branch}"')
      sothat('branch is recorded for the work')
    then('issue is assigned to current user')
      sothat('ownership is visible on github')
    then('issue description header is updated with tree planted message')
      sothat('claim is visible in issue body')

  when('radio.task.push --via os.fileops --exid 142 --status CLAIMED')
    then('task file frontmatter updated with claimed_by, claimed_at, branch')
    then('status flag file renamed from ._.status=QUEUED.flag to ._.status=CLAIMED.flag')
      sothat('status query reflects new state')
    then('task body updated with "üå≤ tree planted at {branch}"')

given('inside a git repo with task #142 already CLAIMED by same branch')
  when('radio.task.push --via gh.issues --exid 142 --status CLAIMED')
    then('output shows task already claimed (no-op)')
      sothat('idempotent re-claim from same branch succeeds')

given('inside a git repo with task #142 already CLAIMED by different branch')
  when('radio.task.push --via gh.issues --exid 142 --status CLAIMED')
    then('error: task already claimed by {branch}')
      sothat('branch conflicts are detected early')


# usecase.4 = deliver task (CLAIMED ‚Üí DELIVERED)

given('inside a git repo with task #142 in CLAIMED status')
  when('radio.task.push --via gh.issues --exid 142 --status DELIVERED')
    then('output shows task delivered')
    then('output shows "üå≤ tree delivered at {branch}"')
    then('issue is closed')
      sothat('delivered tasks are removed from open queue')
    then('issue description header updated from "planted" to "delivered"')

  when('radio.task.push --via os.fileops --exid 142 --status DELIVERED')
    then('task file frontmatter updated with delivered_at')
    then('task body updated with "üå≤ tree delivered at {branch}"')
    then('status flag file is removed')
      sothat('delivered tasks have no flag (queryable via absence)')

given('inside a git repo with task #142 in QUEUED status')
  when('radio.task.push --via gh.issues --exid 142 --status DELIVERED')
    then('error: cannot deliver unclaimed task')
      sothat('lifecycle order is enforced')


# usecase.5 = list tasks from gh.issues

given('inside a git repo with 3 radio tasks on gh.issues')
  when('radio.task.pull --via gh.issues --list')
    then('output shows all 3 tasks')
      sothat('user can see available work')
    then('each task shows exid, title, and status')
      sothat('user can identify and filter tasks')
    then('tasks are prefixed with üéôÔ∏è emoji')
      sothat('radio tasks are visually distinct')

given('inside a git repo with 0 radio tasks on gh.issues')
  when('radio.task.pull --via gh.issues --list')
    then('output shows "no tasks found"')
      sothat('user knows no tasks are enqueued')


# usecase.6 = list tasks from os.fileops

given('inside a git repo with 2 tasks in .radio/')
  when('radio.task.pull --via os.fileops --list')
    then('output shows both tasks with status')
      sothat('user can identify local tasks and their state')

given('inside a git repo with status flag files')
  when('user globs for *._.status=QUEUED.flag')
    then('only QUEUED tasks are matched')
      sothat('fast status queries work without file parse')

given('inside a git repo with empty .radio/')
  when('radio.task.pull --via os.fileops --list')
    then('output shows "no tasks cached locally"')


# usecase.7 = pull specific task

given('inside a git repo with task #142 on gh.issues')
  when('radio.task.pull --via gh.issues --exid 142')
    then('output shows task details')
    then('output shows task cached to .radio/task.142._.md')
      sothat('user knows task is available locally')
    then('task file contains full details with frontmatter')

  when('radio.task.pull --via gh.issues --exid 999')
    then('error: task #999 not found on channel')
      sothat('user knows the exid is invalid')

given('inside a git repo with task.142._.md in .radio/')
  when('radio.task.pull --via os.fileops --exid 142')
    then('output shows task details from local cache')
      sothat('user can read task without network')


# usecase.8 = auto-cache on remote pull (episode)

given('inside a git repo with task #142 on gh.issues and empty .radio/')
  when('radio.task.pull --via gh.issues --exid 142')
    then('task is fetched from gh.issues')
    then('task is auto-cached to .radio/task.142._.md')
    then('status flag file is created')
      sothat('subsequent reads are local-first')

  when('radio.task.pull --via os.fileops --exid 142')
    then('task is available from local cache')
      sothat('no network required after initial pull')


# usecase.9 = edit task with idempotency

given('inside a git repo with task #142 on gh.issues')
  when('radio.task.push --via gh.issues --exid 142 --title "new title" --idem upsert')
    then('task is updated with new title')
    then('backup created at .radio/task.142.bak.{isodate}.md')
      sothat('prior version is preserved')
    then('output shows "task #142 updated"')

  when('radio.task.push --via gh.issues --title "duplicate" --description "same" --idem findsert')
    given('task with title "duplicate" already exists with same attributes')
      then('output shows "task found" with matched attributes')
        sothat('idempotent retry succeeds without error')

    given('task with title "duplicate" exists with different attributes')
      then('output shows "task found" with matched title')
        sothat('findsert ignores attribute mismatch')

  when('radio.task.push --via gh.issues --title "duplicate" --description "different"')
    given('task with title "duplicate" already exists')
      then('error: task exists but attributes differ')
      then('error suggests --idem upsert or --idem findsert')
        sothat('user knows how to proceed')


# usecase.10 = cross-repo dispatch

given('inside a git repo (ehmpathy/acme-app)')
  when('radio.task.push --via gh.issues --repo ehmpathy/other-service --title "task" --description "desc"')
    then('task is created in ehmpathy/other-service')
      sothat('cross-repo dispatch is explicit')

given('GITHUB_TOKEN set to app token')
  when('radio.task.push --via gh.issues --repo ehmpathy/private-repo --title "task" --description "desc"')
    then('task is created with app token auth')
      sothat('app tokens enable automated dispatch')


# usecase.11 = gh.issues task format

given('a task pushed to gh.issues')
  when('the issue is viewed on github')
    then('issue title is "üéôÔ∏è task: {title}"')
      sothat('radio tasks are identifiable in issue list')
    then('issue body contains "ü¶´ dispatch to foreman" header')
    then('issue body contains pushed_by and pushed_at')
      sothat('audit trail is visible')
    then('issue body contains priority/yieldage/leverage placeholders')
    then('issue body contains task description after separator')


# usecase.12 = os.fileops task format

given('a task pushed to os.fileops')
  when('the task file is read')
    then('file has yaml frontmatter with exid, title, status, pushed_by, pushed_at')
      sothat('metadata is machine-readable')
    then('file body matches gh.issues format')
      sothat('format is consistent across channels')


# usecase.13 = channel validation

given('any context')
  when('radio.task.push --title "task"')
    then('error: --via channel is required')
      sothat('channel selection is explicit')

  when('radio.task.push --via gh.issues --via os.fileops --title "task"')
    then('error: --via specified twice')
      sothat('duplicate flags are rejected early')

  when('radio.task.pull --list')
    then('error: --via channel is required')


# usecase.14 = edge cases

given('a task with special characters in title')
  when('radio.task.push --via gh.issues --title "fix: handle `backticks` & ampersands" --description "desc"')
    then('task is created with escaped title')
      sothat('special characters do not break the command')

given('a task with multiline description')
  when('radio.task.push --via gh.issues --title "task" --description "line1\nline2"')
    then('task is created with multiline description preserved')
      sothat('rich descriptions are supported')

given('invalid status value')
  when('radio.task.push --via gh.issues --exid 142 --status INVALID')
    then('error: status must be QUEUED, CLAIMED, or DELIVERED')
      sothat('invalid status values are rejected')

given('push status without exid')
  when('radio.task.push --via gh.issues --status CLAIMED')
    then('error: --exid required when --status is specified')
      sothat('status updates require task reference')
