# blueprint: dispatcher radio implementation

> step-by-step implementation plan for dispatcher radio feature

---

## filediffs

**legend:** `[+]` create Â· `[~]` update Â· `[-]` delete

```
src/
â”œâ”€â”€ domain.objects/
â”‚   â”œâ”€â”€ [+] RadioTask.ts
â”‚   â”œâ”€â”€ [+] RadioTaskStatus.ts
â”‚   â”œâ”€â”€ [+] RadioChannel.ts
â”‚   â”œâ”€â”€ [+] RadioTaskRepo.ts
â”‚   â””â”€â”€ [+] IdempotencyMode.ts
â”œâ”€â”€ domain.operations/radio/
â”‚   â”œâ”€â”€ task/
â”‚   â”‚   â”œâ”€â”€ format/
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] composeTaskIntoGhIssues.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] composeTaskIntoGhIssues.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] extractTaskFromGhIssues.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] extractTaskFromGhIssues.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] composeTaskIntoOsFileops.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] composeTaskIntoOsFileops.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] extractTaskFromOsFileops.ts
â”‚   â”‚   â”‚   â””â”€â”€ [+] extractTaskFromOsFileops.test.ts
â”‚   â”‚   â”œâ”€â”€ push/
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] radioTaskPush.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] radioTaskPush.via-gh-issues.integration.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] radioTaskPush.via-os-fileops.integration.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] setFullRadioTask.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] setFullRadioTask.via-gh-issues.integration.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] setFullRadioTask.via-os-fileops.integration.test.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] setPartRadioTask.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [+] setPartRadioTask.via-gh-issues.integration.test.ts
â”‚   â”‚   â”‚   â””â”€â”€ [+] setPartRadioTask.via-os-fileops.integration.test.ts
â”‚   â”‚   â””â”€â”€ pull/
â”‚   â”‚       â”œâ”€â”€ [+] radioTaskPull.ts
â”‚   â”‚       â”œâ”€â”€ [+] radioTaskPull.via-gh-issues.integration.test.ts
â”‚   â”‚       â””â”€â”€ [+] radioTaskPull.via-os-fileops.integration.test.ts
â”‚   â””â”€â”€ bootstrap/
â”‚       â”œâ”€â”€ [+] bootstrapRadioDir.ts
â”‚       â”œâ”€â”€ [+] bootstrapRadioDir.integration.test.ts
â”‚       â”œâ”€â”€ [+] getRadioPath.ts
â”‚       â””â”€â”€ [+] getRadioPath.test.ts
â”œâ”€â”€ access/daos/daoRadioTask/
â”‚   â”œâ”€â”€ [+] index.ts
â”‚   â”œâ”€â”€ [+] daoRadioTaskViaGhIssues.ts
â”‚   â”œâ”€â”€ [+] daoRadioTaskViaGhIssues.integration.test.ts
â”‚   â”œâ”€â”€ [+] daoRadioTaskViaOsFileops.ts
â”‚   â””â”€â”€ [+] daoRadioTaskViaOsFileops.integration.test.ts
â”œâ”€â”€ infra/git/
â”‚   â”œâ”€â”€ [+] getRepoFromGitContext.ts
â”‚   â”œâ”€â”€ [+] getRepoFromGitContext.test.ts
â”‚   â”œâ”€â”€ [+] getCurrentBranch.ts
â”‚   â”œâ”€â”€ [+] getCurrentBranch.test.ts
â”‚   â”œâ”€â”€ [+] getCurrentActor.ts
â”‚   â””â”€â”€ [+] getCurrentActor.test.ts
â”œâ”€â”€ contract/cli/
â”‚   â”œâ”€â”€ [+] radioTaskPush.ts
â”‚   â””â”€â”€ [+] radioTaskPull.ts
â”œâ”€â”€ domain.roles/dispatcher/skills/
â”‚   â”œâ”€â”€ [+] radio.task.push.sh
â”‚   â””â”€â”€ [+] radio.task.pull.sh
â””â”€â”€ [~] index.ts
blackbox/role=dispatcher/
â”œâ”€â”€ [+] skill.radio.task.push.via-gh-issues.acceptance.test.ts
â”œâ”€â”€ [+] skill.radio.task.push.via-os-fileops.acceptance.test.ts
â”œâ”€â”€ [+] skill.radio.task.pull.via-gh-issues.acceptance.test.ts
â””â”€â”€ [+] skill.radio.task.pull.via-os-fileops.acceptance.test.ts
```

---

## codepaths

**legend:** `[+]` create Â· `[~]` update Â· `[â—‹]` retain Â· `[-]` delete Â· `[â†]` reuse Â· `[â†’]` eject

### radio.task.push --via gh.issues (create new task)

```
[+] radio.task.push.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPush
    â””â”€â”€ [+] cliRadioTaskPush [â† portable-skills-pattern]
        â””â”€â”€ [+] radioTaskPush
            â”œâ”€â”€ [+] getRepoFromGitContext
            â””â”€â”€ [+] setFullRadioTask
                â””â”€â”€ [+] getDaoRadioTask
                    â””â”€â”€ [+] daoRadioTaskViaGhIssues [â† gh patterns research]
                        â”œâ”€â”€ get.one.byUnique
                        â”‚   â””â”€â”€ [+] extractTaskFromGhIssues
                        â””â”€â”€ set.findsert
                            â””â”€â”€ [+] composeTaskIntoGhIssues
```

### radio.task.push --via gh.issues --exid (claim/deliver/edit)

```
[+] radio.task.push.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPush
    â””â”€â”€ [+] cliRadioTaskPush
        â””â”€â”€ [+] radioTaskPush
            â”œâ”€â”€ [+] getRepoFromGitContext
            â””â”€â”€ [+] setPartRadioTask
                â”œâ”€â”€ [+] getCurrentBranch
                â”œâ”€â”€ [+] getCurrentActor
                â””â”€â”€ [+] getDaoRadioTask
                    â””â”€â”€ [+] daoRadioTaskViaGhIssues
                        â”œâ”€â”€ get.one.byPrimary
                        â”‚   â””â”€â”€ [+] extractTaskFromGhIssues
                        â””â”€â”€ set.upsert
                            â””â”€â”€ [+] composeTaskIntoGhIssues
```

### radio.task.push --via os.fileops (create new task)

```
[+] radio.task.push.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPush
    â””â”€â”€ [+] cliRadioTaskPush
        â””â”€â”€ [+] radioTaskPush
            â”œâ”€â”€ [+] getRepoFromGitContext
            â”œâ”€â”€ [+] bootstrapRadioDir
            â”‚   â””â”€â”€ [+] getRadioPath
            â””â”€â”€ [+] setFullRadioTask
                â””â”€â”€ [+] getDaoRadioTask
                    â””â”€â”€ [+] daoRadioTaskViaOsFileops
                        â”œâ”€â”€ get.one.byUnique
                        â”‚   â”œâ”€â”€ [+] getRadioPath
                        â”‚   â””â”€â”€ [+] extractTaskFromOsFileops [â† gray-matter]
                        â””â”€â”€ set.findsert
                            â”œâ”€â”€ [+] getRadioPath
                            â””â”€â”€ [+] composeTaskIntoOsFileops
```

### radio.task.push --via os.fileops --exid (claim/deliver/edit)

```
[+] radio.task.push.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPush
    â””â”€â”€ [+] cliRadioTaskPush
        â””â”€â”€ [+] radioTaskPush
            â”œâ”€â”€ [+] getRepoFromGitContext
            â”œâ”€â”€ [+] bootstrapRadioDir
            â”‚   â””â”€â”€ [+] getRadioPath
            â””â”€â”€ [+] setPartRadioTask
                â”œâ”€â”€ [+] getCurrentBranch
                â”œâ”€â”€ [+] getCurrentActor
                â””â”€â”€ [+] getDaoRadioTask
                    â””â”€â”€ [+] daoRadioTaskViaOsFileops
                        â”œâ”€â”€ get.one.byPrimary
                        â”‚   â”œâ”€â”€ [+] getRadioPath
                        â”‚   â””â”€â”€ [+] extractTaskFromOsFileops
                        â””â”€â”€ set.upsert
                            â”œâ”€â”€ [+] getRadioPath
                            â””â”€â”€ [+] composeTaskIntoOsFileops
```

### radio.task.pull --via gh.issues --all

```
[+] radio.task.pull.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPull
    â””â”€â”€ [+] cliRadioTaskPull
        â””â”€â”€ [+] radioTaskPull
            â”œâ”€â”€ [+] getRepoFromGitContext
            â””â”€â”€ [+] getDaoRadioTask
                â””â”€â”€ [+] daoRadioTaskViaGhIssues
                    â””â”€â”€ get.all
                        â””â”€â”€ [+] extractTaskFromGhIssues
```

### radio.task.pull --via gh.issues --exid (with auto-cache)

```
[+] radio.task.pull.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPull
    â””â”€â”€ [+] cliRadioTaskPull
        â””â”€â”€ [+] radioTaskPull
            â”œâ”€â”€ [+] getRepoFromGitContext
            â”œâ”€â”€ [+] getDaoRadioTask
            â”‚   â””â”€â”€ [+] daoRadioTaskViaGhIssues
            â”‚       â””â”€â”€ get.one.byPrimary
            â”‚           â””â”€â”€ [+] extractTaskFromGhIssues
            â”œâ”€â”€ [+] bootstrapRadioDir
            â”‚   â””â”€â”€ [+] getRadioPath
            â””â”€â”€ [+] getDaoRadioTask
                â””â”€â”€ [+] daoRadioTaskViaOsFileops
                    â””â”€â”€ set.findsert
                        â”œâ”€â”€ [+] getRadioPath
                        â””â”€â”€ [+] composeTaskIntoOsFileops
```

### radio.task.pull --via os.fileops --all

```
[+] radio.task.pull.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPull
    â””â”€â”€ [+] cliRadioTaskPull
        â””â”€â”€ [+] radioTaskPull
            â”œâ”€â”€ [+] getRepoFromGitContext
            â””â”€â”€ [+] getDaoRadioTask
                â””â”€â”€ [+] daoRadioTaskViaOsFileops
                    â””â”€â”€ get.all
                        â”œâ”€â”€ [+] getRadioPath
                        â””â”€â”€ [+] extractTaskFromOsFileops
```

### radio.task.pull --via os.fileops --exid

```
[+] radio.task.pull.sh
â””â”€â”€ [~] index.ts::cli.radioTaskPull
    â””â”€â”€ [+] cliRadioTaskPull
        â””â”€â”€ [+] radioTaskPull
            â”œâ”€â”€ [+] getRepoFromGitContext
            â””â”€â”€ [+] getDaoRadioTask
                â””â”€â”€ [+] daoRadioTaskViaOsFileops
                    â””â”€â”€ get.one.byPrimary
                        â”œâ”€â”€ [+] getRadioPath
                        â””â”€â”€ [+] extractTaskFromOsFileops
```

---

## legend

### file operations
| marker | definition          |
| ------ | ------------------- |
| `[+]`  | create new file     |
| `[~]`  | modify file         |
| `[-]`  | delete file         |
| `[â—‹]`  | retain (no changes) |

### code operations
| marker | definition                  |
| ------ | --------------------------- |
| `[+]`  | create new code             |
| `[â†]`  | reuse pattern from codebase |
| `[â†’]`  | eject/refactor code         |

---

## phase 0: foundation

### 0.1 domain objects

create core domain objects that all other code depends on.

```
src/domain.objects/
  [+] RadioTask.ts
  [+] RadioTaskStatus.ts
  [+] RadioChannel.ts
  [+] RadioTaskRepo.ts
  [+] IdempotencyMode.ts
```

**codepaths**:

```typescript
// RadioTask.ts [+]
import { DomainEntity } from 'domain-objects';
import { IsoDateStamp } from 'iso-time';

interface RadioTask {
  exid: string;
  title: string;
  description: string;
  status: RadioTaskStatus;
  repo: RadioTaskRepo;
  pushedBy: string;
  pushedAt: IsoDateStamp;
  claimedBy: string | null;
  claimedAt: IsoDateStamp | null;
  deliveredAt: IsoDateStamp | null;
  branch: string | null;
}

class RadioTask extends DomainEntity<RadioTask> implements RadioTask {
  public static primary = ['exid'] as const;
  public static unique = ['repo', 'title'] as const;
  public static updatable = ['title', 'description', 'status', 'claimedBy', 'claimedAt', 'deliveredAt', 'branch'] as const;
  public static nested = { repo: RadioTaskRepo };
}

// RadioTaskStatus.ts [+]
import { createIsOfEnum } from 'type-fns';

enum RadioTaskStatus {
  QUEUED = 'QUEUED',
  CLAIMED = 'CLAIMED',
  DELIVERED = 'DELIVERED',
}
const isRadioTaskStatus = createIsOfEnum(RadioTaskStatus);

// RadioChannel.ts [+]
import { createIsOfEnum } from 'type-fns';

enum RadioChannel {
  GH_ISSUES = 'gh.issues',
  OS_FILEOPS = 'os.fileops',
}
const isRadioChannel = createIsOfEnum(RadioChannel);

// RadioTaskRepo.ts [+]
import { DomainLiteral } from 'domain-objects';

interface RadioTaskRepo {
  owner: string;
  name: string;
}
class RadioTaskRepo extends DomainLiteral<RadioTaskRepo> implements RadioTaskRepo {}

// IdempotencyMode.ts [+]
import { createIsOfEnum } from 'type-fns';

enum IdempotencyMode {
  FINDSERT = 'findsert',
  UPSERT = 'upsert',
}
const isIdempotencyMode = createIsOfEnum(IdempotencyMode);
```

**tests**:
- unit tests for domain object instantiation
- unit tests for unique/primary key extraction via `getUniqueIdentifier`

---

## phase 1: format utilities

### 1.1 task format compose/extract

create utilities to convert RadioTask to/from channel-specific formats.

```
src/domain.operations/radio/task/format/
  [+] composeTaskIntoGhIssues.ts
  [+] composeTaskIntoGhIssues.test.ts
  [+] extractTaskFromGhIssues.ts
  [+] extractTaskFromGhIssues.test.ts
  [+] composeTaskIntoOsFileops.ts
  [+] composeTaskIntoOsFileops.test.ts
  [+] extractTaskFromOsFileops.ts
  [+] extractTaskFromOsFileops.test.ts
```

**codepaths**:

```typescript
// composeTaskIntoGhIssues.ts [+]
/**
 * .what = compose github issue body from RadioTask
 * .why = consistent format across all radio tasks on gh.issues
 */
export const composeTaskIntoGhIssues = (
  input: { task: RadioTask },
): string => {
  // return formatted markdown body
  // include ğŸ¦« dispatch header, ğŸ’§ enqueued section, ğŸŒ² tree section
};

// extractTaskFromGhIssues.ts [+]
/**
 * .what = extract RadioTask from github issue
 * .why = extract structured data from issue format
 */
export const extractTaskFromGhIssues = (
  input: { issueNumber: string; title: string; body: string; state: string; assignees: string[] },
): RadioTask => {
  // extract from markdown body
  // extract metadata from structure
};

// composeTaskIntoOsFileops.ts [+]
/**
 * .what = compose task file content with yaml frontmatter
 * .why = consistent format for local task files
 */
export const composeTaskIntoOsFileops = (
  input: { task: RadioTask },
): string => {
  // yaml frontmatter + markdown body
};

// extractTaskFromOsFileops.ts [+] [â† gray-matter pattern]
/**
 * .what = extract RadioTask from local task file
 * .why = extract structured data from file format
 */
export const extractTaskFromOsFileops = (
  input: { content: string },
): RadioTask => {
  // extract yaml frontmatter via gray-matter
  // extract task from frontmatter
};
```

**tests**:
- unit tests for compose â†’ extract roundtrip
- unit tests for edge cases (special characters, multiline descriptions)
- snapshot tests for output format

---

## phase 2: dao adapters

### 2.1 dao interface

```
src/access/daos/daoRadioTask/
  [+] index.ts              # interface + adapter selector
```

**codepaths**:

```typescript
// index.ts [+]
import { RefByPrimary, RefByUnique } from 'domain-objects';

export interface DaoRadioTask {
  get: {
    one: {
      byPrimary(input: RefByPrimary<typeof RadioTask>): Promise<RadioTask | null>;
      byUnique(input: RefByUnique<typeof RadioTask>): Promise<RadioTask | null>;
    };
    all(input: {
      repo: RadioTaskRepo;
      filter?: { status?: RadioTaskStatus };
      limit?: number;
    }): Promise<RadioTask[]>;
  };
  set: {
    findsert(input: { task: RadioTask }): Promise<RadioTask>;
    upsert(input: { task: RadioTask }): Promise<RadioTask>;
  };
  del(input: RefByPrimary<typeof RadioTask>): Promise<void>;
}

export const getDaoRadioTask = (input: { channel: RadioChannel }): DaoRadioTask => {
  if (input.channel === RadioChannel.GH_ISSUES) return daoRadioTaskViaGhIssues;
  if (input.channel === RadioChannel.OS_FILEOPS) return daoRadioTaskViaOsFileops;
  throw new UnexpectedCodePathError('unknown channel', { channel: input.channel });
};
```

### 2.2 gh.issues adapter

```
src/access/daos/daoRadioTask/
  [+] daoRadioTaskViaGhIssues.ts
  [+] daoRadioTaskViaGhIssues.integration.test.ts
```

**codepaths**:

```typescript
// daoRadioTaskViaGhIssues.ts [+] [â† gh cli patterns from research]
/**
 * .what = dao adapter for github issues channel
 * .why = enables radio task persistence via github issues
 */
export const daoRadioTaskViaGhIssues: DaoRadioTask = {
  get: {
    one: {
      byPrimary: async ({ exid }) => {
        // gh issue view $exid --repo $repo --json number,title,body,state,assignees
        // extract json, convert to RadioTask via extractTaskFromGhIssues
      },
      byUnique: async ({ repo, title }) => {
        // gh issue list --search "ğŸ™ï¸ task: $title in:title" --repo $repo --json ...
        // find match, extract to RadioTask
      },
    },
    all: async ({ repo, filter, limit }) => {
      // gh issue list --state open|all --search "ğŸ™ï¸ task:" --limit $limit --json ...
      // filter by status via body extraction
    },
  },
  set: {
    findsert: async ({ task }) => {
      // get.one.byUnique first
      // if found, return found
      // else gh issue create
    },
    upsert: async ({ task }) => {
      // get.one.byPrimary or byUnique
      // if found, gh issue edit
      // else gh issue create
    },
  },
  del: async ({ exid }) => {
    // gh issue close $exid --reason "not planned"
  },
};
```

**tests**:
- integration tests against real github repo (test repo)
- tests for create, read, update, close operations
- tests for error handler (not found, auth failed)

### 2.3 os.fileops adapter

```
src/access/daos/daoRadioTask/
  [+] daoRadioTaskViaOsFileops.ts
  [+] daoRadioTaskViaOsFileops.integration.test.ts
```

**codepaths**:

```typescript
// daoRadioTaskViaOsFileops.ts [+]
/**
 * .what = dao adapter for local filesystem channel
 * .why = enables radio task persistence via filesystem for offline access
 */
export const daoRadioTaskViaOsFileops: DaoRadioTask = {
  get: {
    one: {
      byPrimary: async ({ exid }) => {
        // read ~/git/.radio/$owner/$repo/task.$exid._.md
        // extract via extractTaskFromOsFileops
      },
      byUnique: async ({ repo, title }) => {
        // glob for task.*._.md in repo radio dir
        // extract each, find title match
      },
    },
    all: async ({ repo, filter, limit }) => {
      // if filter.status, glob for *._.status=$status.flag
      // else glob for task.*._.md
      // extract and return, apply limit
    },
  },
  set: {
    findsert: async ({ task }) => {
      // get.one.byUnique first
      // if found, return found
      // else write file + status flag
    },
    upsert: async ({ task }) => {
      // get.one.byPrimary or byUnique
      // if found, create .bak, then overwrite
      // else write new file
      // update status flag
    },
  },
  del: async ({ exid }) => {
    // remove task file + status flag
  },
};
```

**tests**:
- integration tests with temp directories
- tests for file create, read, update, delete
- tests for status flag file management
- tests for backup file creation

---

## phase 3: utilities

### 3.1 git context resolution (infra)

```
src/infra/git/
  [+] getRepoFromGitContext.ts
  [+] getRepoFromGitContext.test.ts
  [+] getCurrentBranch.ts
  [+] getCurrentBranch.test.ts
  [+] getCurrentActor.ts
  [+] getCurrentActor.test.ts
```

**codepaths**:

```typescript
// getRepoFromGitContext.ts [+]
/**
 * .what = resolve RadioTaskRepo from current git directory
 * .why = default --repo to current git context
 */
export const getRepoFromGitContext = async (): Promise<RadioTaskRepo | null> => {
  // gh repo view --json nameWithOwner -q '.nameWithOwner'
  // or parse git remote -v
};

// getCurrentBranch.ts [+]
/**
 * .what = get current git branch name
 * .why = record branch when claim task
 */
export const getCurrentBranch = async (): Promise<string> => {
  // git branch --show-current
};

// getCurrentActor.ts [+]
/**
 * .what = get current git/gh user
 * .why = record who pushed/claimed task
 */
export const getCurrentActor = async (): Promise<string> => {
  // gh api user -q '.login' or git config user.name
};
```

### 3.2 radio directory bootstrap (domain.operations)

```
src/domain.operations/radio/bootstrap/
  [+] bootstrapRadioDir.ts
  [+] bootstrapRadioDir.integration.test.ts
  [+] getRadioPath.ts
  [+] getRadioPath.test.ts
```

**codepaths**:

```typescript
// getRadioPath.ts [+]
/**
 * .what = compute paths for radio task storage
 * .why = consistent path resolution for global and local radio dirs
 */
export const getRadioPath = (input: {
  repo: RadioTaskRepo;
  exid?: string;
  variant: 'global' | 'local';
}): {
  radioDir: string;
  taskFile?: string;
  statusFlag?: string;
  backup?: string;
} => {
  // global: ~/git/.radio/$owner/$repo/
  // local: .radio/ (symlink)
};

// bootstrapRadioDir.ts [+]
/**
 * .what = ensure radio directory structure exists
 * .why = bootstrap global and local radio dirs on first use
 */
export const bootstrapRadioDir = async (
  input: { repo: RadioTaskRepo; cwd: string },
): Promise<{ globalDir: string; localSymlink: string }> => {
  // findsert ~/git/.radio/readme.md
  // findsert ~/git/.radio/$owner/$repo/readme.md
  // findsert .radio/ symlink â†’ global
};
```

---

## phase 4: skill operations

### 4.1 radioTaskPush

```
src/domain.operations/radio/task/push/
  [+] radioTaskPush.ts
  [+] radioTaskPush.via-gh-issues.integration.test.ts
  [+] radioTaskPush.via-os-fileops.integration.test.ts
  [+] setFullRadioTask.ts
  [+] setFullRadioTask.via-gh-issues.integration.test.ts
  [+] setFullRadioTask.via-os-fileops.integration.test.ts
  [+] setPartRadioTask.ts
  [+] setPartRadioTask.via-gh-issues.integration.test.ts
  [+] setPartRadioTask.via-os-fileops.integration.test.ts
```

**codepaths**:

```typescript
// setFullRadioTask.ts [+]
/**
 * .what = create a new task on a channel
 * .why = enables broadcast of new tasks with full required data
 */
export const setFullRadioTask = async (
  input: {
    via: RadioChannel;
    idem?: IdempotencyMode;
    task: Pick<RadioTask, 'repo' | 'title' | 'description'>;
  },
  context: { log: LogMethods },
): Promise<{
  task: RadioTask;
  outcome: 'created' | 'found';
}> => {
  // title + description required (enforced by types)
  // bootstrap radio dir for os.fileops
  // select dao, use findsert or upsert based on idem flag
};

// setPartRadioTask.ts [+]
/**
 * .what = update a found task on a channel
 * .why = enables status transitions and partial updates
 */
export const setPartRadioTask = async (
  input: {
    via: RadioChannel;
    task: Pick<RadioTask, 'exid'> & Partial<Pick<RadioTask, 'repo' | 'title' | 'description' | 'status'>>;
  },
  context: { log: LogMethods },
): Promise<{
  task: RadioTask;
  outcome: 'updated';
  backup?: string;
}> => {
  // exid required (enforced by types)
  // handle status transitions (QUEUED â†’ CLAIMED â†’ DELIVERED)
  // validate lifecycle order
  // create backup on edit
};

// radioTaskPush.ts [+]
/**
 * .what = dispatch to setFullRadioTask or setPartRadioTask
 * .why = single entry point for cli that routes based on input shape
 */
export const radioTaskPush = async (
  input: {
    via: RadioChannel;
    idem?: IdempotencyMode;
    task: Partial<Pick<RadioTask, 'exid' | 'repo' | 'title' | 'description' | 'status'>>;
  },
  context: { log: LogMethods },
): Promise<{
  task: RadioTask;
  outcome: 'created' | 'found' | 'updated';
  backup?: string;
}> => {
  // resolve repo from git context if not provided
  const repo = input.task.repo ?? await getRepoFromGitContext();
  if (!repo) throw new BadRequestError('--repo required (not in a git repo)');

  // bootstrap radio dir for os.fileops
  if (input.via === RadioChannel.OS_FILEOPS) {
    await bootstrapRadioDir({ repo, cwd: process.cwd() });
  }

  // dispatch to setPartRadioTask if exid provided (update mode)
  if (input.task.exid) {
    return setPartRadioTask(
      { via: input.via, task: { ...input.task, exid: input.task.exid, repo } },
      context,
    );
  }

  // dispatch to setFullRadioTask (create mode)
  if (!input.task.title) throw new BadRequestError('--title required for new task');
  if (!input.task.description) throw new BadRequestError('--description required for new task');

  return setFullRadioTask(
    { via: input.via, idem: input.idem, task: { repo, title: input.task.title, description: input.task.description } },
    context,
  );
};
```

**tests**:
- integration tests for setFullRadioTask (create new task, both channels)
- integration tests for setPartRadioTask (claim, deliver, edit)
- integration tests for radioTaskPush dispatch logic
- integration tests for idempotency modes
- integration tests for error cases (auth, validation, lifecycle order)

### 4.2 radioTaskPull

```
src/domain.operations/radio/task/pull/
  [+] radioTaskPull.ts
  [+] radioTaskPull.via-gh-issues.integration.test.ts
  [+] radioTaskPull.via-os-fileops.integration.test.ts
```

**codepaths**:

```typescript
// radioTaskPull.ts [+]
/**
 * .what = read task(s) from a channel
 * .why = enables discovery and retrieval of tasks from remote repositories
 */

// overload: list tasks
export function radioTaskPull(
  input: {
    via: RadioChannel;
    repo?: RadioTaskRepo;
    all: { filter?: { status?: RadioTaskStatus }; limit?: number };
  },
  context: { log: LogMethods },
): Promise<{ tasks: RadioTask[] }>;

// overload: pull specific task (by primary or unique ref)
export function radioTaskPull(
  input: { via: RadioChannel; repo?: RadioTaskRepo; one: Omit<Ref<typeof RadioTask>, 'repo'> },
  context: { log: LogMethods },
): Promise<{ task: RadioTask; cached: boolean }>;

// implementation
export async function radioTaskPull(
  input: {
    via: RadioChannel;
    repo?: RadioTaskRepo;
    all?: { filter?: { status?: RadioTaskStatus }; limit?: number };
    one?: Omit<Ref<typeof RadioTask>, 'repo'>;
  },
  context: { log: LogMethods },
): Promise<{ tasks: RadioTask[] } | { task: RadioTask; cached: boolean }> {
  // resolve repo from git context if not provided
  const repo = input.repo ?? await getRepoFromGitContext();
  if (!repo) throw new BadRequestError('--repo required (not in a git repo)');

  const dao = getDaoRadioTask({ channel: input.via });

  // list mode
  if (input.all) {
    const tasks = await dao.get.all({ repo, ...input.all });
    return { tasks };
  }

  // pull one by ref (primary or unique)
  if (input.one) {
    const ref = input.one;
    const task = 'exid' in ref
      ? await dao.get.one.byPrimary({ exid: ref.exid })
      : await dao.get.one.byUnique({ repo, title: ref.title });

    if (!task) throw new BadRequestError('task not found on channel', { ref });

    // auto-cache to os.fileops if pull from remote
    let cached = false;
    if (input.via !== RadioChannel.OS_FILEOPS) {
      const localDao = getDaoRadioTask({ channel: RadioChannel.OS_FILEOPS });
      await bootstrapRadioDir({ repo, cwd: process.cwd() });
      await localDao.set.findsert({ task });
      cached = true;
    }

    return { task, cached };
  }

  throw new BadRequestError('either --all or --one required');
};
```

**tests**:
- integration tests for list tasks (both channels)
- integration tests for list with filters
- integration tests for pull specific task
- integration tests for auto-cache on remote pull
- integration tests for error cases

---

## phase 5: cli entry points

### 5.1 cli argument parse

```
src/contract/cli/
  [+] radioTaskPush.ts
  [+] radioTaskPull.ts
```

**codepaths**:

```typescript
// radioTaskPush.ts [+] [â† portable-skills-pattern]
import { z } from 'zod';
import { getCliArgs } from '../../infra/cli';
import { radioTaskPush } from '../../domain.operations/radio/task/push/radioTaskPush';

const schemaOfArgs = z.object({
  named: z.object({
    via: z.nativeEnum(RadioChannel),
    idem: z.nativeEnum(IdempotencyMode).optional(),
    // task fields (flattened for cli ergonomics)
    repo: z.string().optional(),
    title: z.string().optional(),
    description: z.string().optional(),
    exid: z.string().optional(),
    status: z.nativeEnum(RadioTaskStatus).optional(),
  }),
  ordered: z.array(z.string()).default([]),
});

export const cliRadioTaskPush = async () => {
  const { named } = getCliArgs({ schema: schemaOfArgs });

  // restructure flat cli args into nested input
  const repo = named.repo ? extractRepo(named.repo) : undefined;

  const result = await radioTaskPush(
    {
      via: named.via,
      idem: named.idem,
      task: {
        repo,
        exid: named.exid,
        title: named.title,
        description: named.description,
        status: named.status,
      },
    },
    { log: console },
  );

  // format output
  console.log(`ğŸ™ï¸ ${result.outcome}: ${result.task.title}`);
  // ...
};

// radioTaskPull.ts [+]
// similar pattern for pull
```

### 5.2 shell skills

```
src/domain.roles/dispatcher/skills/
  [+] radio.task.push.sh
  [+] radio.task.pull.sh
```

**codepaths**:

```bash
# radio.task.push.sh [+] [â† portable-skills-pattern]
#!/usr/bin/env bash
set -euo pipefail
exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.radioTaskPush())" -- "$@"

# radio.task.pull.sh [+]
#!/usr/bin/env bash
set -euo pipefail
exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.radioTaskPull())" -- "$@"
```

### 5.3 export from index

```
src/index.ts
  [~] add cli exports
```

**codepaths**:

```typescript
// src/index.ts [~]
import { cliRadioTaskPush } from './contract/cli/radioTaskPush';
import { cliRadioTaskPull } from './contract/cli/radioTaskPull';

export const cli = {
  // ... prior exports
  radioTaskPush: cliRadioTaskPush,
  radioTaskPull: cliRadioTaskPull,
};
```

---

## phase 6: acceptance tests

### 6.1 blackbox acceptance tests

```
blackbox/role=dispatcher/
  [+] skill.radio.task.push.via-gh-issues.acceptance.test.ts
  [+] skill.radio.task.push.via-os-fileops.acceptance.test.ts
  [+] skill.radio.task.pull.via-gh-issues.acceptance.test.ts
  [+] skill.radio.task.pull.via-os-fileops.acceptance.test.ts
```

**codepaths**:

```typescript
// skill.radio.task.push.via-gh-issues.acceptance.test.ts [+] [â† test patterns research]
import { given, when, then, useBeforeAll } from 'test-fns';
import { genConsumerRepo } from '../.test/infra/genConsumerRepo';
import { runRhachetSkill } from '../.test/infra/runRhachetSkill';

describe('radio.task.push via gh.issues', () => {
  const consumer = genConsumerRepo({ prefix: 'radio-push-' });
  afterAll(() => consumer.cleanup());

  given('[case1] inside a git repo with gh cli authenticated', () => {
    when('[t0] radio.task.push --via gh.issues --title "..." --description "..."', () => {
      const result = useBeforeAll(async () =>
        runRhachetSkill({
          repo: 'rhachet-roles-bhuild',
          role: 'dispatcher',
          skill: 'radio.task.push',
          args: '--via gh.issues --title "test task" --description "test description"',
          repoDir: consumer.repoDir,
        }),
      );

      then('output shows broadcast confirmation', () => {
        expect(result.output).toContain('ğŸ™ï¸');
      });

      then('output shows created issue number', () => {
        expect(result.output).toMatch(/#\d+/);
      });
    });
  });

  // ... additional cases from criteria
});
```

**tests per criteria (gh.issues)**:
- usecase.1: push to gh.issues (create)
- usecase.3: claim task
- usecase.4: deliver task
- usecase.9: edit with idempotency
- usecase.10: cross-repo dispatch
- usecase.11: gh.issues task format
- usecase.13: channel validation errors
- usecase.14: edge cases

```typescript
// skill.radio.task.push.via-os-fileops.acceptance.test.ts [+]
// ... similar structure for os.fileops tests
```

**tests per criteria (os.fileops)**:
- usecase.2: push to os.fileops (create)
- usecase.2b: cross-repo os.fileops
- usecase.3: claim task (os.fileops)
- usecase.4: deliver task (os.fileops)
- usecase.12: os.fileops task format
- usecase.13: channel validation errors

```typescript
// skill.radio.task.pull.via-gh-issues.acceptance.test.ts [+]
```

**tests per criteria (gh.issues pull)**:
- usecase.5: list from gh.issues
- usecase.7: pull specific task
- usecase.8: auto-cache on remote pull

```typescript
// skill.radio.task.pull.via-os-fileops.acceptance.test.ts [+]
```

**tests per criteria (os.fileops pull)**:
- usecase.6: list from os.fileops
- usecase.7: pull specific task (local)

---

## test coverage matrix

| layer            | test type          | files                                 | criteria coverage             |
| ---------------- | ------------------ | ------------------------------------- | ----------------------------- |
| domain objects   | unit               | `*.test.ts`                           | instantiation, keys           |
| format utilities | unit               | `*.test.ts`                           | compose/extract roundtrip     |
| dao adapters     | integration        | `*.via-{channel}.integration.test.ts` | all dao methods per channel   |
| git utilities    | unit + integration | `*.test.ts`                           | git context resolution        |
| radio bootstrap  | unit + integration | `*.test.ts`                           | path compute, dir bootstrap   |
| skill operations | integration        | `*.via-{channel}.integration.test.ts` | all usecases per channel      |
| cli entry points | â€”                  | via acceptance                        | arg parse validation          |
| shell skills     | acceptance         | `*.via-{channel}.acceptance.test.ts`  | blackbox criteria per channel |

---

## dependency order

```
1. domain objects (no deps)
   â†“
2. format utilities (depends on domain objects)
   â†“
3. git utilities (git context resolution)
   â†“
4. radio bootstrap (depends on domain objects)
   â†“
5. dao adapters (depends on format, git, bootstrap)
   â†“
6. skill operations (depends on dao, bootstrap)
   â†“
7. cli entry points (depends on operations)
   â†“
8. shell skills (depends on cli)
   â†“
9. acceptance tests (depends on all)
```

---

## file summary

### creates `[+]`

| path                                                                   | purpose                        |
| ---------------------------------------------------------------------- | ------------------------------ |
| `src/domain.objects/RadioTask.ts`                                      | core entity                    |
| `src/domain.objects/RadioTaskStatus.ts`                                | status literal                 |
| `src/domain.objects/RadioChannel.ts`                                   | channel literal                |
| `src/domain.objects/RadioTaskRepo.ts`                                  | repo literal                   |
| `src/domain.objects/IdempotencyMode.ts`                                | idem literal                   |
| `src/domain.operations/radio/task/format/*.ts`                         | format utilities               |
| `src/domain.operations/radio/bootstrap/*.ts`                           | radio dir utilities            |
| `src/access/daos/daoRadioTask/*.ts`                                    | dao adapters                   |
| `src/infra/git/*.ts`                                                   | git context utilities          |
| `src/domain.operations/radio/task/push/*.ts`                           | push operation                 |
| `src/domain.operations/radio/task/pull/*.ts`                           | pull operation                 |
| `src/contract/cli/radioTaskPush.ts`                                    | cli entry                      |
| `src/contract/cli/radioTaskPull.ts`                                    | cli entry                      |
| `src/domain.roles/dispatcher/skills/radio.task.push.sh`                | shell skill                    |
| `src/domain.roles/dispatcher/skills/radio.task.pull.sh`                | shell skill                    |
| `blackbox/role=dispatcher/skill.radio.task.*.via-*.acceptance.test.ts` | acceptance tests (per channel) |

### modifies `[~]`

| path           | change          |
| -------------- | --------------- |
| `src/index.ts` | add cli exports |

---

## implementation sequence

1. **phase 0** (foundation): domain objects â€” no external deps, pure types
2. **phase 1** (format): compose/extract utilities â€” depends on domain objects
3. **phase 2** (dao): adapters â€” depends on format, enables persistence
4. **phase 3** (utilities): git context + radio bootstrap â€” enables skill operations
5. **phase 4** (operations): push/pull logic â€” composes dao + utilities
6. **phase 5** (cli): entry points + skills â€” thin dispatch layer
7. **phase 6** (acceptance): blackbox tests â€” validates full contract

each phase is independently testable before the next begins.
