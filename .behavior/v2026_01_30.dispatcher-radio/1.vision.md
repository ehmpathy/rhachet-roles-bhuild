# vision: dispatcher radio

> a distributed task dispatch system where humans and clones broadcast tasks via channels â€” like a walkie-talkie network for work

---

## the outcome world

### before: the silent workplace

casey has three ideas while she walks to the coffee machine:
- "we should add retry logic to the payment processor"
- "that flaky test in ci needs attention"
- "the readme is outdated after last week's refactor"

by the time she sits down, two are forgotten. the third gets a sticky note that falls behind the monitor.

meanwhile, a clone is idle in another terminal, awaits instructions. the foreman clone could pick up work, but doesn't know there's work to do.

tasks live in heads, sticky notes, slack threads, forgotten gh issues. no broadcast. no coordination.

### after: the radio network

casey, still on her walk to coffee, pulls out her phone:

```sh
rhx radio.task.push \
  --via gh.issues \
  --repo ehmpathy/acme-app \
  --title "add retry logic to payment processor" \
  --description "intermittent failures on stripe webhook. need exponential backoff."
```

the task broadcasts to the gh.issues channel. a ğŸ™ï¸ emoji marks it as radio traffic. github records who pushed it and when.

back at her desk, the foreman clone (active in a tmux pane, inside the acme-app repo) has already pulled the task:

```sh
# --repo defaults to current git repo (ehmpathy/acme-app)
rhx radio.task.pull --via gh.issues --list
# ğŸ™ï¸ tasks on gh.issues (repo: ehmpathy/acme-app)
#    â”œâ”€ #142: add retry logic to payment processor
#    â”œâ”€ #139: fix flaky ci test
#    â””â”€ #137: update readme after auth refactor
```

the foreman claims one:

```sh
rhx radio.task.push --via gh.issues --exid 142 --status CLAIMED
# ğŸ™ï¸ task #142 claimed
#    â””â”€ ğŸŒ² tree planted at vlad/fix-payment-retry
```

the task is now assigned to the clone. the issue description updates with the branch where work happens.

after the work is done:

```sh
rhx radio.task.push --via gh.issues --exid 142 --status DELIVERED
# ğŸ™ï¸ task #142 delivered
#    â””â”€ ğŸŒ² tree delivered at vlad/fix-payment-retry
#    â””â”€ issue closed
```

### the "aha" moment

the value clicks when casey realizes:

> "i can broadcast tasks from anywhere â€” phone, laptop, different repo â€” and any clone tuned to that channel picks them up. once claimed, i know who's on it. once delivered, the loop closes. it's like a radio dispatch system, but for clones."

the radio metaphor lands: push = broadcast, pull = tune in, channels = frequencies.

---

## user experience

### usecase 1: human broadcasts task to clones

**goal**: get an idea out of your head and into the system, fast

**timeline**:
1. idea strikes (anywhere, anytime)
2. broadcast via `radio.task.push --via gh.issues` (--repo defaults to current)
3. forget about it â€” the system remembers who pushed and when
4. later, a clone (or human) claims and executes

**contract**:
```sh
# broadcast a task to a specific repo
rhx radio.task.push \
  --via gh.issues \
  --repo ehmpathy/acme-app \
  --title "implement dark mode toggle" \
  --description "user option in preferences. persist to localstorage."

# output:
# ğŸ™ï¸ broadcast to gh.issues
#    â”œâ”€ repo: ehmpathy/acme-app
#    â”œâ”€ issue #156 created
#    â”œâ”€ pushed by: casey
#    â”œâ”€ pushed at: 2026-01-30
#    â””â”€ url: https://github.com/ehmpathy/acme-app/issues/156
```

### usecase 2: clone claims and delivers task

**goal**: track task lifecycle from enqueued â†’ claimed â†’ delivered

**timeline**:
1. clone lists available tasks via `radio.task.pull --list`
2. clone claims one via `radio.task.push --exid --status CLAIMED`
3. task marked as claimed, branch recorded
4. clone executes the work
5. clone marks delivered via `radio.task.push --exid --status DELIVERED`

**contract**:
```sh
# list available tasks (--repo defaults to current git repo)
rhx radio.task.pull --via gh.issues --list

# claim a task (assigns to current user, records branch)
rhx radio.task.push \
  --via gh.issues \
  --exid 156 \
  --status CLAIMED

# output:
# ğŸ™ï¸ task #156 claimed
#    â”œâ”€ assigned to: foreman
#    â””â”€ ğŸŒ² tree planted at foreman/dark-mode-toggle

# mark task as delivered (closes issue, updates header)
rhx radio.task.push \
  --via gh.issues \
  --exid 156 \
  --status DELIVERED

# output:
# ğŸ™ï¸ task #156 delivered
#    â”œâ”€ ğŸŒ² tree delivered at foreman/dark-mode-toggle
#    â””â”€ issue closed
```

### usecase 3: local-first task reference

**goal**: work on tasks without network dependency

**timeline**:
1. task pulled from gh.issues â†’ auto-cached to `.radio/`
2. clone reads `.radio/task.156._.md` at execution time
3. network goes down â€” doesn't matter, task is local
4. clone completes work, syncs status when online

**contract**:
```sh
# list locally cached tasks (--repo defaults to current git repo)
rhx radio.task.pull --via os.fileops --list

# output:
# ğŸ™ï¸ tasks in .radio/
#    â”œâ”€ task.156._.md (dark mode toggle) [CLAIMED]
#    â””â”€ task.155._.md (payment retry logic) [QUEUED]

# pull specific task from local cache
rhx radio.task.pull --via os.fileops --exid 156

# file structure (local symlink â†’ global):
# .radio/ â†’ ~/git/.radio/ehmpathy/acme-app/
#
# global structure:
# ~/git/.radio/
#   â””â”€ ehmpathy/
#       â””â”€ acme-app/
#           â”œâ”€ task.156._.md
#           â”œâ”€ task.156.bak.2026-01-30.md    # backup if edited
#           â”œâ”€ task.156._.status=CLAIMED.flag
#           â””â”€ task.155._.md
```

### usecase 3b: cross-repo dispatch via os.fileops

**goal**: dispatch tasks to other repos without github dependency

**timeline**:
1. human pushes task to another repo via `--via os.fileops --repo`
2. task is written to global `~/git/.radio/$owner/$repo/`
3. clone in target repo sees task via its local `.radio/` symlink
4. no network required â€” pure filesystem dispatch

**note**: cross-repo operations (`--repo` flag) always use global radio directly. the local `.radio/` symlink only provides access to tasks for the current repo.

**contract**:
```sh
# push task to another repo via filesystem (uses global radio)
rhx radio.task.push \
  --via os.fileops \
  --repo ehmpathy/other-service \
  --title "upgrade typescript to 5.4"

# output:
# ğŸ™ï¸ broadcast to os.fileops
#    â”œâ”€ repo: ehmpathy/other-service
#    â””â”€ path: ~/git/.radio/ehmpathy/other-service/task.{exid}._.md

# pull tasks from another repo (uses global radio)
rhx radio.task.pull --via os.fileops --repo ehmpathy/other-service --list

# output:
# ğŸ™ï¸ tasks in ~/git/.radio/ehmpathy/other-service/
#    â””â”€ task.{exid}._.md (upgrade typescript to 5.4) [QUEUED]

# from inside other-service repo, same task via local symlink:
cd ~/git/other-service
rhx radio.task.pull --via os.fileops --list
# ğŸ™ï¸ tasks in .radio/
#    â””â”€ task.{exid}._.md (upgrade typescript to 5.4) [QUEUED]
```

### usecase 4: edit and update tasks

**goal**: modify task details with idempotency and audit trail

**timeline**:
1. human updates task description
2. system creates .bak before overwrite
3. changes are persisted with idempotency semantics

**contract**:
```sh
# update task title and description (upsert mode)
rhx radio.task.push \
  --via gh.issues \
  --exid 156 \
  --title "implement dark mode toggle v2" \
  --description "updated requirements: also support system preference detection." \
  --idem upsert

# output:
# ğŸ™ï¸ task #156 updated
#    â”œâ”€ backup: .radio/task.156.bak.2026-01-30.md
#    â””â”€ changes applied

# idempotent push (findsert mode - find or insert)
rhx radio.task.push \
  --via gh.issues \
  --title "implement dark mode toggle" \
  --description "same description" \
  --idem findsert

# output (if found with matched attributes):
# ğŸ™ï¸ task found
#    â””â”€ issue #156 already exists with matched attributes

# output (if mismatch detected without --idem):
# â›ˆï¸ error: task with title "implement dark mode toggle" exists but attributes differ
#    â””â”€ use --idem upsert to update, or --idem findsert to ignore
```

### usecase 5: cross-repo dispatch

**goal**: dispatch tasks to any repo you have access to

**timeline**:
1. human broadcasts task to a different repo
2. auth via GITHUB_TOKEN (personal or app token)
3. task appears in target repo's issue tracker

**contract**:
```sh
# push to a different repo (with explicit auth)
GITHUB_TOKEN=$APP_TOKEN rhx radio.task.push \
  --via gh.issues \
  --repo ehmpathy/other-service \
  --title "upgrade typescript to 5.4"

# output:
# ğŸ™ï¸ broadcast to gh.issues
#    â”œâ”€ repo: ehmpathy/other-service
#    â””â”€ issue #42 created
```

---

## mental model

### how users describe it to a friend

> "it's like a walkie-talkie for work. you push tasks to a channel â€” could be github issues, could be local files â€” and any clone tuned in can pull them. you claim a task to plant a tree (start work on a worktree branch), and deliver it when done. the dispatcher role listens to the radio and picks up work."

### analogies that fit

| analogy         | maps to                                |
| --------------- | -------------------------------------- |
| walkie-talkie   | push/pull broadcast system             |
| radio channel   | gh.issues, os.fileops, future channels |
| tune in         | `--via` flag selects channel           |
| plant a tree    | claim task, record branch              |
| harvest         | deliver task, close issue              |
| local tape      | `.radio/` cache after pull             |
| broadcast tower | github (persistent, shared)            |

### terms: user vs system

| user says         | system says                                    |
| ----------------- | ---------------------------------------------- |
| "send a task"     | `radio.task.push --title`                      |
| "check for tasks" | `radio.task.pull --list`                       |
| "grab that task"  | `radio.task.push --exid --status CLAIMED`      |
| "mark it done"    | `radio.task.push --exid --status DELIVERED`    |
| "update the task" | `radio.task.push --exid --title --idem upsert` |
| "github tasks"    | `--via gh.issues`                              |
| "local tasks"     | `--via os.fileops`                             |
| "which repo"      | `--repo $owner/$repo` (defaults to current)    |

---

## task format

### gh.issues format

```md
ğŸ™ï¸ task: implement dark mode toggle

ğŸ¦« dispatch to foreman

ğŸ’§ task enqueued
   â”œâ”€ pushed by: casey
   â”œâ”€ pushed at: 2026-01-30
   â”œâ”€ priority = ?
   â”œâ”€ yieldage = ?
   â””â”€ leverage = ?

ğŸŒ² tree planted at foreman/dark-mode-toggle

---

implement dark mode toggle

user option in preferences. persist to localstorage.
```

### os.fileops format

```md
---
exid: "156"
title: "implement dark mode toggle"
status: CLAIMED
pushed_by: casey
pushed_at: 2026-01-30
claimed_by: foreman
claimed_at: 2026-01-30
branch: foreman/dark-mode-toggle
---

ğŸ™ï¸ task: implement dark mode toggle

ğŸ¦« dispatch to foreman

ğŸ’§ task enqueued
   â”œâ”€ pushed by: casey
   â”œâ”€ pushed at: 2026-01-30
   â”œâ”€ priority = ?
   â”œâ”€ yieldage = ?
   â””â”€ leverage = ?

ğŸŒ² tree planted at foreman/dark-mode-toggle

---

implement dark mode toggle

user option in preferences. persist to localstorage.
```

### status flag files

for fast status queries on os.fileops:

```
# global structure (source of truth)
~/git/.radio/
  â”œâ”€ readme.md                              # explains global radio dir
  â””â”€ ehmpathy/
      â””â”€ acme-app/
          â”œâ”€ readme.md                      # explains repo radio dir
          â”œâ”€ task.156._.md                   # main task file
          â”œâ”€ task.156.bak.2026-01-30.md       # backup from edit
          â”œâ”€ task.156._.status=CLAIMED.flag     # empty file for glob
          â”œâ”€ task.155._.md
          â”œâ”€ task.155._.status=QUEUED.flag
          â””â”€ task.154._.md
              # no flag = DELIVERED (cleaned up)

# local symlink (per-repo convenience)
.radio/ â†’ ~/git/.radio/ehmpathy/acme-app/
```

### bootstrap readme files

on first push, `readme.md` files are findserted to document each directory:

**~/git/.radio/readme.md**:
```md
# .radio

> global radio directory for cross-repo task dispatch

this directory stores tasks broadcast via `radio.task.push --via os.fileops`.

## structure

- `$owner/$repo/` â€” tasks for each repo
- `$owner/$repo/task.{exid}.md` â€” task content with frontmatter
- `$owner/$repo/task.{exid}._.status=QUEUED.flag` â€” status flag for fast glob

## usage

tasks here are accessible from each repo via `.radio/` symlink.

cross-repo dispatch writes directly here without local symlink.
```

**~/git/.radio/$owner/$repo/readme.md**:
```md
# .radio/$owner/$repo

> local radio cache for $owner/$repo

this directory stores tasks for the $owner/$repo repository.

symlinked from: `$repo_path/.radio/`

## files

- `readme.md` â€” this file
- `task.{exid}._.md` â€” main task file with yaml frontmatter
- `task.{exid}.bak.{isodate}.md` â€” backup from prior edit
- `task.{exid}._.status={STATUS}.flag` â€” empty flag file for status glob
```

query open tasks:
```sh
ls .radio/*._.status=QUEUED.flag
# task.155._.status=QUEUED.flag

# or query globally across all repos
ls ~/git/.radio/**/\*._.status=QUEUED.flag
```

---

## architecture

### adapter pattern via declastruct dao

the radio system uses a dao adapter pattern so channels are swappable:

```
RadioTask (domain object)
  â”œâ”€ exid: string
  â”œâ”€ title: string
  â”œâ”€ description: string
  â”œâ”€ status: QUEUED | CLAIMED | DELIVERED
  â”œâ”€ pushed_by: string
  â”œâ”€ pushed_at: string (iso date)
  â”œâ”€ claimed_by: string | null
  â”œâ”€ claimed_at: string | null
  â”œâ”€ branch: string | null
  â””â”€ repo: { owner: string, name: string }

daoRadioTask (adapter interface)
  â”œâ”€ get.byPrimary({ exid }) â†’ RadioTask | null
  â”œâ”€ get.byUnique({ repo, title }) â†’ RadioTask | null
  â”œâ”€ get.all({ repo, status? }) â†’ RadioTask[]
  â”œâ”€ set.findsert(task) â†’ RadioTask
  â”œâ”€ set.upsert(task) â†’ RadioTask
  â””â”€ del({ exid }) â†’ void

daoRadioTask.ghIssues (gh.issues adapter)
  â””â”€ implements daoRadioTask via gh cli

daoRadioTask.osFileops (os.fileops adapter)
  â””â”€ implements daoRadioTask via filesystem
```

this enables:
- easy addition of new channels (slack, linear, notion)
- consistent behavior across channels
- testability via in-memory adapter

---

## evaluation

### how well does it solve the goals?

| goal                | solution                       | score       |
| ------------------- | ------------------------------ | ----------- |
| capture ideas fast  | push from anywhere             | âœ… excellent |
| clone autonomy      | pull, claim, deliver           | âœ… excellent |
| task lifecycle      | QUEUED â†’ CLAIMED â†’ DELIVERED | âœ… excellent |
| offline capability  | local cache + status flags     | âœ… excellent |
| cross-repo dispatch | --repo (defaults to current)   | âœ… excellent |
| audit trail         | who/when pushed, .bak versions | âœ… excellent |
| channel flexibility | adapter pattern                | âœ… excellent |
| idempotency         | --idem findsert/upsert         | âœ… excellent |

### pros

- **full lifecycle**: QUEUED â†’ CLAIMED â†’ DELIVERED with branch recorded
- **audit trail**: who pushed, when, with .bak on edits
- **idempotent**: findsert and upsert modes prevent duplicates
- **cross-repo**: dispatch to any repo you have access to
- **adapter pattern**: channels are swappable via dao interface
- **local-first**: status flags enable fast offline queries
- **auth flexible**: works with default gh token or app token

### cons

- **no priority queue**: priority/yieldage/leverage are still placeholders
- **branch lock**: claim failfast if task already claimed by different branch
- **no notifications**: no push notifications when tasks arrive

### edgecases and pit of success

| edgecase                        | pit of success design                             |
| ------------------------------- | ------------------------------------------------- |
| duplicate --via flags           | fail-fast: "error: --via specified twice"         |
| no --repo outside git repo      | error: "--repo required (not in a git repo)"      |
| push with mismatched attributes | error unless --idem specified                     |
| edit task                       | .bak created before overwrite                     |
| query open tasks                | status flag files enable fast glob                |
| auth token expired              | clear error: "gh cli not authenticated"           |
| claim already-claimed           | failfast if different branch; same branch = no-op |

---

## summary

the dispatcher radio transforms scattered ideas into a tracked broadcast. push to any repo, claim to plant a tree (start work), deliver to harvest (close the loop). channels are swappable via dao adapters. edits are versioned. status is queryable offline.

> ğŸ™ï¸ push. claim. deliver. done.
