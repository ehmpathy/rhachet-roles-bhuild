# research: production code patterns

> what patterns exist in this repo that are relevant to dispatcher radio?

---

## overview

| pattern | relation to radio | action |
|---------|-------------------|--------|
| shell skill dispatch | task.push.sh, task.pull.sh entry points | [REUSE] |
| cli arg parse via zod | --via, --title, --exid flags | [REUSE] |
| role registry | dispatcher role registration | [REUSE] |
| domain objects via DomainLiteral | RadioTask, RadioTaskStatus | [REUSE] |
| operation signature (input, context) | all radio operations | [REUSE] |
| findsert pattern | idempotent task creation | [REUSE] |
| flag file pattern | status flags for glob queries | [REUSE] |
| filesystem persistence | os.fileops channel | [EXTEND] |
| gh cli integration | gh.issues channel | [NEW] |
| dao adapter pattern | channel abstraction | [NEW] |

---

## 1. shell skill dispatch pattern [REUSE]

### 1.1 pattern description

shell skills are thin dispatchers that forward execution to TypeScript via node dynamic import.

### 1.2 citations

**[1] shell skill header structure** — `src/domain.roles/behaver/skills/init.behavior.sh:1-32`
```bash
#!/usr/bin/env bash
######################################################################
# .what = initialize a .behavior directory for bhuild thoughtroute
#
# .why  = standardize the behavior-driven development thoughtroute
#         by creation of a structured directory with:
#           - wish definition
#           - vision statement
#           - blackbox criteria (user-faced behavioral requirements)
#           - blueprint criteria (implementation requirements)
#           - research prompts
#           - distillation prompts
#           - blueprint prompts
#           - roadmap prompts
#           - execution prompts
#           - feedback template
#
# usage:
#   init.behavior.sh --name <behaviorname> [--dir <directory>]
#
# guarantee:
#   - creates .behavior/ if not found
#   - creates versioned behavior directory
#   - findserts all thoughtroute files (creates if not found, skips if present)
#   - auto-binds current branch to newly created behavior
#   - idempotent: safe to rerun
#   - fail-fast on errors
######################################################################

set -euo pipefail

exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.initBehavior())" -- "$@"
```

**[2] package export structure** — `src/index.ts:1-24`
```typescript
export * from './contract/sdk';

// CLI entry points for portable skill dispatch
import { withEmojiSpaceShim } from 'emoji-space-shim';

import { bindBehavior } from './contract/cli/bind.behavior';
import { bootBehavior } from './contract/cli/boot.behavior';
import { catchDream } from './contract/cli/catch.dream';
import { decomposeBehavior } from './contract/cli/decompose.behavior';
import { giveFeedback } from './contract/cli/give.feedback';
import { initBehavior } from './contract/cli/init.behavior';
import { reviewBehavior } from './contract/cli/review.behavior';

export const cli = {
  bindBehavior: () => withEmojiSpaceShim({ logic: async () => bindBehavior() }),
  bootBehavior: () => withEmojiSpaceShim({ logic: async () => bootBehavior() }),
  catchDream: () => withEmojiSpaceShim({ logic: async () => catchDream() }),
  decomposeBehavior: () =>
    withEmojiSpaceShim({ logic: async () => decomposeBehavior() }),
  giveFeedback: () => withEmojiSpaceShim({ logic: async () => giveFeedback() }),
  initBehavior: () => withEmojiSpaceShim({ logic: async () => initBehavior() }),
  reviewBehavior: () =>
    withEmojiSpaceShim({ logic: async () => reviewBehavior() }),
};
```

### 1.3 relation to radio

dispatcher radio will use this exact pattern:
- `src/domain.roles/dispatcher/skills/radio.task.push.sh`
- `src/domain.roles/dispatcher/skills/radio.task.pull.sh`
- both dispatch to `cli.radioTaskPush()` and `cli.radioTaskPull()`

---

## 2. cli arg parse via zod [REUSE]

### 2.1 pattern description

all cli entry points use `getCliArgs()` with zod schemas for type-safe arg parse.

### 2.2 citations

**[3] rhachet passthrough args schema** — `src/infra/cli/getCliArgs.ts:3-14`
```typescript
/**
 * .what = base schema for rhachet passthrough args
 *
 * .why  = all CLI entry points must accept these optional args
 *         so they can be invoked via rhachet skill dispatch
 */
export const schemaOfRhachetArgs = z.object({
  repo: z.string().optional(),
  role: z.string().optional(),
  skill: z.string().optional(),
  s: z.string().optional(),
});
```

**[4] cli arg parse main function** — `src/infra/cli/getCliArgs.ts:103-134`
```typescript
export const getCliArgs = <T extends CliSchemaWithRhachetArgs>(input: {
  schema: T;
  argv?: string[];
}): z.infer<T> => {
  // drop entry filename from argv if present
  //
  // rhachet skills use `tsx -e "import('pkg').then(m => m.cli.X())"` which
  // has no entry filename - argv[1] is already the first user arg.
  //
  // direct invocation like `tsx src/contract/cli/bind.behavior.ts` puts
  // the entry path in argv[1], which we need to skip.
  //
  // we detect the entry filename by checking for `/cli/` in the path,
  // since all CLI entry points live in src/contract/cli/.
  const argvFirstIsEntryFilename = process.argv[1]?.includes('/cli/');
  const argvWithoutEntryFilename = argvFirstIsEntryFilename
    ? process.argv.slice(2)
    : process.argv.slice(1);
  const argv = input.argv ?? argvWithoutEntryFilename;
  const raw = getCliArgsRaw(argv);

  // validate against schema
  const result = input.schema.safeParse(raw);

  if (!result.success) {
    const errorOutput = genCliArgsErrorStdout({ issues: result.error.issues });
    console.error(errorOutput);
    process.exit(1);
  }

  return result.data;
};
```

**[5] cli entry point schema example** — `src/contract/cli/init.behavior.ts:29-42`
```typescript
const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    name: z.string(),
    dir: z.string().optional(),
    open: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

### 2.3 relation to radio

dispatcher radio will define schemas for:
- `radio.task.push`: `--via`, `--title`, `--description`, `--repo`, `--exid`, `--status`, `--idem`
- `radio.task.pull`: `--via`, `--list`, `--exid`, `--repo`

---

## 3. role registry pattern [REUSE]

### 3.1 pattern description

roles are defined as `Role.build()` objects and collected in a `RoleRegistry`.

### 3.2 citations

**[6] role definition structure** — `src/domain.roles/behaver/getBehaverRole.ts:1-33`
```typescript
import { Role } from 'rhachet';

export const ROLE_BEHAVER: Role = Role.build({
  slug: 'behaver',
  name: 'Behaver',
  purpose: 'declare clear, buildable, and testable behaviors',
  readme: { uri: __dirname + '/readme.md' },
  traits: [],
  skills: {
    dirs: [{ uri: __dirname + '/skills' }],
    refs: [],
  },
  briefs: {
    dirs: [{ uri: __dirname + '/briefs' }],
  },
  inits: {
    dirs: { uri: __dirname + '/inits' },
    exec: [],
  },
  hooks: {
    onBrain: {
      onBoot: [
        {
          command:
            './node_modules/.bin/rhachet run --repo bhuild --role behaver --init claude.hooks/sessionstart.boot-behavior',
          timeout: 'PT10S',
        },
      ],
      onTool: [],
      onStop: [],
    },
  },
});
```

**[7] role registry structure** — `src/domain.roles/getRoleRegistry.ts:1-18`
```typescript
import { RoleRegistry } from 'rhachet';

import { ROLE_BEHAVER } from './behaver/getBehaverRole';
import { ROLE_DECOMPOSER } from './decomposer/getDecomposerRole';
import { ROLE_DREAMER } from './dreamer/getDreamerRole';

/**
 * .what = returns the core registry of predefined roles and skills
 * .why =
 *   - enables CLI or thread logic to load available roles
 *   - avoids dynamic load or global mutation
 */
export const getRoleRegistry = (): RoleRegistry =>
  new RoleRegistry({
    slug: 'bhuild',
    readme: { uri: __dirname + '/readme.md' },
    roles: [ROLE_BEHAVER, ROLE_DECOMPOSER, ROLE_DREAMER],
  });
```

### 3.3 relation to radio

dispatcher role will follow this pattern:
- `src/domain.roles/dispatcher/getDispatcherRole.ts`
- registered in `getRoleRegistry()` alongside behaver, decomposer, dreamer

---

## 4. domain objects via DomainLiteral [REUSE]

### 4.1 pattern description

domain objects extend `DomainLiteral` from `domain-objects` with `primary` and `unique` keys.

### 4.2 citations

**[8] domain object with primary/unique keys** — `src/domain.objects/BehaviorArtifact.ts:1-41`
```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = a behavior artifact that can be targeted for feedback
 * .why = provides identity and version info for artifact resolution
 */
interface BehaviorArtifact {
  /**
   * full path to the artifact file
   */
  path: string;

  /**
   * artifact name extracted from filename (e.g., 'execution', 'criteria.blackbox')
   */
  name: string;

  /**
   * version number if present in filename (vX), null otherwise
   */
  version: number | null;

  /**
   * attempt number if present in filename (iX), null otherwise
   */
  attempt: number | null;

  /**
   * the base filename without path
   */
  filename: string;
}
class BehaviorArtifact
  extends DomainLiteral<BehaviorArtifact>
  implements BehaviorArtifact
{
  public static primary = ['path'] as const;
  public static unique = ['path'] as const;
}

export { BehaviorArtifact };
```

### 4.3 relation to radio

RadioTask will follow this pattern:
```typescript
interface RadioTask {
  exid: string;
  title: string;
  description: string;
  status: RadioTaskStatus;
  // ... other fields
}
class RadioTask extends DomainLiteral<RadioTask> implements RadioTask {
  public static primary = ['exid'] as const;
  public static unique = ['repo', 'title'] as const;
}
```

---

## 5. operation signature (input, context) [REUSE]

### 5.1 pattern description

all operations follow `(input: {...}, context?: {...}) => Result` pattern.

### 5.2 citations

**[9] operation with context pattern** — `src/domain.operations/behavior/bind/setBranchBehaviorBind.ts:8-22`
```typescript
/**
 * .what = bind a branch to a behavior
 *
 * .why  = creates the bind flag file that associates a branch with a behavior
 *
 * @returns success status and message
 */
export const setBranchBehaviorBind = (
  input: {
    branchName: string;
    behaviorDir: string;
    boundBy?: string;
  },
  context?: { cwd?: string },
): { success: boolean; message: string; alreadyBound?: boolean } => {
```

**[10] cli entry point with context** — `src/contract/cli/init.behavior.ts:48-52`
```typescript
export const initBehavior = (): void => {
  const { named } = getCliArgs({ schema: schemaOfArgs });
  const behaviorName = named.name;
  const rawTargetDir = named.dir ?? process.cwd();
  const context = { cwd: rawTargetDir };
```

### 5.3 relation to radio

all radio operations will follow this pattern:
- `daoRadioTask.ghIssues.set.findsert(input, context)`
- `daoRadioTask.osFileops.get.byPrimary(input, context)`

---

## 6. findsert pattern [REUSE]

### 6.1 pattern description

findsert = "find or insert" — returns prior if found, creates new if not found.

### 6.2 citations

**[11] findsert operation implementation** — `src/domain.operations/dreamer/dreams/setDream.ts:7-44`
```typescript
/**
 * .what = finds prior dream or creates new one (findsert pattern)
 * .why = ensures dreams are not duplicated while it enables capture
 */
export const setDream = (input: {
  findsert: {
    name: string;
    dreamDir: string;
    date: string;
  };
}): { dream: DreamArtifact; outcome: 'caught' | 'found' } => {
  // check for prior dream
  const dreamFound = getOneDreamByName({
    name: input.findsert.name,
    dreamDir: input.findsert.dreamDir,
  });

  // return prior if found
  if (dreamFound) {
    return { dream: dreamFound, outcome: 'found' };
  }

  // create new dream
  const filename = `${input.findsert.date}.${input.findsert.name}.dream.md`;
  const dreamPath = path.join(input.findsert.dreamDir, filename);
  const content = 'dream = \n\n';

  writeFileSync(dreamPath, content, 'utf-8');

  const dreamCreated = new DreamArtifact({
    path: dreamPath,
    name: input.findsert.name,
    date: input.findsert.date,
    filename,
  });

  return { dream: dreamCreated, outcome: 'caught' };
};
```

### 6.3 relation to radio

radio will use findsert for idempotent task creation:
- `radio.task.push --title "x" --description "y"` → findsert by (repo, title)
- `radio.task.push --title "x" --idem findsert` → explicit findsert mode

---

## 7. flag file pattern [REUSE]

### 7.1 pattern description

empty `.flag` files enable fast glob queries without file parse.

### 7.2 citations

**[12] flag file creation for bind** — `src/domain.operations/behavior/bind/setBranchBehaviorBind.ts:54-65`
```typescript
  // create bind directory if needed
  const bindDir = join(input.behaviorDir, '.bind');
  mkdirSync(bindDir, { recursive: true });

  // create bind flag with metadata
  const flagPath = join(bindDir, `${branchFlat}.flag`);
  writeFileSync(
    flagPath,
    `branch: ${input.branchName}
bound_by: ${input.boundBy ?? 'bind.behavior skill'}
`,
  );
```

### 7.3 relation to radio

radio will use status flags for fast queries:
- `task.{exid}._.status=QUEUED.flag`
- `task.{exid}._.status=CLAIMED.flag`
- query: `ls .radio/*._.status=QUEUED.flag`

---

## 8. filesystem persistence pattern [EXTEND]

### 8.1 pattern description

direct filesystem operations via node `fs` module.

### 8.2 citations

**[13] filesystem read for discovery** — `src/domain.operations/dreamer/dreams/getOneDreamByName.ts:7-46`
```typescript
/**
 * .what = finds a dream artifact by its name, regardless of date
 * .why = enables reuse of prior dreams via findsert pattern
 */
export const getOneDreamByName = (input: {
  name: string;
  dreamDir: string;
}): DreamArtifact | null => {
  // handle dir not present
  if (!existsSync(input.dreamDir)) return null;

  // read directory and filter for dreams with this name
  const files = readdirSync(input.dreamDir);
  const pattern = new RegExp(
    `^\\d{4}_\\d{2}_\\d{2}\\.${escapeRegex(input.name)}\\.dream\\.md$`,
  );
  const matches = files.filter((file) => pattern.test(file));

  // handle no match
  if (matches.length === 0) return null;

  // handle multiple matches - unexpected
  if (matches.length > 1) {
    throw new UnexpectedCodePathError('multiple dreams with same name found', {
      name: input.name,
      matches,
    });
  }

  // parse the match to extract date
  const filename = matches[0]!;
  const date = filename.split('.')[0]!; // YYYY_MM_DD

  return new DreamArtifact({
    path: path.join(input.dreamDir, filename),
    name: input.name,
    date,
    filename,
  });
};
```

### 8.3 relation to radio

radio os.fileops channel will extend this pattern:
- add yaml frontmatter parse/serialize
- add status flag file management
- add backup file creation on edit
- add symlink creation for `.radio/` → global radio

---

## 9. gh cli integration [NEW]

### 9.1 pattern description

no gh cli integration exists in this repo. this is a new pattern for radio.

### 9.2 relation to radio

radio gh.issues channel will:
- use `gh issue create` for task push
- use `gh issue list` for task pull --list
- use `gh issue view` for task pull --exid
- use `gh issue edit` for status updates
- use `gh issue close` for delivered status

see `3.1.research.access._.v1.md` for gh cli contract details.

---

## 10. dao adapter pattern [NEW]

### 10.1 pattern description

no dao adapter pattern exists in this repo. current code uses direct filesystem operations.

### 10.2 relation to radio

radio will introduce a dao adapter interface:
```typescript
daoRadioTask
  ├─ get.byPrimary({ exid }) → RadioTask | null
  ├─ get.byUnique({ repo, title }) → RadioTask | null
  ├─ get.all({ repo, status? }) → RadioTask[]
  ├─ set.findsert(task) → RadioTask
  ├─ set.upsert(task) → RadioTask
  └─ del({ exid }) → void
```

with two adapter implementations:
- `daoRadioTask.ghIssues` — via gh cli
- `daoRadioTask.osFileops` — via filesystem

this enables channel-swap without logic change.

---

## 11. directory structure pattern [REUSE]

### 11.1 pattern description

production code follows layered directory structure.

### 11.2 citations

**[14] directory structure observed**
```
src/
  ├─ contract/
  │   └─ cli/           # cli entry points
  ├─ domain.objects/    # domain literals
  ├─ domain.operations/ # business logic
  │   ├─ behavior/
  │   │   ├─ bind/
  │   │   ├─ decompose/
  │   │   ├─ feedback/
  │   │   ├─ init/
  │   │   └─ render/
  │   └─ dreamer/
  │       ├─ catch/
  │       └─ dreams/
  ├─ domain.roles/      # role definitions
  │   ├─ behaver/
  │   │   ├─ briefs/
  │   │   ├─ inits/
  │   │   └─ skills/
  │   ├─ decomposer/
  │   └─ dreamer/
  └─ infra/             # infrastructure
      ├─ brain/
      ├─ cli/
      └─ shell/
```

### 11.3 relation to radio

radio will follow this structure:
```
src/
  ├─ contract/cli/
  │   ├─ radio.task.push.ts
  │   └─ radio.task.pull.ts
  ├─ domain.objects/
  │   ├─ RadioTask.ts
  │   ├─ RadioTaskStatus.ts
  │   ├─ RadioChannel.ts
  │   └─ RadioTaskRepo.ts
  └─ domain.roles/dispatcher/
      ├─ briefs/
      ├─ inits/
      └─ skills/
          ├─ radio.task.push.sh
          └─ radio.task.pull.sh
```

---

## summary

| pattern | source | action | rationale |
|---------|--------|--------|-----------|
| shell skill dispatch | [1][2] | [REUSE] | exact same dispatch pattern |
| cli arg parse via zod | [3][4][5] | [REUSE] | exact same parse pattern |
| role registry | [6][7] | [REUSE] | add dispatcher to registry |
| domain objects | [8] | [REUSE] | RadioTask follows BehaviorArtifact pattern |
| operation signature | [9][10] | [REUSE] | (input, context) everywhere |
| findsert pattern | [11] | [REUSE] | idempotent task creation |
| flag file pattern | [12] | [REUSE] | status flags for queries |
| filesystem persistence | [13] | [EXTEND] | add frontmatter, symlinks |
| gh cli integration | — | [NEW] | no prior pattern |
| dao adapter pattern | — | [NEW] | no prior pattern |

---

## citations index

| # | file | lines | description |
|---|------|-------|-------------|
| 1 | src/domain.roles/behaver/skills/init.behavior.sh | 1-32 | shell skill header |
| 2 | src/index.ts | 1-24 | package cli exports |
| 3 | src/infra/cli/getCliArgs.ts | 3-14 | rhachet args schema |
| 4 | src/infra/cli/getCliArgs.ts | 103-134 | getCliArgs function |
| 5 | src/contract/cli/init.behavior.ts | 29-42 | cli schema example |
| 6 | src/domain.roles/behaver/getBehaverRole.ts | 1-33 | role definition |
| 7 | src/domain.roles/getRoleRegistry.ts | 1-18 | role registry |
| 8 | src/domain.objects/BehaviorArtifact.ts | 1-41 | domain object |
| 9 | src/domain.operations/behavior/bind/setBranchBehaviorBind.ts | 8-22 | operation signature |
| 10 | src/contract/cli/init.behavior.ts | 48-52 | cli context creation |
| 11 | src/domain.operations/dreamer/dreams/setDream.ts | 7-44 | findsert pattern |
| 12 | src/domain.operations/behavior/bind/setBranchBehaviorBind.ts | 54-65 | flag file creation |
| 13 | src/domain.operations/dreamer/dreams/getOneDreamByName.ts | 7-46 | filesystem read |
| 14 | src/ | — | directory structure |
