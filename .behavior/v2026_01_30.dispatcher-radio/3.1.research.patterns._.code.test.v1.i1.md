# research: test code patterns

> what test patterns exist in this repo that inform dispatcher radio test implementation?

---

## overview

this document enumerates test patterns observed in the codebase, with citations and applicability markers for the dispatcher radio feature.

| marker | meaning |
|--------|---------|
| [REUSE] | pattern applies directly to radio tests |
| [EXTEND] | pattern needs adaptation for radio-specific needs |
| [REPLACE] | pattern doesn't fit radio requirements |

---

## 1. bdd test structure with given/when/then [REUSE]

the codebase uses `test-fns` for behavior-driven test structure.

**citation [1]** — `src/domain.operations/behavior/decompose/applyPlan.integration.test.ts:1-5`:
```typescript
import { given, then, when } from 'test-fns';
```

**citation [2]** — `src/domain.operations/behavior/decompose/applyPlan.integration.test.ts:18-36`:
```typescript
describe('applyPlan.integration', () => {
  given('[case1] valid plan with two proposed behaviors', () => {
    // ...
    when('[t0] applyPlan invoked with full plan', () => {
      then('sub-behavior directories are created', async () => {
        const result = await applyPlan({ plan });
        expect(result.behaviorsCreated).toHaveLength(2);
      });
    });
  });
});
```

**applicability**: radio tests should use the same `given/when/then` structure for consistency. the `[caseN]` and `[tN]` label convention aids test identification.

---

## 2. useBeforeAll for expensive async setup [REUSE]

tests use `useBeforeAll` to share expensive setup across assertions.

**citation [3]** — `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts:77-84`:
```typescript
given('[case2] consumer: feedback file already exists', () => {
  when('[t0] give.feedback invoked again for same artifact', () => {
    const result = useBeforeAll(async () =>
      runGiveFeedbackSkillViaRhachet({
        against: 'execution',
        behavior: 'exists-test',
        repoDir: consumer.repoDir,
      }),
    );
```

**citation [4]** — `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts:86-88`:
```typescript
    then('exits with non-zero code', () => {
      expect(result.exitCode).not.toBe(0);
    });
```

**applicability**: radio acceptance tests will invoke skills and verify outputs — `useBeforeAll` prevents redundant skill invocations across multiple `then` assertions.

---

## 3. consumer repo factory pattern [REUSE]

acceptance tests create isolated consumer repos via `genConsumerRepo`.

**citation [5]** — `blackbox/.test/infra/genConsumerRepo.ts:1-17`:
```typescript
import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

import { genTestGitRepo, TestGitRepo } from './genTestGitRepo';

export interface ConsumerRepo extends TestGitRepo {
  repoDir: string;
  cleanup: () => void;
}

export const genConsumerRepo = (input?: {
  prefix?: string;
  withClaudeDir?: boolean;
}): ConsumerRepo => {
```

**citation [6]** — `blackbox/.test/infra/genConsumerRepo.ts:18-35`:
```typescript
  const { repoDir, cleanup } = genTestGitRepo({
    prefix: input?.prefix ?? 'consumer-test-',
  });

  // create .claude directory if requested
  if (input?.withClaudeDir !== false) {
    const claudeDir = path.join(repoDir, '.claude');
    fs.mkdirSync(claudeDir, { recursive: true });
  }

  // create minimal package.json
  const packageJson = {
    name: 'test-consumer',
    version: '0.0.0',
    private: true,
  };
  fs.writeFileSync(
    path.join(repoDir, 'package.json'),
    JSON.stringify(packageJson, null, 2),
  );
```

**applicability**: radio tests need isolated repos with `.radio/` directories and symlinks. this pattern provides the foundation — extend to create radio-specific fixtures.

---

## 4. test git repo factory pattern [REUSE]

base layer for minimal git repos in tests.

**citation [7]** — `blackbox/.test/infra/genTestGitRepo.ts:1-19`:
```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { execSync } from 'child_process';

export interface TestGitRepo {
  repoDir: string;
  cleanup: () => void;
}

export const genTestGitRepo = (input?: {
  prefix?: string;
  branchName?: string;
  copyFrom?: string;
  commitGlob?: string;
}): TestGitRepo => {
  const prefix = input?.prefix ?? 'test-git-repo-';
```

**citation [8]** — `blackbox/.test/infra/genTestGitRepo.ts:20-38`:
```typescript
  const repoDir = fs.mkdtempSync(path.join(os.tmpdir(), prefix));

  // init git repo
  execSync('git init -b main', { cwd: repoDir, stdio: 'pipe' });
  execSync('git config user.email "test@test.com"', {
    cwd: repoDir,
    stdio: 'pipe',
  });
  execSync('git config user.name "Test User"', { cwd: repoDir, stdio: 'pipe' });

  // copy from template if provided
  if (input?.copyFrom) {
    execSync(`cp -r ${input.copyFrom}/* .`, { cwd: repoDir, stdio: 'pipe' });
  }

  // create initial commit
  const commitGlob = input?.commitGlob ?? '.';
  execSync(`git add ${commitGlob}`, { cwd: repoDir, stdio: 'pipe' });
```

**applicability**: radio tests need git repos to test `--repo` default behavior and branch detection for CLAIMED status. this factory provides exactly that.

---

## 5. skill invocation utility [EXTEND]

acceptance tests invoke skills via cli and capture results.

**citation [9]** — `blackbox/.test/infra/runRhachetSkill.ts:1-22`:
```typescript
import { execSync } from 'child_process';

export interface SkillResult {
  stdout: string;
  stderr: string;
  output: string;
  exitCode: number;
}

export const runRhachetSkill = (input: {
  repo: string;
  role?: string;
  skill: string;
  args?: string;
  repoDir: string;
  timeout?: number;
}): SkillResult => {
  const args = input.args ?? '';
  const roleFlag = input.role ? `--role ${input.role}` : '';
  const timeout = input.timeout ?? 30000;
```

**citation [10]** — `blackbox/.test/infra/runRhachetSkill.ts:24-45`:
```typescript
  try {
    const stdout = execSync(
      `npx rhachet run --repo ${input.repo} ${roleFlag} --skill ${input.skill} ${args}`,
      {
        cwd: input.repoDir,
        encoding: 'utf-8',
        timeout,
        stdio: ['pipe', 'pipe', 'pipe'],
      },
    );

    return {
      stdout: stdout.trim(),
      stderr: '',
      output: stdout.trim(),
      exitCode: 0,
    };
  } catch (error: unknown) {
    const execError = error as {
      stdout?: Buffer | string;
      stderr?: Buffer | string;
      status?: number;
    };
```

**applicability**: radio tests need a similar utility, but may need extension for:
- pass `GITHUB_TOKEN` environment variable
- handle `--via` channel argument
- capture structured json output for verification

---

## 6. behavior fixture factory [EXTEND]

tests create behavior directory structures programmatically.

**citation [11]** — `blackbox/.test/infra/genBehaviorFixture.ts:1-24`:
```typescript
import * as fs from 'fs';
import * as path from 'path';

export const genBehaviorFixture = (input: {
  repoDir: string;
  behaviorName: string;
  withCriteria?: boolean;
  withDecomposed?: boolean;
  withFeedbackTemplate?: boolean;
  withExecution?: boolean;
  datePrefix?: string;
}): { behaviorDir: string } => {
  const datePrefix = input.datePrefix ?? 'v2026_01_01';
  const behaviorDir = path.join(
    input.repoDir,
    '.behavior',
    `${datePrefix}.${input.behaviorName}`,
  );

  fs.mkdirSync(behaviorDir, { recursive: true });
```

**citation [12]** — `blackbox/.test/infra/genBehaviorFixture.ts:26-45`:
```typescript
  // create wish file (always)
  fs.writeFileSync(
    path.join(behaviorDir, '0.wish.md'),
    `wish = test behavior for ${input.behaviorName}\n`,
  );

  // create criteria if requested
  if (input.withCriteria) {
    fs.writeFileSync(
      path.join(behaviorDir, '2.1.criteria.blackbox.md'),
      `# blackbox criteria\n\ngiven('test case')\n  when('action')\n    then('result')\n`,
    );
  }
```

**applicability**: radio tests need a similar fixture factory for:
- create `.radio/` directories with symlinks
- create `task.{exid}._.md` files with frontmatter
- create `task.{exid}._.status={STATUS}.flag` files
- create `~/git/.radio/$owner/$repo/` global structure

---

## 7. temp directory cleanup pattern [REUSE]

integration tests manage temp directories with beforeEach/afterAll.

**citation [13]** — `src/domain.operations/behavior/decompose/applyPlan.integration.test.ts:20-34`:
```typescript
    const testDir = path.join(os.tmpdir(), 'applyPlan-int-test-1');
    const parentBehaviorPath = path.join(
      testDir,
      '.behavior',
      'v2026_01_01.parent',
    );

    beforeEach(async () => {
      // clean up before each test
      await fs.rm(testDir, { recursive: true, force: true });
      await fs.mkdir(parentBehaviorPath, { recursive: true });
      // ... setup
    });

    afterAll(async () => {
      await fs.rm(testDir, { recursive: true, force: true });
    });
```

**applicability**: radio integration tests need the same pattern for:
- clean temp `.radio/` directories
- clean `~/git/.radio/` global directories (or test equivalents)
- ensure test isolation

---

## 8. acceptance vs integration test separation [REUSE]

the codebase separates test types by file extension and directory.

**citation [14]** — `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts:1-3`:
```typescript
// acceptance tests live in blackbox/ directory
// use .acceptance.test.ts extension
```

**citation [15]** — `src/domain.operations/behavior/decompose/applyPlan.integration.test.ts:1`:
```typescript
// integration tests live alongside source
// use .integration.test.ts extension
```

**applicability**: radio tests should follow the same separation:
- `src/domain.operations/radio/*.integration.test.ts` — tests dao adapters
- `blackbox/role=dispatcher/skill.radio.*.acceptance.test.ts` — tests cli contract

---

## 9. error case test pattern [REUSE]

tests verify error conditions with expected exit codes and messages.

**citation [16]** — `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts:85-92`:
```typescript
        then('exits with non-zero code', () => {
          expect(result.exitCode).not.toBe(0);
        });

        then('output mentions file already exists', () => {
          expect(result.output.toLowerCase()).toContain('already exists');
        });
```

**applicability**: radio tests need to verify error cases per blackbox criteria:
- `--via` channel not specified
- `--via` specified twice
- `--repo` required outside git repo
- task not found
- gh cli not authenticated

---

## 10. structured output verification [EXTEND]

tests verify specific output content and structure.

**citation [17]** — `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts:63-75`:
```typescript
        then('output includes feedback path', () => {
          expect(result.output).toContain('.ref.[feedback]');
        });

        then('feedback file is created', () => {
          const feedbackFiles = fs.readdirSync(behaviorDir).filter((f) =>
            f.includes('.ref.[feedback]'),
          );
          expect(feedbackFiles.length).toBeGreaterThan(0);
        });
```

**applicability**: radio tests need to verify:
- output shows broadcast confirmation
- output shows issue number / exid
- output shows pushed_by and pushed_at
- task file contains expected frontmatter
- status flag file exists

---

## summary: patterns for radio tests

| pattern | applicability | rationale |
|---------|---------------|-----------|
| bdd given/when/then | [REUSE] | consistent test structure |
| useBeforeAll | [REUSE] | share expensive skill invocations |
| genConsumerRepo | [REUSE] | create isolated test repos |
| genTestGitRepo | [REUSE] | base git repo factory |
| runRhachetSkill | [EXTEND] | add env vars, structured output |
| genBehaviorFixture | [EXTEND] | create genRadioFixture for tasks |
| temp cleanup | [REUSE] | test isolation |
| test separation | [REUSE] | acceptance vs integration |
| error test pattern | [REUSE] | verify error conditions |
| output verification | [EXTEND] | radio-specific output checks |

---

## new patterns needed for radio

### genRadioFixture

factory to create radio task fixtures for tests:

```typescript
export const genRadioFixture = (input: {
  repoDir: string;
  tasks: Array<{
    exid: string;
    title: string;
    status: 'QUEUED' | 'CLAIMED' | 'DELIVERED';
    pushedBy?: string;
    pushedAt?: string;
  }>;
}): { radioDir: string } => {
  // create .radio/ symlink → ~/git/.radio/$owner/$repo/
  // create task files with frontmatter
  // create status flag files
};
```

### runRadioSkill

extended skill runner with github token support:

```typescript
export const runRadioSkill = (input: {
  skill: 'radio.task.push' | 'radio.task.pull';
  via: 'gh.issues' | 'os.fileops';
  args: string;
  repoDir: string;
  githubToken?: string;
}): SkillResult => {
  // set GITHUB_TOKEN if provided
  // invoke skill via runRhachetSkill
  // parse structured output
};
```

### mockGhIssues (for unit tests)

mock github issues api for unit test of dao adapter:

```typescript
export const mockGhIssues = (input: {
  issues: Array<{ number: number; title: string; body: string; state: string }>;
}): GhIssuesMock => {
  // return mock that tracks create/update/close calls
  // verify issue format matches expected structure
};
```

---

## citations index

| # | source file | description |
|---|-------------|-------------|
| 1 | applyPlan.integration.test.ts:1-5 | test-fns import |
| 2 | applyPlan.integration.test.ts:18-36 | given/when/then structure |
| 3 | skill.give.feedback.acceptance.test.ts:77-84 | useBeforeAll pattern |
| 4 | skill.give.feedback.acceptance.test.ts:86-88 | assertion after useBeforeAll |
| 5 | genConsumerRepo.ts:1-17 | consumer repo interface |
| 6 | genConsumerRepo.ts:18-35 | consumer repo creation |
| 7 | genTestGitRepo.ts:1-19 | test git repo interface |
| 8 | genTestGitRepo.ts:20-38 | test git repo creation |
| 9 | runRhachetSkill.ts:1-22 | skill result interface |
| 10 | runRhachetSkill.ts:24-45 | skill invocation logic |
| 11 | genBehaviorFixture.ts:1-24 | behavior fixture interface |
| 12 | genBehaviorFixture.ts:26-45 | behavior fixture creation |
| 13 | applyPlan.integration.test.ts:20-34 | temp dir cleanup |
| 14 | skill.give.feedback.acceptance.test.ts:1-3 | acceptance test location |
| 15 | applyPlan.integration.test.ts:1 | integration test location |
| 16 | skill.give.feedback.acceptance.test.ts:85-92 | error case test pattern |
| 17 | skill.give.feedback.acceptance.test.ts:63-75 | output verification |
