wish =

we launched the dispatcher role with radio capacities via

- skill task.pull
- skill task.push

e.g., under

domain.roles/dispatcher/radio/task.push.sh and task.pull.sh

and launch with initial support for tasks persisted against gh.issues

that'll be our first radio.channel

lets serialize RadioTask's into gh.issues as

title = ğŸ™ï¸ task: $title
description = `
ğŸ¦« dispatch to foreman

ğŸ’§ task enqueued
   â”œâ”€ priority = ?
   â”œâ”€ yieldage = ?
   â””â”€ leverage = ?

---

$title

$description
`


with usage as (where rhx = new alias for rhachet run --skill)

DESCRIPTION=$(EOF


EOF);
rhx radio.task.push --via gh.issues --title "..." --description $DESCRIPTION

and

rhx radio.task.pull --list
rhx radio.task.pull --title | --exid (exid being the gh actions id)


---

also, we want to launch with initial support for tasks persisted against the local filesystem

specifically


rhx radio.task.push --via os.fileops --title --description

which, persists into just `@gitroot/.radio/`

in the future, we'll symlink it into a global os dir so all dispatchers can talk to eachother (w/ cross channel and org segmentation)

but for now, just inrepo is fine


---

also, whenever someone rhx radio.task.pull from anywhere OTHER than os.fileops, it should first push the task into os.fileops

that way, whoever works in that repo can easily reference the task from disk, rather than needing to pull everytime

---

e.g., --via os.fileops is our local repo of the tasks, with a subset of tasks checked out (distributed radio system, effectively)


-----
-----
-----

additional requirements

1. we need to be able to specify which --repo to persist to
   1. for --via gh.issues, $owner/$repo pattern (e.g., ehmpathy/rhachet-roles-bhuild)
   2. for --via os.fileops, same, $owner/$repo pattern

2. if --via is passed in, keep the first --via and failfast if a second --via is specified (this is what would allow us to deny permissions to --via certain channels, if desired)

3. we need to persist who & when pushed the task
  1. --via gh.issues, that's dont automatically for us on the auth token & metadata
  2. --via os.fileops, we should use some frontmatter

4. we need to persist the status of the task
   1. e.g., claimed vs delivered
   2. e.g., `rhx radio.task.push --exid xyz --status CLAIMED`
   3. in github, should persist that via...
      1. claimed = gh.issue.assigned && issue description.header updated with `ğŸŒ² tree planted at ${branch}`
      2. delivered = gh.issue.closed && description.header updated from `ğŸŒ² tree planted at ${branch}` to `ğŸŒ² tree delivered at ${branch}`
   4. in fileops, should persist that via
      1. claimed = frontmatter && description.header updated with `ğŸŒ² tree planted at ${branch}`
      2. delivered frontmatter && description.header updated from `ğŸŒ² tree planted at ${branch}` to `ğŸŒ² tree delivered at ${branch}`
      3. we should also make it easy to search for only open tasks, via a dedicated `$pathToTask.status=x.flag`
      4. so that folks can search on just `$pathToTasksDir/*.status=x.flag`, collect all the ones with the desired status, and then just list those

5. we need to support gh.issues auth
   1. via default gh token
   2. via gh app token (hopefully, can pass through as GITHUB_TOKEN still)
   3. e.g., `GITHUB_TOKEN=x rhx radio.task.push`

6. we need to be able to edit existing tasks
   1. e.g.,
      1. `rhx radio.task.push --exid xyz --title, --description, etc`
      2. `rhx radio.task.push --title --description` should be idempotent (if description is the same for that title, that's fine) - but we should also ...
         1. failfast if not an exact retry (e.g., mismatch on any of the attributes)
         2. allow if --idem findsert was specified (find or insert, but make it clear it was found)
         3. allow if --idem upsert was specified (find or update, but make it clear that we've updated it)
   2. and on updates, we should always keep a .bak version of it
      1. e.g., $pathToTask.bak.$isotimestamp

7. its important we structure this via an adapter architecture
   1. i.e., use declastruct dao pattern to support persistance of a RadioTask against any --via $channel
   2. that way we can easily add and replace more as time goes on
