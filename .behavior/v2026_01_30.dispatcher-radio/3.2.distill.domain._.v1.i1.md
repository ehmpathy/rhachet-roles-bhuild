# distill: domain model

> declastruct domain objects and operations for dispatcher radio

---

## 1. usecases â†’ contracts

### usecase 1: push new task

**contract**:
```typescript
await radioTaskPush({
  via: 'gh.issues',
  title: 'fix flaky test',
  description: 'timeout in ci',
  repo: { owner: 'ehmpathy', name: 'acme-app' }, // optional, defaults to current
});
// â†’ { task: RadioTask, outcome: 'created' }
```

**maps to criteria**: usecase.1, usecase.2, usecase.10

### usecase 2: claim task

**contract**:
```typescript
await radioTaskPush({
  via: 'gh.issues',
  exid: '142',
  status: 'CLAIMED',
});
// â†’ { task: RadioTask, outcome: 'updated' }
// task.status === 'CLAIMED', task.branch === 'vlad/fix-flaky-test'
```

**maps to criteria**: usecase.3

### usecase 3: deliver task

**contract**:
```typescript
await radioTaskPush({
  via: 'gh.issues',
  exid: '142',
  status: 'DELIVERED',
});
// â†’ { task: RadioTask, outcome: 'updated' }
// task.status === 'DELIVERED'
```

**maps to criteria**: usecase.4

### usecase 4: list tasks

**contract**:
```typescript
// list all tasks
await radioTaskPull({
  via: 'gh.issues',
  all: {},
});
// â†’ { tasks: RadioTask[] }

// list with filters
await radioTaskPull({
  via: 'gh.issues',
  all: {
    filter: { status: 'QUEUED' },
    limit: 10,
  },
});
// â†’ { tasks: RadioTask[] }
```

**maps to criteria**: usecase.5, usecase.6

### usecase 5: pull specific task

**contract**:
```typescript
await radioTaskPull({
  via: 'gh.issues',
  exid: '142',
});
// â†’ { task: RadioTask, cached: true }
```

**maps to criteria**: usecase.7, usecase.8

### usecase 6: edit task with idempotency

**contract**:
```typescript
await radioTaskPush({
  via: 'gh.issues',
  exid: '142',
  title: 'new title',
  idem: 'upsert',
});
// â†’ { task: RadioTask, outcome: 'updated', backup: '.radio/task.142.bak.2026-01-30.md' }
```

**maps to criteria**: usecase.9

---

## 2. domain objects

### 2.1 entities

#### RadioTask

the core domain entity. represents a task broadcast via radio channel.

```typescript
import { IsoDateStamp } from 'iso-time';

interface RadioTask {
  // identity
  exid: string;                        // external id (primary key from channel)

  // attributes
  title: string;                       // task title (unique within repo)
  description: string;                 // task description (required)
  status: RadioTaskStatus;             // QUEUED | CLAIMED | DELIVERED
  repo: RadioTaskRepo;                 // target repository

  // audit
  pushedBy: string;                    // who created the task
  pushedAt: IsoDateStamp;              // when created (iso date)
  claimedBy: string | null;            // who claimed the task
  claimedAt: IsoDateStamp | null;      // when claimed (iso date)
  deliveredAt: IsoDateStamp | null;    // when delivered (iso date)
  branch: string | null;               // git branch for claimed work
}

class RadioTask extends DomainEntity<RadioTask> implements RadioTask {
  public static primary = ['exid'] as const;
  public static unique = ['repo', 'title'] as const;
  public static updatable = ['title', 'description', 'status', 'claimedBy', 'claimedAt', 'deliveredAt', 'branch'] as const;
}
```

**identity**:
- primary key: `exid` (channel-specific identifier)
- unique key: `{ repo, title }`

**lifecycle**:
```
QUEUED â†’ CLAIMED â†’ DELIVERED
```

### 2.2 literals (value objects)

#### RadioTaskStatus

lifecycle states of a task.

```typescript
import { createIsOfEnum, Literalize } from 'type-fns';

enum RadioTaskStatus {
  QUEUED = 'QUEUED',
  CLAIMED = 'CLAIMED',
  DELIVERED = 'DELIVERED',
}

const isRadioTaskStatus = createIsOfEnum(RadioTaskStatus);

// usage: Literalize<typeof RadioTaskStatus.QUEUED> for narrowed type
```

**state machine**:
- `QUEUED` â†’ task created, awaits claim
- `CLAIMED` â†’ task claimed, work in progress
- `DELIVERED` â†’ task completed, work delivered

#### RadioChannel

communication path for task persistence.

```typescript
import { createIsOfEnum, Literalize } from 'type-fns';

enum RadioChannel {
  GH_ISSUES = 'gh.issues',
  OS_FILEOPS = 'os.fileops',
}

const isRadioChannel = createIsOfEnum(RadioChannel);

// usage: Literalize<typeof RadioChannel.GH_ISSUES> for narrowed type
```

**adapter pattern**: the channel determines which dao adapter handles persistence.

#### RadioTaskRepo

target repository for task dispatch.

```typescript
interface RadioTaskRepo {
  owner: string;  // e.g., "ehmpathy"
  name: string;   // e.g., "acme-app"
}

class RadioTaskRepo extends DomainLiteral<RadioTaskRepo> implements RadioTaskRepo {}
```

**format**: `$owner/$repo` (e.g., `ehmpathy/acme-app`)

#### IdempotencyMode

idempotency semantics for task push operations.

```typescript
import { createIsOfEnum, Literalize } from 'type-fns';

enum IdempotencyMode {
  FINDSERT = 'findsert',  // find or insert (ignore attribute mismatch)
  UPSERT = 'upsert',      // update or insert (overwrite if found)
}

const isIdempotencyMode = createIsOfEnum(IdempotencyMode);

// usage: Literalize<typeof IdempotencyMode.FINDSERT> for narrowed type
```

---

## 3. domain operations

### 3.1 dao interface (declastruct pattern)

```typescript
import { RefByPrimary, RefByUnique } from 'domain-objects';

interface DaoRadioTask {
  get: {
    one: {
      byPrimary(input: RefByPrimary<typeof RadioTask>): Promise<RadioTask | null>;
      byUnique(input: RefByUnique<typeof RadioTask>): Promise<RadioTask | null>;
    };
    all(input: {
      repo: RadioTaskRepo;
      filter?: { status?: RadioTaskStatus };
      limit?: number;
    }): Promise<RadioTask[]>;
  };
  set: {
    findsert(input: { task: RadioTask }): Promise<RadioTask>;
    upsert(input: { task: RadioTask }): Promise<RadioTask>;
  };
  del(input: RefByPrimary<typeof RadioTask>): Promise<void>;
}
```

### 3.2 adapter implementations

#### daoRadioTask.ghIssues

```typescript
/**
 * .what = dao adapter for github issues channel
 * .why = enables radio task persistence via github issues
 */
const daoRadioTaskGhIssues: DaoRadioTask = {
  get: {
    one: {
      byPrimary: async (input) => {
        // input: RefByPrimary<typeof RadioTask> â†’ { exid }
        // gh issue view $input.exid --json number,title,body,state,assignees
      },
      byUnique: async (input) => {
        // input: RefByUnique<typeof RadioTask> â†’ { repo, title }
        // gh issue list --search "ğŸ™ï¸ task: $input.title in:title" --json ...
      },
    },
    all: async ({ repo, filter, limit }) => {
      // gh issue list --state open|closed --search "ğŸ™ï¸ task:" --limit $limit --json ...
    },
  },
  set: {
    findsert: async ({ task }) => {
      // find by unique, return if found
      // else gh issue create
    },
    upsert: async ({ task }) => {
      // gh issue create or gh issue edit
    },
  },
  del: async (input) => {
    // input: RefByPrimary<typeof RadioTask> â†’ { exid }
    // gh issue close $input.exid --reason "not planned"
  },
};
```

#### daoRadioTask.osFileops

```typescript
/**
 * .what = dao adapter for local filesystem channel
 * .why = enables radio task persistence via filesystem for offline access
 */
const daoRadioTaskOsFileops: DaoRadioTask = {
  get: {
    one: {
      byPrimary: async (input) => {
        // input: RefByPrimary<typeof RadioTask> â†’ { exid }
        // fs.readFile(`.radio/task.${input.exid}._.md`)
        // parse yaml frontmatter
      },
      byUnique: async (input) => {
        // input: RefByUnique<typeof RadioTask> â†’ { repo, title }
        // glob for task.*._.md, parse each, match title
      },
    },
    all: async ({ repo, filter, limit }) => {
      // glob for task.*._.md or task.*._.status=${filter?.status}.flag
      // parse and return, limit results
    },
  },
  set: {
    findsert: async ({ task }) => {
      // find by unique, return if found
      // else write file with frontmatter
      // create status flag file
    },
    upsert: async ({ task }) => {
      // create .bak if exists
      // write file with frontmatter
      // update status flag file
    },
  },
  del: async (input) => {
    // input: RefByPrimary<typeof RadioTask> â†’ { exid }
    // fs.rm task file and flag file
  },
};
```

### 3.3 skill operations

#### radioTaskPush

```typescript
/**
 * .what = create a new task on a channel
 * .why = enables broadcast of new tasks with full required data
 */
export const setFullRadioTask = async (
  input: {
    via: RadioChannel;
    idem?: IdempotencyMode;
    task: Pick<RadioTask, 'repo' | 'title' | 'description'>;
  },
  context: { log: LogMethods },
): Promise<{
  task: RadioTask;
  outcome: 'created' | 'found';
}> => {
  // title + description required (enforced by types)
  // select dao, use findsert or upsert based on idem flag
};

/**
 * .what = update a found task on a channel
 * .why = enables status transitions and partial updates
 */
export const setPartRadioTask = async (
  input: {
    via: RadioChannel;
    task: Pick<RadioTask, 'exid'> & Partial<Pick<RadioTask, 'repo' | 'title' | 'description' | 'status'>>;
  },
  context: { log: LogMethods },
): Promise<{
  task: RadioTask;
  outcome: 'updated';
  backup?: string;
}> => {
  // exid required (enforced by types)
  // handle status transitions (QUEUED â†’ CLAIMED â†’ DELIVERED)
  // validate lifecycle order, create backup on edit
};

/**
 * .what = dispatch to setFullRadioTask or setPartRadioTask
 * .why = single entry point for cli that routes based on input shape
 */
export const radioTaskPush = async (
  input: {
    via: RadioChannel;
    idem?: IdempotencyMode;
    task: Partial<Pick<RadioTask, 'exid' | 'repo' | 'title' | 'description' | 'status'>>;
  },
  context: { log: LogMethods },
): Promise<{
  task: RadioTask;
  outcome: 'created' | 'found' | 'updated';
  backup?: string;
}> => {
  // resolve repo from git context if not provided
  // dispatch to setPartRadioTask if exid provided
  // dispatch to setFullRadioTask otherwise
};
```

#### radioTaskPull

```typescript
/**
 * .what = reads task(s) from a channel
 * .why = enables discovery and retrieval of tasks from remote repositories
 */

// overload: list tasks (with optional filter and limit)
export function radioTaskPull(
  input: {
    via: RadioChannel;
    repo?: RadioTaskRepo;
    all: {
      filter?: { status?: RadioTaskStatus };
      limit?: number;
    };
  },
  context: { log: LogMethods },
): Promise<{ tasks: RadioTask[] }>;

// overload: pull specific task (by primary or unique ref)
export function radioTaskPull(
  input: { via: RadioChannel; repo?: RadioTaskRepo; one: Omit<Ref<typeof RadioTask>, 'repo'> },
  context: { log: LogMethods },
): Promise<{ task: RadioTask; cached: boolean }>;

// implementation
export async function radioTaskPull(
  input: {
    via: RadioChannel;
    repo?: RadioTaskRepo;
    all?: { filter?: { status?: RadioTaskStatus }; limit?: number };
    one?: Omit<Ref<typeof RadioTask>, 'repo'>;  // { exid } | { title }
  },
  context: { log: LogMethods },
): Promise<{ tasks: RadioTask[] } | { task: RadioTask; cached: boolean }> {
  // resolve repo from git context if not provided
  // select dao adapter based on channel
  // if all: dao.get.all
  // if one: dao.get.one.byPrimary or byUnique based on ref shape
  // auto-cache to os.fileops if pull from remote
}
```

---

## 4. relationships

### 4.1 treestruct (domain hierarchy)

```
radio
  â””â”€ task
      â”œâ”€ RadioTask (entity)
      â”œâ”€ RadioTaskStatus (literal)
      â””â”€ operations
          â”œâ”€ push (skill)
          â””â”€ pull (skill)

channel
  â”œâ”€ gh.issues (adapter)
  â””â”€ os.fileops (adapter)

repo
  â””â”€ RadioTaskRepo (literal)

idempotency
  â””â”€ IdempotencyMode (literal)
```

### 4.2 dependencies

```
RadioTask
  â”œâ”€ depends on â†’ RadioTaskStatus (status field)
  â”œâ”€ depends on â†’ RadioTaskRepo (repo field)
  â””â”€ persisted via â†’ RadioChannel (adapter selection)

radioTaskPush
  â”œâ”€ depends on â†’ RadioTask
  â”œâ”€ depends on â†’ RadioChannel
  â”œâ”€ depends on â†’ IdempotencyMode
  â””â”€ uses â†’ daoRadioTask.$channel

radioTaskPull
  â”œâ”€ depends on â†’ RadioTask
  â”œâ”€ depends on â†’ RadioChannel
  â””â”€ uses â†’ daoRadioTask.$channel
```

### 4.3 composition flow

```
human/clone
    â”‚
    â–¼
radio.task.push --via $channel
    â”‚
    â–¼
radioTaskPush(input, context)
    â”‚
    â–¼
daoRadioTask.$channel.set.findsert/upsert
    â”‚
    â–¼
RadioTask persisted
    â”‚
    â–¼
radio.task.pull --via $channel
    â”‚
    â–¼
radioTaskPull(input, context)
    â”‚
    â–¼
daoRadioTask.$channel.get.one.byPrimary / get.all
    â”‚
    â–¼
RadioTask returned + cached to os.fileops
```

---

## 5. file structure

### 5.1 domain objects

```
src/domain.objects/
  â”œâ”€ RadioTask.ts
  â”œâ”€ RadioTaskStatus.ts
  â”œâ”€ RadioChannel.ts
  â”œâ”€ RadioTaskRepo.ts
  â””â”€ IdempotencyMode.ts
```

### 5.2 domain operations

```
src/domain.operations/
  â””â”€ radio/
      â””â”€ task/
          â”œâ”€ push/
          â”‚   â”œâ”€ radioTaskPush.ts
          â”‚   â””â”€ radioTaskPush.integration.test.ts
          â””â”€ pull/
              â”œâ”€ radioTaskPull.ts
              â””â”€ radioTaskPull.integration.test.ts
```

### 5.3 access layer (dao adapters)

```
src/access/
  â””â”€ daos/
      â””â”€ daoRadioTask/
          â”œâ”€ index.ts                    # exports daoRadioTask interface
          â”œâ”€ daoRadioTask.ghIssues.ts    # github issues adapter
          â”œâ”€ daoRadioTask.osFileops.ts   # filesystem adapter
          â””â”€ __tests__/
              â”œâ”€ daoRadioTask.ghIssues.integration.test.ts
              â””â”€ daoRadioTask.osFileops.integration.test.ts
```

### 5.4 contract layer (skills)

```
src/domain.roles/
  â””â”€ dispatcher/
      â””â”€ skills/
          â”œâ”€ radio.task.push.sh
          â””â”€ radio.task.pull.sh

src/contract/
  â””â”€ cli/
      â”œâ”€ radioTaskPush.ts    # cli entry point
      â””â”€ radioTaskPull.ts    # cli entry point
```

---

## 6. criteria coverage matrix

| criteria usecase | domain operation | dao method |
|-----------------|-----------------|------------|
| usecase.1 (push to gh.issues) | radioTaskPush | set.findsert |
| usecase.2 (push to os.fileops) | radioTaskPush | set.findsert |
| usecase.2b (cross-repo os.fileops) | radioTaskPush | set.findsert |
| usecase.3 (claim) | radioTaskPush | set.upsert |
| usecase.4 (deliver) | radioTaskPush | set.upsert |
| usecase.5 (list gh.issues) | radioTaskPull | get.all |
| usecase.6 (list os.fileops) | radioTaskPull | get.all |
| usecase.7 (pull specific) | radioTaskPull | get.one.byPrimary |
| usecase.8 (auto-cache) | radioTaskPull | get.one.byPrimary + set.findsert |
| usecase.9 (edit with idem) | radioTaskPush | set.upsert |
| usecase.10 (cross-repo) | radioTaskPush | set.findsert |
| usecase.11 (gh.issues format) | â€” | adapter internal |
| usecase.12 (os.fileops format) | â€” | adapter internal |
| usecase.13 (channel validation) | radioTaskPush/Pull | input validation |
| usecase.14 (edge cases) | radioTaskPush | input validation |

---

## 7. format specifications

### 7.1 gh.issues task format

```markdown
ğŸ™ï¸ task: {title}

ğŸ¦«  dispatch to foreman

ğŸ’§ task enqueued
   â”œâ”€ priority = ?
   â”œâ”€ yieldage = ?
   â””â”€ leverage = ?

ğŸŒ² tree planted at {branch}

---

{title}

{description}
```

### 7.2 os.fileops task format

```markdown
---
exid: "{exid}"
title: "{title}"
status: {status}
repo: "{owner}/{name}"
pushed_by: {pushedBy}
pushed_at: {pushedAt}
claimed_by: {claimedBy}
claimed_at: {claimedAt}
delivered_at: {deliveredAt}
branch: {branch}
---

ğŸ™ï¸ task: {title}

ğŸ¦«  dispatch to foreman

ğŸ’§ task enqueued
   â”œâ”€ priority = ?
   â”œâ”€ yieldage = ?
   â””â”€ leverage = ?

ğŸŒ² tree planted at {branch}

---

{title}

{description}
```

### 7.3 status flag files

```
.radio/task.{exid}._.status=QUEUED.flag   # empty file
.radio/task.{exid}._.status=CLAIMED.flag    # empty file
# no flag for DELIVERED (queryable via absence)
```

---

## 8. summary

the dispatcher radio domain consists of:

| category | items |
|----------|-------|
| entities | `RadioTask` |
| literals | `RadioTaskStatus`, `RadioChannel`, `RadioTaskRepo`, `IdempotencyMode` |
| dao interface | `daoRadioTask` with `get.one.*`, `get.all`, `set.*`, `del` methods |
| dao adapters | `daoRadioTask.ghIssues`, `daoRadioTask.osFileops` |
| operations | `radioTaskPush`, `radioTaskPull` |
| skills | `radio.task.push.sh`, `radio.task.pull.sh` |
| cli entries | `radioTaskPush.ts`, `radioTaskPull.ts` |

the declastruct pattern enables:
- channel-swappable persistence via dao adapters
- consistent behavior across `gh.issues` and `os.fileops`
- idempotent operations via `findsert` and `upsert`
- testability via adapter injection
