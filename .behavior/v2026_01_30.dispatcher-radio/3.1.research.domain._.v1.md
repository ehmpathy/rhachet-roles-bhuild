# research: domain model

> what domain objects and operations compose the dispatcher radio system?

---

## overview

the dispatcher radio domain consists of:

| category | items |
|----------|-------|
| entities | RadioTask |
| literals | RadioTaskStatus, RadioChannel, RadioTaskRepo, IdempotencyMode |
| operations | get.byPrimary, get.byUnique, get.all, set.findsert, set.upsert, del |
| skills | radio.task.push, radio.task.pull |

---

## 1. domain objects

### 1.1 RadioTask (entity)

the core domain entity. represents a task broadcast via radio channel.

```
RadioTask
  â”œâ”€ exid: string              # external id (primary key from channel)
  â”œâ”€ title: string             # task title (unique within repo)
  â”œâ”€ description: string             # task description (required)
  â”œâ”€ status: RadioTaskStatus        # QUEUED | CLAIMED | DELIVERED
  â”œâ”€ repo: RadioTaskRepo           # target repository
  â”œâ”€ pushed_by: string         # who created the task
  â”œâ”€ pushed_at: string         # when created (iso date)
  â”œâ”€ claimed_by: string | null # who claimed the task
  â”œâ”€ claimed_at: string | null # when claimed (iso date)
  â”œâ”€ delivered_at: string | null # when delivered (iso date)
  â””â”€ branch: string | null     # git branch for claimed work
```

**identity:**
- primary key: `exid` (channel-specific identifier)
- unique key: `{ repo, title }`

**lifecycle:**
```
QUEUED â†’ CLAIMED â†’ DELIVERED
```

**ddd pattern:**

> "domain entities are a fundamental build block of domain-driven design. entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them." [1]

> "a domain entity in ddd must implement the domain logic or behavior related to the entity data." [1]

### 1.2 RadioTaskStatus (literal/enum)

represents the lifecycle state of a task.

```
RadioTaskStatus
  â”œâ”€ QUEUED      # task created, awaits claim
  â”œâ”€ CLAIMED   # task claimed, work in progress
  â””â”€ DELIVERED # task completed, work delivered
```

**state machine:**

> "when build issueops workflows, common states for issues include opened, submitted, approved, denied, and closed." [2]

> "a 'state' is defined as a point in an object's lifecycle that satisfies certain condition(s), while an 'event' is an external occurrence that triggers a state change." [2]

### 1.3 RadioChannel (literal)

represents the communication channel for task persistence.

```
RadioChannel
  â”œâ”€ gh.issues   # github issues as task storage
  â””â”€ os.fileops  # local filesystem as task storage
```

**adapter pattern:**

the channel determines which dao adapter handles persistence. this enables channel-swap without logic change.

### 1.4 RadioTaskRepo (literal)

represents the target repository for task dispatch.

```
RadioTaskRepo
  â”œâ”€ owner: string  # e.g., "ehmpathy"
  â””â”€ name: string   # e.g., "acme-app"
```

**format:** `$owner/$repo` (e.g., `ehmpathy/acme-app`)

### 1.5 IdempotencyMode (literal/enum)

represents the idempotency semantics for task push operations.

```
IdempotencyMode
  â”œâ”€ findsert  # find or insert (ignore attribute mismatch)
  â””â”€ upsert    # update or insert (overwrite if found)
```

**pattern:**

> "an 'upsert' (update-or-insert) is a single operation that will insert a record if it doesn't exist, or update it if it does." [3]

> "upsert operations (insert or update if exists) are naturally idempotent. run an upsert 10 times with the same data, and you get the same result every time." [3]

note: "findsert" is a project-specific term for "find or insert with no update" â€” similar to "insert if not exists" semantics.

---

## 2. domain operations

### 2.1 dao interface (declastruct pattern)

```
daoRadioTask
  â”œâ”€ get
  â”‚   â”œâ”€ byPrimary({ exid }) â†’ RadioTask | null
  â”‚   â”œâ”€ byUnique({ repo, title }) â†’ RadioTask | null
  â”‚   â””â”€ all({ repo, status? }) â†’ RadioTask[]
  â”œâ”€ set
  â”‚   â”œâ”€ findsert(task) â†’ RadioTask
  â”‚   â””â”€ upsert(task) â†’ RadioTask
  â””â”€ del({ exid }) â†’ void
```

**operation semantics:**

| operation | behavior |
|-----------|----------|
| get.byPrimary | fetch task by external id |
| get.byUnique | fetch task by repo + title |
| get.all | list tasks, optionally filter by status |
| set.findsert | find or insert (no update if found) |
| set.upsert | update or insert (overwrite if found) |
| del | remove task by external id |

### 2.2 adapter implementations

```
daoRadioTask.ghIssues
  â””â”€ implements daoRadioTask via gh cli

daoRadioTask.osFileops
  â””â”€ implements daoRadioTask via filesystem
```

**aggregate root:**

> "an aggregate is composed of at least one entity: the aggregate root. the purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate." [1]

RadioTask is the aggregate root. each adapter ensures consistency within its channel.

---

## 3. skills (cli operations)

### 3.1 radio.task.push

creates or updates a task on a channel.

```
radio.task.push
  --via $channel          # required: gh.issues | os.fileops
  --title $title          # required for create
  --description $desc     # required for create
  --repo $owner/$repo     # optional (defaults to current git repo)
  --exid $exid            # optional (for update/status change)
  --status $status        # optional: QUEUED | CLAIMED | DELIVERED
  --idem $mode            # optional: findsert | upsert
```

**operations mapped:**

| input | operation |
|-------|-----------|
| --title (no --exid) | set.findsert or set.upsert |
| --exid --title | set.upsert |
| --exid --status | set.upsert (status change) |

### 3.2 radio.task.pull

reads task(s) from a channel.

```
radio.task.pull
  --via $channel          # required: gh.issues | os.fileops
  --list                  # list all tasks
  --exid $exid            # pull specific task
  --repo $owner/$repo     # optional (defaults to current git repo)
```

**operations mapped:**

| input | operation |
|-------|-----------|
| --list | get.all |
| --exid | get.byPrimary |

---

## 4. relationships

### 4.1 treestruct (domain hierarchy)

```
radio
  â””â”€ task
      â”œâ”€ RadioTask (entity)
      â”œâ”€ RadioTaskStatus (literal)
      â””â”€ operations
          â”œâ”€ push (skill)
          â””â”€ pull (skill)

channel
  â”œâ”€ gh.issues (adapter)
  â””â”€ os.fileops (adapter)

repo
  â””â”€ RadioTaskRepo (literal)

idempotency
  â””â”€ IdempotencyMode (literal)
```

### 4.2 dependencies

```
RadioTask
  â”œâ”€ depends on â†’ RadioTaskStatus (status field)
  â”œâ”€ depends on â†’ RadioTaskRepo (repo field)
  â””â”€ persisted via â†’ RadioChannel (adapter)

radio.task.push
  â”œâ”€ depends on â†’ RadioTask
  â”œâ”€ depends on â†’ RadioChannel
  â””â”€ depends on â†’ IdempotencyMode

radio.task.pull
  â”œâ”€ depends on â†’ RadioTask
  â””â”€ depends on â†’ RadioChannel
```

### 4.3 composition flow

```
human/clone
    â”‚
    â–¼
radio.task.push --via $channel
    â”‚
    â–¼
daoRadioTask.$channel.set.findsert/upsert
    â”‚
    â–¼
RadioTask persisted
    â”‚
    â–¼
radio.task.pull --via $channel
    â”‚
    â–¼
daoRadioTask.$channel.get.byPrimary/all
    â”‚
    â–¼
RadioTask returned
```

---

## 5. external references

### 5.1 github issues domain

the gh.issues channel maps to github's issue domain:

| RadioTask field | GitHub Issue field |
|-----------------|-------------------|
| exid | issue number |
| title | issue title (prefixed with ðŸŽ™ï¸) |
| description | issue body |
| status=QUEUED | issue state=open, unassigned |
| status=CLAIMED | issue state=open, assigned |
| status=DELIVERED | issue state=closed |
| pushed_by | issue author |
| pushed_at | issue created_at |
| claimed_by | issue assignee |
| branch | recorded in issue body |

### 5.2 filesystem domain

the os.fileops channel maps to filesystem structure:

| RadioTask field | Filesystem artifact |
|-----------------|---------------------|
| exid | filename: task.{exid}._.md |
| title | yaml frontmatter: title |
| description | file body after separator |
| status | yaml frontmatter + .flag file |
| pushed_by | yaml frontmatter: pushed_by |
| pushed_at | yaml frontmatter: pushed_at |
| claimed_by | yaml frontmatter: claimed_by |
| branch | yaml frontmatter: branch |

---

## 6. identity pattern

### 6.1 external id (exid)

the `exid` (external id) is the channel-specific identifier:

- gh.issues: issue number (e.g., `142`)
- os.fileops: generated uuid or sequential id

> "sometimes the same entity identifier has a different format and representation in different applications." [4]

> "the identifier of the domain identity is sometimes not used as the implemented identifier. that identifier value has unique characteristics in technical solutions within the domain, but that doesn't mean that the domain identifier is also the technical solution's unique identifier." [4]

### 6.2 unique key

the `{ repo, title }` tuple provides a secondary unique constraint:

- enables findsert semantics (find by title, insert if not found)
- prevents duplicate tasks with same title in same repo

---

## citations

[1] microsoft â€” design microservice domain model â€” https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model

[2] github blog â€” issueops â€” https://github.blog/engineering/issueops-automate-ci-cd-and-more-with-github-issues-and-actions/

[3] algomaster â€” idempotency in system design â€” https://algomaster.io/learn/system-design/idempotency

[4] medium â€” domain-driven design: the identifier type pattern â€” https://medium.com/@gara.mohamed/domain-driven-design-the-identifier-type-pattern-d86fd3c128b3
