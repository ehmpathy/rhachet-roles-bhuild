# vision: driver-bind for behavior routes

## the outcome world

### before

a behaver generates a `.behavior/` directory with stones (milestones) that guide a brain through deliberate thought — vision, criteria, research, blueprint, roadmap, execution.

but there's friction:
- the driver role doesn't know which route is "active" for this branch
- template files like `1.vision.md` exist alongside `1.vision.stone`, which confuses the driver into thought that work is done
- no quality gates exist — the brain can rush through milestones without human checkpoints
- files use `.src` extension instead of `.stone`, which hides their purpose

### after

the behaver hooks into the driver's `route.bind` skill at behavior init time:
- `.behavior/{name}` is automatically bound as the active route for the current branch
- no stale template files — only `.stone` prompts and `.guard` gates exist
- human approval gates at critical milestones (vision, blueprint) ensure quality
- the driver knows exactly where the brain is on the route and what's next

### the "aha" moment

you run `route.stone.get --stone @next-one` and it returns exactly the next milestone to work on. you complete it, run `route.stone.set --stone 1.vision --as passed`, the guard triggers, and it waits for human approval before it advances. no confusion. no rush. deliberate progress.

## user experience

### usecases

1. **init a behavior** → behaver creates route, binds it, brain is ready to drive
2. **check progress** → `route.stone.get --stone @next-one` shows current milestone
3. **complete a stone** → produce the artifact, mark as passed, guard validates
4. **human checkpoint** → critical stones (vision, blueprint) require explicit approval

### contract inputs & outputs

```sh
# bind route to branch (at behavior init)
npx rhachet run --repo bhrain --skill route.bind --route .behavior/v2026_02_09.driver-bind

# get next stone
npx rhachet run --repo bhrain --skill route.stone.get --stone @next-one --route .behavior/v2026_02_09.driver-bind

# mark stone as passed (triggers guard)
npx rhachet run --repo bhrain --skill route.stone.set --stone 1.vision --route .behavior/v2026_02_09.driver-bind --as passed

# mark stone as approved (human approval, bypasses guard)
npx rhachet run --repo bhrain --skill route.stone.set --stone 1.vision --route .behavior/v2026_02_09.driver-bind --as approved
```

### timeline

1. human creates wish → `0.wish.md`
2. behaver inits behavior → generates stones, binds route
3. brain drives through stones → vision → criteria → research → blueprint → roadmap → execution
4. human approves at gates → vision gate, blueprint gate
5. behavior complete → route unbinds naturally when branch merges

## mental model

### how users describe it

> "it's like a GPS for thought — you set the destination (wish), it shows you the next turn (stone), and there are checkpoints (guards) where someone confirms you're on track before you continue."

### analogies

- **GPS navigation**: destination = wish, turns = stones, checkpoints = guards
- **construction phases**: blueprint approval before you break ground
- **flight plan**: you file it, tower approves key waypoints

### terms

| user term | our term |
|-----------|----------|
| milestone | stone |
| checkpoint | guard |
| approve | mark as approved |
| next step | @next-one |

## evaluation

### how well does it solve the goals?

| goal | solved? |
|------|---------|
| bind behavior as active route | yes — `route.bind` at init time |
| remove template files that confuse | yes — only `.stone` and `.guard` remain |
| human approval at vision | yes — `1.vision.guard` with `approved?` judge |
| human approval at blueprint | yes — `3.3.blueprint.v1.guard` with `approved?` judge |
| learn route.stone.* skills | yes — docs in brief or source browse |

### pros

- deliberate progress — can't skip critical thought
- human in the loop — quality gates at key decisions
- clear state — driver knows exactly what's done and what's next
- composable — works with any .behavior route

### cons

- requires bhrain driver role installed
- human must be available to approve gates (async friction)
- curve to learn for new terms (stone, guard, route)

### edgecases & pit of success

| edgecase | pit of success |
|----------|----------------|
| brain tries to skip ahead | guard blocks until prior stones pass |
| human forgets to approve | stone stays queued, driver reminds |
| multiple behaviors on one branch | only one route bound at a time (explicit) |
| template file left behind | behavior init deletes templates, only stones remain |

## awkward discoveries

1. **name collision**: `1.vision.md` (artifact) vs `1.vision.stone` (prompt) vs `1.vision.guard` (gate) — three files with same prefix, different extensions. clear once learned, but initial confusion is possible.

2. **approval flow**: human must invoke `--as approved` explicitly. no ui, no notification system. relies on human discipline or external reminders.

3. **guard file format**: yaml with `judges` array that invokes shell commands. powerful but requires knowledge of the judge mechanisms (`approved?`, `reviewed?`).

---

*vision complete — ready for human approval at the 1.vision.guard gate*
