# research: test code patterns

## pattern.1 = giveFeedback unit test structure

**[EXTEND]** â€” need to add tests for findsert, latest version, and ++

### current structure

```typescript
// cite[1]: src/domain.operations/behavior/feedback/giveFeedback.test.ts:16-46
describe('giveFeedback', () => {
  let testDir: string;
  let behaviorDir: string;

  const setupTestRepo = () => {
    testDir = mkdtempSync(join(tmpdir(), 'give-feedback-test-'));

    // init git repo
    execSync('git init', { cwd: testDir });
    execSync('git config user.email "test@test.com"', { cwd: testDir });
    execSync('git config user.name "Test"', { cwd: testDir });
    writeFileSync(join(testDir, 'README.md'), '# test');
    execSync('git add . && git commit -m "init"', { cwd: testDir });

    // create behavior directory
    behaviorDir = join(testDir, '.behavior/v2025_01_01.test-feature');
    mkdirSync(behaviorDir, { recursive: true });

    // create default template
    writeFileSync(
      join(behaviorDir, '.ref.[feedback].v1.[given].by_human.md'),
      [
        'feedback for $BEHAVIOR_REF_NAME',
        'emit response to $BEHAVIOR_DIR_REL/response.md',
      ].join('\n'),
    );
  };

  afterEach(() => {
    if (testDir) rmSync(testDir, { recursive: true, force: true });
  });
```

### tests to add

1. `test('defaults to latest version when feedback exists')`
2. `test('version ++ creates next version')`
3. `test('findsert returns found when feedback exists')`

---

## pattern.2 = giveFeedback integration test with BDD style

**[EXTEND]** â€” need new cases for findsert, latest, and ++

### current BDD structure

```typescript
// cite[2]: src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts:10-49
given('[case1] behavior with execution artifact', () => {
  const testDir = path.join(os.tmpdir(), 'giveFeedback-int-case1');

  const scene = useBeforeAll(async () => {
    // clean and setup test repo
    fs.rmSync(testDir, { recursive: true, force: true });
    fs.mkdirSync(testDir, { recursive: true });

    // init git repo
    execSync('git init', { cwd: testDir });
    execSync('git config user.email "test@test.com"', { cwd: testDir });
    execSync('git config user.name "Test"', { cwd: testDir });
    fs.writeFileSync(path.join(testDir, 'README.md'), '# test');
    execSync('git add . && git commit -m "init"', { cwd: testDir });

    // create behavior directory
    const behaviorDir = path.join(
      testDir,
      '.behavior/v2025_01_01.test-feature',
    );
    fs.mkdirSync(behaviorDir, { recursive: true });

    // create template
    fs.writeFileSync(
      path.join(behaviorDir, '.ref.[feedback].v1.[given].by_human.md'),
      [
        '# feedback for $BEHAVIOR_REF_NAME',
        '',
        'emit response to $BEHAVIOR_DIR_REL/response.md',
      ].join('\n'),
    );

    // create execution artifact
    fs.writeFileSync(
      path.join(behaviorDir, '5.1.execution.v1.i1.md'),
      '# execution v1 attempt 1\n\nsome content here',
    );

    return { testDir, behaviorDir };
  });
```

### tests to update

current test throws on duplicate:

```typescript
// cite[3]: src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts:98-123
when('[t1] giveFeedback invoked second time for same artifact', () => {
  then('throws error about file already present', () => {
    // ensure feedback file exists from prior test
    const behaviorDir = path.join(
      scene.testDir,
      '.behavior/v2025_01_01.test-feature',
    );
    const feedbackPath = path.join(
      behaviorDir,
      '5.1.execution.v1.i1.md.[feedback].v1.[given].by_human.md',
    );
    if (!fs.existsSync(feedbackPath)) {
      giveFeedback(
        { against: 'execution', behavior: 'test-feature' },
        { cwd: scene.testDir },
      );
    }

    expect(() =>
      giveFeedback(
        { against: 'execution', behavior: 'test-feature' },
        { cwd: scene.testDir },
      ),
    ).toThrow(/already exists/);
  });
});
```

needs to become findsert:

```typescript
when('[t1] giveFeedback invoked second time for same artifact', () => {
  then('returns found feedback file without error', () => {
    // ...findsert behavior
  });
});
```

---

## pattern.3 = computeFooterOutput test structure

**[REUSE]** â€” same pattern for new computeFeedbackOutput tests

### output line assertion pattern

```typescript
// cite[4]: src/domain.operations/behavior/render/computeFooterOutput.test.ts:6-26
given('a wishPathRel', () => {
  when('computeFooterOutput is called', () => {
    const result = computeFooterOutput({
      wishPathRel: '.behavior/v2026_01_08.test/0.wish.md',
    });

    then('output line 1 is "ðŸŒ² go on then,"', () => {
      const lines = result.split('\n');
      expect(lines[0]).toEqual('ðŸŒ² go on then,');
    });

    then('output line 2 contains the path with tree prefix', () => {
      const lines = result.split('\n');
      expect(lines[1]).toEqual('   â”œâ”€ .behavior/v2026_01_08.test/0.wish.md');
    });

    then('output line 3 shows tip about --open', () => {
      const lines = result.split('\n');
      expect(lines[2]).toContain('tip: use --open');
    });
  });
});
```

---

## pattern.4 = opener test cases

**[REUSE]** â€” copy for feedback output tests

### with opener provided

```typescript
// cite[5]: src/domain.operations/behavior/render/computeFooterOutput.test.ts:57-83
given('path with opener', () => {
  when('computeFooterOutput is called with opener', () => {
    const result = computeFooterOutput({
      wishPathRel: '.behavior/v2026_01_08.test/0.wish.md',
      opener: 'vim',
    });

    then('wish path uses â”œâ”€ branch', () => {
      const lines = result.split('\n');
      expect(lines[1]).toContain('â”œâ”€');
    });

    then('third line shows "opened in" with opener name', () => {
      const lines = result.split('\n');
      expect(lines[2]).toContain('opened in vim');
    });

    then('third line uses â””â”€ branch', () => {
      const lines = result.split('\n');
      expect(lines[2]).toContain('â””â”€');
    });

    then('does not show --open tip', () => {
      expect(result).not.toContain('tip: use --open');
    });
  });
});
```

---

## pattern.5 = version detection test cases

**[REUSE]** â€” use for feedback version detection

### version sort test

```typescript
// cite[6]: src/domain.operations/behavior/feedback/getLatestArtifactByName.test.ts:110-121
test('version wins over attempt across versions', () => {
  writeFileSync(join(testDir, '5.1.execution.v1.i3.md'), '');
  writeFileSync(join(testDir, '5.1.execution.v2.i1.md'), '');

  const result = getLatestArtifactByName({
    behaviorDir: testDir,
    artifactName: 'execution',
  });

  expect(result?.filename).toEqual('5.1.execution.v2.i1.md');
  expect(result?.version).toEqual(2);
});
```

---

## pattern.6 = test repo setup helper

**[REUSE]** â€” same pattern for all behavior tests

### helper function

```typescript
// cite[7]: src/domain.operations/behavior/feedback/giveFeedback.test.ts:20-42
const setupTestRepo = () => {
  testDir = mkdtempSync(join(tmpdir(), 'give-feedback-test-'));

  // init git repo
  execSync('git init', { cwd: testDir });
  execSync('git config user.email "test@test.com"', { cwd: testDir });
  execSync('git config user.name "Test"', { cwd: testDir });
  writeFileSync(join(testDir, 'README.md'), '# test');
  execSync('git add . && git commit -m "init"', { cwd: testDir });

  // create behavior directory
  behaviorDir = join(testDir, '.behavior/v2025_01_01.test-feature');
  mkdirSync(behaviorDir, { recursive: true });

  // create default template
  writeFileSync(
    join(behaviorDir, '.ref.[feedback].v1.[given].by_human.md'),
    [
      'feedback for $BEHAVIOR_REF_NAME',
      'emit response to $BEHAVIOR_DIR_REL/response.md',
    ].join('\n'),
  );
};
```

---

## summary

| pattern | disposition | rationale |
|---------|-------------|-----------|
| giveFeedback unit tests | EXTEND | add findsert, latest, ++ tests |
| giveFeedback integration tests | EXTEND | update duplicate behavior, add new cases |
| computeFooterOutput tests | REUSE | same line-by-line assertion pattern |
| opener test cases | REUSE | copy for feedback opener tests |
| version detection tests | REUSE | same sort/latest pattern for feedback |
| test repo setup helper | REUSE | same git init + behavior dir pattern |

## new test cases needed

### unit tests

1. `test('defaults to latest version when feedback v1 exists')`
2. `test('defaults to latest version when feedback v1+v2 exist')`
3. `test('version ++ creates v2 when v1 exists')`
4. `test('version ++ creates v3 when v1+v2 exist')`
5. `test('findsert returns found when feedback exists (no error)')`

### integration tests

1. `given('[caseN] feedback v1 already exists')` â†’ findsert behavior
2. `given('[caseN] feedback v1+v2 already exist')` â†’ opens latest (v2)
3. `given('[caseN] --version ++ with v1')` â†’ creates v2

### output format tests (new file)

1. `given('feedback created')` â†’ `ðŸ¦« wassup?` header
2. `given('feedback found')` â†’ same output format
3. `given('--open provided')` â†’ `opened in {editor}` line
4. `given('--open not provided')` â†’ tip line
5. `given('any success')` â†’ `--version ++` tip line
