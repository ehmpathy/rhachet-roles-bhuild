# blueprint: settings-hooks pattern upgrade

## summary

upgrade rhachet-roles-bhuild hook initialization to match rhachet-roles-ehmpathy best practices:

1. **settings.json** (repo-level) instead of `settings.local.json` (user-level)
2. **rhachet run --init** pattern instead of direct script paths
3. **cleanup mechanism** for stale hooks
4. **tree output** for hook registration status

---

## blackbox criteria

### usecase.1 = hook initialization via `rhachet roles init --role behaver`

```
given('a repo with rhachet-roles-bhuild installed')
  when('user runs rhachet roles init --role behaver')
    then('creates .claude/settings.json if absent')
    then('binds sessionstart.boot-behavior hook')
    then('prints tree of newly bound hooks')
    then('prints tree of hooks already bound (idempotent)')
      sothat('user knows what hooks are active')
```

### usecase.2 = hook execution via rhachet run --init

```
given('a repo with behaver hooks bound')
  when('Claude session starts')
    then('SessionStart hook executes via rhachet run --init')
    then('boot-behavior output injected into session')
      sothat('agent starts with behavior context')
```

### usecase.3 = cleanup of stale hooks

```
given('a repo with stale hooks that reference removed scripts')
  when('user runs rhachet roles init --role behaver')
    then('stale hooks are removed from settings.json')
    then('valid hooks are preserved')
      sothat('settings.json stays clean')
```

### usecase.4 = idempotency

```
given('hooks already bound correctly')
  when('user runs rhachet roles init --role behaver again')
    then('no changes to settings.json')
    then('output shows "hooks already bound"')
      sothat('rerun is safe and predictable')
```

---

## subcomponent contracts

### init.claude.hooks.sh

```
given('init.claude.hooks.sh contract')
  then('exposes: main script that orchestrates hook bind')
  then('calls cleanup first to remove stale hooks')
  then('calls findsert for each hook in priority order')
  then('collects results and prints tree output')
  then('uses RHACHET_INIT="./node_modules/.bin/rhachet run --init" pattern')
```

### init.claude.hooks.findsert.sh

```
given('init.claude.hooks.findsert.sh contract')
  then('exposes: findsert(hookType, matcher, command, name, timeout?, position?, author?)')
  then('writes to .claude/settings.json (not settings.local.json)')
  then('creates settings.json if absent')
  then('idempotent: no-op if hook already present')
  then('supports position=prepend for priority hooks')
  then('outputs "bound successfully" or "already bound"')
```

### init.claude.hooks.cleanup.sh

```
given('init.claude.hooks.cleanup.sh contract')
  then('exposes: cleanup script for stale hooks')
  then('reads settings.json and checks each hook command')
  then('removes hooks whose command scripts no longer exist')
  then('preserves hooks from other repos/roles')
```

### claude.hooks/sessionstart.boot-behavior.sh

```
given('sessionstart.boot-behavior.sh contract')
  then('exposes: SessionStart hook for behavior injection')
  then('delegates to TypeScript via npx tsx import pattern')
  then('exits 0 always (never blocks session)')
  then('NO CHANGES to this file - keeps current npx tsx pattern')
```

---

## composition boundaries

### file structure

```
src/domain.roles/behaver/inits/
  ├── init.claude.hooks.sh           # orchestrator (update: cleanup, tree output, rhachet command)
  ├── init.claude.hooks.findsert.sh  # findsert utility (update: settings.json)
  ├── init.claude.hooks.cleanup.sh   # cleanup utility (new)
  └── claude.hooks/
      └── sessionstart.boot-behavior.sh  # hook script (NO CHANGES)
```

### key changes

| file | change |
|------|--------|
| `init.claude.hooks.findsert.sh` | `settings.local.json` → `settings.json` |
| `init.claude.hooks.sh` | add cleanup call, add tree output, use `rhachet run --init` in `--command` |
| `init.claude.hooks.cleanup.sh` | new file: removes stale hooks |
| `sessionstart.boot-behavior.sh` | **NO CHANGES** - keeps current `npx tsx` pattern |

### rhachet run --init pattern

the `rhachet run --init` pattern applies to **what command gets stored in settings.json**, not the skill scripts themselves.

**current** (in init.claude.hooks.sh):
```bash
"$FINDSERT" \
  --command "$HOOKS_DIR/sessionstart.boot-behavior.sh" \
  ...
```

**target** (in init.claude.hooks.sh):
```bash
RHACHET_INIT="./node_modules/.bin/rhachet run --repo bhuild --role behaver --init"

"$FINDSERT" \
  --command "$RHACHET_INIT sessionstart.boot-behavior" \
  ...
```

the skill scripts (like `sessionstart.boot-behavior.sh`) remain unchanged:
```bash
# sessionstart.boot-behavior.sh - NO CHANGES
npx tsx -e "import('rhachet-roles-bhuild').then(m => m.cli.bootBehavior())" -- "$@"
```

**why this matters**:
- `rhachet run --init` provides fast execution via compiled binary dispatch
- the hook command in settings.json calls rhachet, which then invokes the shell script
- shell scripts keep their `npx tsx` pattern for TypeScript delegation

---

## test coverage criteria

### how to test init scripts

init scripts are invoked via `rhachet roles init`, similar to skills:

```sh
# 1. build src → dist
npm run build

# 2. link dist → .agent (creates symlinks)
npx rhachet roles link --role behaver

# 3. run the init (the target under test)
npx rhachet roles init --role behaver
```

shorthand for iteration:
```sh
npm run build && npx rhachet roles link --role behaver && npx rhachet roles init --role behaver
```

### how to write tests

use the test infrastructure in `blackbox/.test/infra/`:

- **`genConsumerRepo()`** — creates a tmp git repo with rhachet-roles-bhuild installed as a dependency
- **`genTestGitRepo()`** — creates a minimal tmp git repo (for lighter-weight tests)
- **`runRolesInit()`** — runs `npx rhachet roles init` against a repo

#### example: integration test for findsert

```typescript
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { given, then, useBeforeAll, when } from 'test-fns';
import { genTestGitRepo } from '@blackbox/.test/infra';

describe('init.claude.hooks.findsert', () => {
  given('[case1] settings.json does not exist', () => {
    const testRepo = useBeforeAll(() =>
      genTestGitRepo({ prefix: 'findsert-test-' }),
    );

    when('[t0] findsert is called', () => {
      const result = useBeforeAll(() => {
        // create .claude dir
        fs.mkdirSync(path.join(testRepo.repoDir, '.claude'));

        // run findsert via the shell script
        return execSync(
          `bash ${process.cwd()}/dist/domain.roles/behaver/inits/init.claude.hooks.findsert.sh ` +
          `--type SessionStart --matcher "*" --command "echo test" --name "test-hook"`,
          { cwd: testRepo.repoDir },
        ).toString();
      });

      then('creates settings.json', () => {
        const settingsPath = path.join(testRepo.repoDir, '.claude', 'settings.json');
        expect(fs.existsSync(settingsPath)).toBe(true);
      });

      then('adds the hook to settings.json', () => {
        const settingsPath = path.join(testRepo.repoDir, '.claude', 'settings.json');
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        expect(settings.hooks.SessionStart).toBeDefined();
      });
    });
  });
});
```

#### example: integration test for full init flow

```typescript
import fs from 'fs';
import path from 'path';
import { given, then, useBeforeAll, when } from 'test-fns';
import { genConsumerRepo, runRolesInit } from '@blackbox/.test/infra';

describe('init.claude.hooks integration', () => {
  given('[case1] fresh consumer repo', () => {
    const consumer = useBeforeAll(() =>
      genConsumerRepo({
        prefix: 'hooks-init-test-',
        withClaudeDir: true,
      }),
    );

    afterAll(() => consumer.cleanup());

    when('[t0] roles init --role behaver is executed', () => {
      const result = useBeforeAll(() =>
        runRolesInit({
          repo: 'bhuild',
          role: 'behaver',
          repoDir: consumer.repoDir,
        }),
      );

      then('exits with code 0', () => {
        expect(result.exitCode).toBe(0);
      });

      then('creates settings.json (not settings.local.json)', () => {
        const settingsPath = path.join(consumer.repoDir, '.claude', 'settings.json');
        expect(fs.existsSync(settingsPath)).toBe(true);
      });

      then('hook command uses rhachet run --init pattern', () => {
        const settingsPath = path.join(consumer.repoDir, '.claude', 'settings.json');
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        const sessionStartMatchers = settings.hooks.SessionStart;
        const hookCommand = sessionStartMatchers[0]?.hooks[0]?.command;
        expect(hookCommand).toContain('rhachet run');
        expect(hookCommand).toContain('--init');
      });
    });

    when('[t1] roles init is executed twice', () => {
      then('second run is idempotent', () => {
        const first = runRolesInit({ repo: 'bhuild', role: 'behaver', repoDir: consumer.repoDir });
        const settingsBefore = fs.readFileSync(
          path.join(consumer.repoDir, '.claude', 'settings.json'),
          'utf-8',
        );

        const second = runRolesInit({ repo: 'bhuild', role: 'behaver', repoDir: consumer.repoDir });
        const settingsAfter = fs.readFileSync(
          path.join(consumer.repoDir, '.claude', 'settings.json'),
          'utf-8',
        );

        expect(second.exitCode).toBe(0);
        expect(settingsAfter).toEqual(settingsBefore);
      });
    });
  });
});
```

#### example: cleanup test with stale hooks

```typescript
import fs from 'fs';
import path from 'path';
import { given, then, useBeforeAll, when } from 'test-fns';
import { genConsumerRepo, runRolesInit } from '@blackbox/.test/infra';

describe('init.claude.hooks.cleanup', () => {
  given('[case1] settings.json has stale hooks', () => {
    const consumer = useBeforeAll(() => {
      const repo = genConsumerRepo({ prefix: 'cleanup-test-', withClaudeDir: true });

      // inject a stale hook that references a non-existent script
      const settingsPath = path.join(repo.repoDir, '.claude', 'settings.json');
      const settings = {
        hooks: {
          SessionStart: [{
            matcher: '*',
            hooks: [{
              command: '/path/to/nonexistent/script.sh',
              name: 'stale-hook',
              author: 'repo=bhuild/role=behaver',
            }],
          }],
        },
      };
      fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));

      return repo;
    });

    afterAll(() => consumer.cleanup());

    when('[t0] roles init is executed', () => {
      const result = useBeforeAll(() =>
        runRolesInit({ repo: 'bhuild', role: 'behaver', repoDir: consumer.repoDir }),
      );

      then('stale hook is removed', () => {
        const settingsPath = path.join(consumer.repoDir, '.claude', 'settings.json');
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        const hooks = settings.hooks.SessionStart?.[0]?.hooks ?? [];
        const staleHook = hooks.find((h: { name: string }) => h.name === 'stale-hook');
        expect(staleHook).toBeUndefined();
      });

      then('valid hooks are preserved', () => {
        const settingsPath = path.join(consumer.repoDir, '.claude', 'settings.json');
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
        const hooks = settings.hooks.SessionStart?.[0]?.hooks ?? [];
        const bootHook = hooks.find((h: { command: string }) =>
          h.command.includes('sessionstart.boot-behavior'),
        );
        expect(bootHook).toBeDefined();
      });
    });
  });
});
```

### test fixture assets

create new fixtures in `src/domain.roles/behaver/inits/.test/assets/` for these tests (shared across all hook-related tests, but separate from other test suites):

```
src/domain.roles/behaver/inits/.test/assets/
  ├── repo-empty-hooks/
  │   ├── .claude/
  │   │   └── settings.json         # { "hooks": {} }
  │   └── README.md
  ├── repo-stale-hook-ours/
  │   ├── .claude/
  │   │   └── settings.json         # stale hook authored by bhuild/behaver
  │   └── README.md
  ├── repo-stale-hook-other-role/
  │   ├── .claude/
  │   │   └── settings.json         # stale hook from repo=other/role=other
  │   └── README.md
  ├── repo-valid-boot-behavior/
  │   ├── .claude/
  │   │   └── settings.json         # correctly bound boot-behavior hook
  │   └── README.md
  ├── repo-multiple-matchers/
  │   ├── .claude/
  │   │   └── settings.json         # hooks with multiple matchers
  │   └── README.md
  ├── repo-with-bound-behavior/
  │   ├── .behavior/
  │   │   └── v2025_01_01.test-feature/
  │   │       ├── .bind/
  │   │       │   └── test-branch.flag
  │   │       └── 0.wish.md
  │   ├── .claude/
  │   │   └── settings.json         # empty hooks
  │   └── README.md
  └── repo-without-bound-behavior/
      ├── .claude/
      │   └── settings.json         # empty hooks
      └── README.md
```

#### fixture: repo-empty-hooks/

`.claude/settings.json`:
```json
{
  "hooks": {}
}
```

#### fixture: repo-stale-hook-ours/

`.claude/settings.json` — hook authored by us, but script path no longer exists:
```json
{
  "hooks": {
    "SessionStart": [{
      "matcher": "*",
      "hooks": [{
        "command": "/nonexistent/path/to/old-script.sh",
        "name": "stale-boot-behavior",
        "timeout": 30000,
        "author": "repo=bhuild/role=behaver"
      }]
    }]
  }
}
```

#### fixture: repo-stale-hook-other-role/

`.claude/settings.json` — hook authored by a different role (should be preserved, not cleaned):
```json
{
  "hooks": {
    "SessionStart": [{
      "matcher": "*",
      "hooks": [{
        "command": "/nonexistent/path/to/other-script.sh",
        "name": "other-role-hook",
        "timeout": 30000,
        "author": "repo=other/role=other"
      }]
    }]
  }
}
```

#### fixture: repo-valid-boot-behavior/

`.claude/settings.json` — hook already bound correctly (for idempotency test):
```json
{
  "hooks": {
    "SessionStart": [{
      "matcher": "*",
      "hooks": [{
        "command": "./node_modules/.bin/rhachet run --repo bhuild --role behaver --init sessionstart.boot-behavior",
        "name": "boot-behavior",
        "timeout": 30000,
        "author": "repo=bhuild/role=behaver"
      }]
    }]
  }
}
```

#### fixture: repo-multiple-matchers/

`.claude/settings.json` — multiple matchers to test append behavior:
```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "src/**",
        "hooks": [{
          "command": "echo src-hook",
          "name": "src-hook",
          "author": "repo=other/role=other"
        }]
      },
      {
        "matcher": "*",
        "hooks": [{
          "command": "echo global-hook",
          "name": "global-hook",
          "author": "repo=other/role=other"
        }]
      }
    ]
  }
}
```

#### fixture: repo-with-bound-behavior/

repo with a behavior bound to a branch (for boot-behavior output test):
```
.behavior/
  └── v2025_01_01.test-feature/
      ├── .bind/
      │   └── test-branch.flag    # empty file, branch is bound
      └── 0.wish.md               # "test the settings-hooks upgrade"
.claude/
  └── settings.json               # { "hooks": {} }
README.md                         # "# Test Repo"
```

#### fixture: repo-without-bound-behavior/

repo with no behavior bound (for boot-behavior graceful exit test):
```
.claude/
  └── settings.json    # { "hooks": {} }
README.md              # "# Test Repo"
```

#### usage in tests

```typescript
import path from 'path';
import { genTestGitRepo } from '@blackbox/.test/infra';

const ASSETS = path.join(__dirname, '.test/assets');

// create repo from fixture
const testRepo = genTestGitRepo({
  prefix: 'cleanup-test-',
  copyFrom: path.join(ASSETS, 'repo-stale-hook-ours'),
});

// testRepo.repoDir now has .claude/settings.json with stale hook
```

### integration tests

shell scripts interact with OS boundaries (filesystem, processes), so all tests are integration tests that run against tmp repos.

```
given('init.claude.hooks.findsert.sh')
  then('creates settings.json when absent')
  then('appends hook to empty hooks array')
  then('appends hook to found matcher')
  then('prepends hook when position=prepend')
  then('no-op when hook already present')
  then('validates required arguments')
```

```
given('init.claude.hooks.cleanup.sh')
  then('removes hooks with absent script files')
  then('preserves hooks with found script files')
  then('preserves hooks from other repos/roles')
  then('handles empty hooks array')
```

```
given('init.claude.hooks.sh')
  then('full init flow on fresh repo')
  then('idempotent rerun produces no changes')
  then('cleanup removes stale hooks')
  then('tree output format is correct')
```

```
given('sessionstart.boot-behavior.sh')
  then('hook executes and returns output')
  then('exits 0 on unbound branch')
  then('exits 0 on error (never blocks)')
```

### acceptance tests

```
given('behaver hook system')
  then('has acceptance test: rhachet roles init binds hooks to settings.json')
  then('has acceptance test: Claude session receives behavior context')
  then('has acceptance test: stale hooks are cleaned on reinit')
```

### test file locations

collocated test pattern:

```
src/domain.roles/behaver/inits/
  ├── init.claude.hooks.sh
  ├── init.claude.hooks.integration.test.ts
  ├── init.claude.hooks.findsert.sh
  ├── init.claude.hooks.findsert.integration.test.ts
  ├── init.claude.hooks.cleanup.sh
  └── init.claude.hooks.cleanup.integration.test.ts
```

---

## implementation steps

1. **update init.claude.hooks.findsert.sh**
   - change `SETTINGS_FILE` from `settings.local.json` to `settings.json`
   - update author to match convention

2. **create init.claude.hooks.cleanup.sh**
   - port pattern from rhachet-roles-ehmpathy
   - filter to only hooks authored by `repo=bhuild/role=behaver`

3. **update init.claude.hooks.sh**
   - add cleanup call before findsert calls
   - add tree output collection and display
   - use `rhachet run --init` pattern in `--command` arg to findsert

4. **add tests**
   - unit tests for findsert edge cases
   - unit tests for cleanup logic
   - integration test for full init flow
   - acceptance test for end-to-end hook bind

5. **update .gitignore**
   - ensure `.claude/settings.json` is tracked (repo-level)
   - ensure `.claude/settings.local.json` is ignored (user-level)

---

## notes

- **settings.json vs settings.local.json**: repo-level settings are version-controlled and shared; local settings are per-user overrides
- **rhachet run --init**: the command stored in settings.json; provides fast execution via rhachet's compiled binary dispatch
- **skill scripts unchanged**: `sessionstart.boot-behavior.sh` keeps its `npx tsx` pattern for TypeScript delegation
- **cleanup by author**: only remove hooks authored by this role, preserve hooks from other repos/roles
