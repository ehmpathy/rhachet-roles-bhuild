# research claims: portable-skills-no-npx

claims discovered via web research, relevant to the wish, vision, and criteria


# topic.1 = pnpm and npx compatibility

## [1] pnpm strict mode enforcement causes friction
- source: [pnpm issue #8087](https://github.com/pnpm/pnpm/issues/8087)
- quote: "ERR_PNPM_BAD_PM_VERSION This project is configured to use v9.1.1 of pnpm"
- label: [FACT]
- note: pnpm 9 introduced strict `package-manager-strict` enforcement that breaks cross-version workflows

## [2] npx muscle memory conflicts with pnpm node version management
- source: [pnpm issue #9661](https://github.com/pnpm/pnpm/issues/9661)
- quote: "many developers still have `npx $cmd` deeply ingrained in their muscle memory. This causes those commands to use the node version on `$PATH` instead of the one installed by pnpm"
- label: [FACT]
- note: npx bypasses pnpm's node version management

## [3] pnpm's strict dependency resolution differs from npm/npx
- source: [pnpm feature comparison](https://pnpm.io/feature-comparison)
- quote: "a package can access only dependencies that are specified in its package.json"
- label: [FACT]
- note: this strictness is intentional but causes compatibility issues when npx expects npm-style resolution

## [4] pnpm dlx vs npx have behavioral differences
- source: [pnpm discussion #5820](https://github.com/orgs/pnpm/discussions/5820)
- quote: "they expected `pnpm dlx` to work basically the same as `npx`, but that wasn't always the case"
- label: [FACT]
- note: conceptual equivalence does not equal behavioral equivalence

## [5] pnpm separates local vs remote binary execution
- source: [pnpm discussion #5590](https://github.com/orgs/pnpm/discussions/5590)
- quote: "`pnpx` was replaced by `pnpm dlx` to separate the functionality of running local binaries (`pnpm exec`) and remote binaries (`pnpm dlx`)"
- label: [FACT]
- note: pnpm philosophy favors explicit separation over npx's combined behavior


# topic.2 = tsx runtime vs compiled javascript

## [6] tsx provides fast development but is not for production
- source: [tsx FAQ](https://tsx.is/faq)
- quote: "TSX keeps the boundary clearâ€”use it for development speed, compile for production performance"
- label: [OPIN]
- note: tsx authors recommend compiled JS for production

## [7] tsx has no peer dependencies
- source: [Better Stack - TSX vs ts-node](https://betterstack.com/community/guides/scaling-nodejs/tsx-vs-ts-node/)
- quote: "It's a single binary with no peer-dependencies (e.g., TypeScript or esbuild), so there is no setup necessary"
- label: [FACT]
- note: tsx bundles everything, but still requires runtime compilation

## [8] tsx compilation is fast but still adds overhead
- source: [Better Stack - TSX vs ts-node](https://betterstack.com/community/guides/scaling-nodejs/tsx-vs-ts-node/)
- quote: "compilation only takes 20ms instead of over 500ms"
- label: [FACT]
- note: even 20ms per invocation adds up in cli tools

## [9] tsx does not perform type check
- source: [Better Stack - TSX vs ts-node](https://betterstack.com/community/guides/scaling-nodejs/tsx-vs-ts-node/)
- quote: "The main trade-off with tsx is that it doesn't perform type checking"
- label: [FACT]
- note: type safety must come from build step, not runtime

## [10] tsx requires node v19.6.0+ in ESM mode
- source: [tsx FAQ](https://tsx.is/faq)
- quote: "In CommonJS mode, tsx works broadly. But in Module/ESM mode, Node.js version v19.6.0 and up is required"
- label: [FACT]
- note: this is a portability constraint

## [11] pre-compiled JS is faster than runtime transpilation
- source: [LogRocket - tsx vs ts-node vs native](https://blog.logrocket.com/running-typescript-node-js-tsx-vs-ts-node-vs-native/)
- quote: "Loading TS files directly from disk and compiling with loaders is much slower than transpiling first and passing the JavaScript files directly"
- label: [FACT]
- note: compiled JS has zero transpilation overhead


# topic.3 = node.js module resolution

## [12] node supports self-reference via name + exports
- source: [Node.js packages documentation](https://nodejs.org/api/packages.html)
- quote: "The 'name' field can be used in addition to the 'exports' field to self-reference a package using its name"
- label: [FACT]
- note: native support since Node v12.17+/v13.7+, no symlinks needed

## [13] self-reference works with require and import
- source: [Node.js packages documentation](https://nodejs.org/api/packages.html)
- quote: "Self-referencing is available when using `require`, both in an ES module and in a CommonJS one"
- label: [FACT]
- note: works in both module systems

## [14] package.json exports field controls resolution
- source: [2ality - ESM specifiers](https://2ality.com/2022/01/esm-specifiers.html)
- quote: "With the introduction of pkg.exports, a module only exports the paths explicitly listed in pkg.exports"
- label: [FACT]
- note: unexported paths result in ERR_PACKAGE_PATH_NOT_EXPORTED

## [15] all package managers use npm registry by default
- source: [JSR docs](https://jsr.io/docs/publishing-packages)
- quote: "The most popular package manager is npm and comes bundled with Node.js. There are other popular package managers such as yarn and pnpm. All of these package managers use the npm registry by default"
- label: [FACT]
- note: package resolution is standardized across managers


# topic.4 = portable shell invocation patterns

## [16] direct path to node_modules/.bin is most portable
- source: [Exploring JS - shell operations](https://exploringjs.com/nodejs-shell-scripting/ch_installing-packages.html)
- quote: "directly executes the executable from the node_modules/.bin directory"
- label: [SUMP]
- note: works universally but requires the package to be installed

## [17] pnpm exec adds node_modules/.bin to PATH
- source: [pnpm exec docs](https://pnpm.io/cli/exec)
- quote: "node_modules/.bin is added to the PATH, so pnpm exec allows executing commands of dependencies"
- label: [FACT]
- note: pnpm has explicit exec command for local binaries

## [18] npm run adds node_modules/.bin to PATH
- source: [Better Stack - npm executables](https://betterstack.com/community/questions/how-to-use-executables-from-npm-package/)
- quote: "From npm with respect to npm run: In addition to the shell's pre-existing PATH, npm run adds node_modules/.bin to the PATH"
- label: [FACT]
- note: all package managers do this for run operations

## [19] $npm_execpath is not reliable on windows
- source: [flaming.codes - package-agnostic operations](https://flaming.codes/posts/package-agnostic-scripts-with-node-js)
- quote: "Sadly, using '$npm_execpath' to make operations work with any package manager doesn't reliably work on machines that have Windows installed"
- label: [FACT]
- note: platform-specific issues with env-based package manager detection


# topic.5 = node inline code execution

## [20] node -e with --input-type=module enables ESM
- source: [Node.js ESM docs](https://nodejs.org/api/esm.html)
- quote: "The argument `--input-type=module` can be used when the module's code is passed as a string using `--eval=\"<module-code>\"` argument"
- label: [FACT]
- note: this enables `import()` in inline code without npx

## [21] dynamic import() works in CommonJS context
- source: [LogRocket - ESM in Node](https://blog.logrocket.com/how-to-use-ecmascript-modules-with-node-js/)
- quote: "to import ESM into CommonJS you'll use the asynchronous `import()` function"
- label: [FACT]
- note: can use `node -e` with dynamic import() for ESM packages

## [22] require.resolve finds package paths
- source: [Node.js modules docs](https://nodejs.org/api/modules.html)
- quote: "To get the exact filename that will be loaded when `require()` is called, use the `require.resolve()` function"
- label: [FACT]
- note: can locate packages without executing them


# topic.6 = open questions

## [KHUE.1] what is the minimum node version to target?
- context: tsx requires v19.6.0+ for ESM, self-reference needs v12.17+
- question: should we require node 18 LTS as baseline?

## [KHUE.2] should skills use commonjs or esm for dispatch?
- context: CJS is simpler (`node -e "require(...)"`), ESM needs `--input-type=module`
- question: which approach has fewer edge cases?

## [KHUE.3] how to handle absent package gracefully?
- context: if rhachet-roles-bhuild not installed, skill fails
- question: what error message helps users diagnose?


# summary

## key facts for implementation
1. pnpm strict mode and npx have fundamental compatibility issues [1-5]
2. compiled JS is faster and more portable than tsx runtime [6-11]
3. node natively supports self-reference via name + exports [12-14]
4. all package managers resolve via standard node algorithm [15, 18]
5. `node -e` with dynamic `import()` works across all contexts [20-21]

## recommended approach (from research)
- eliminate npx tsx in favor of `node -e "import('pkg').then(...)"`
- use compiled JS (dist/) not TypeScript source
- rely on node's native self-reference (name + exports in package.json)
- this pattern works identically across npm, pnpm, yarn, bun
