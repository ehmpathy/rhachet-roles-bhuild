# blackbox criteria: portable-skills-no-npx

experience bounds for portable skill execution across package managers


# usecase.1 = skill invocation across package managers

given('a consumer repo with rhachet-roles-bhuild installed via npm')
  when('user invokes any skill')
    then('skill executes successfully')
    then('skill produces correct output')

given('a consumer repo with rhachet-roles-bhuild installed via pnpm')
  when('user invokes any skill')
    then('skill executes successfully')
    then('skill produces correct output')
      sothat('pnpm users have same experience as npm users')

given('a consumer repo with rhachet-roles-bhuild installed via yarn')
  when('user invokes any skill')
    then('skill executes successfully')
    then('skill produces correct output')
      sothat('yarn users have same experience as npm users')

given('a consumer repo with rhachet-roles-bhuild installed via bun')
  when('user invokes any skill')
    then('skill executes successfully')
    then('skill produces correct output')
      sothat('bun users have same experience as npm users')


# usecase.2 = no npx required

given('a system where npx is not in path')
  when('user invokes any skill')
    then('skill executes successfully')
      sothat('npx is not a runtime dependency')

given('a pnpm strict mode environment')
  when('user invokes any skill')
    then('skill does not shell out to npx')
    then('skill resolves imports via node directly')
      sothat('pnpm hoist restrictions are respected')


# usecase.3 = skill behavior preservation

given('any package manager')
  when('user invokes init.behavior skill')
    then('behavior directory is created with all artifacts')
    then('branch is auto-bound to new behavior')

  when('user invokes bind.behavior skill with "set"')
    then('branch is bound to specified behavior')

  when('user invokes bind.behavior skill with "get"')
    then('current bound behavior is returned or null')

  when('user invokes bind.behavior skill with "del"')
    then('bound behavior is removed for current branch')

  when('user invokes give.feedback skill')
    then('feedback file is created for target artifact')

  when('user invokes decompose.behavior skill')
    then('behavior is decomposed into sub-behaviors')


# usecase.4 = development workflow

given('a developer who works on rhachet-roles-bhuild itself')
  when('developer runs npm run build')
    then('skills dispatch to compiled js in dist/')

  when('developer runs npx rhachet roles link')
    then('symlinked skills work without npx tsx')

  when('developer modifies skill typescript source')
    then('rebuild is required before skill reflects changes')


# usecase.5 = error scenarios

given('a system without node available')
  when('user attempts to invoke a skill')
    then('clear error indicates node is required')

given('a consumer repo without rhachet-roles-bhuild installed')
  when('user attempts to invoke a skill')
    then('clear error indicates package not found')

given('invalid arguments to a skill')
  when('user invokes skill with bad args')
    then('same error behavior as current implementation')


# boundary.1 = runtime requirements

given('node v18+ installed')
  when('user invokes any skill')
    then('skill executes successfully')
    then('no tsx compilation occurs at runtime')
    then('startup time is equal or faster than npx tsx version')


# boundary.2 = package resolution

given('rhachet-roles-bhuild installed as dependency')
  when('skill imports from the package')
    then('import resolves via standard node module resolution')
      sothat('all package managers resolve correctly')

given('rhachet-roles-bhuild in development with file:. self-reference')
  when('skill imports from the package')
    then('import resolves to repo root dist/')


# edge.1 = concurrent invocation

given('multiple terminal sessions')
  when('same skill invoked concurrently')
    then('no race conditions or corruption')
    then('each invocation succeeds independently')
