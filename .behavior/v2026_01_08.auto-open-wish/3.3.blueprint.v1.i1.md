# blueprint: auto-open-wish

## summary

enhance `init.behavior` skill to:
1. display tree-style vibed output with unicode symbols
2. show relative path to wish file for easy open
3. accept `--open <opener>` flag to auto-open wish file with specified editor

---

## blackbox criteria satisfied

### usecase.1 = vibed tree-style output
```
given('init.behavior is executed')
  when('files are created or kept')
    then('output uses tree-style format with unicode box chars')
      sothat('output is visually clear and scannable')
    then('header displays "ðŸ¦« oh, behave!"')
    then('created files show "+" prefix')
    then('kept files show "âœ“" prefix')
    then('updated files show "â†»" prefix')
      sothat('file action type is immediately clear')
  when('init completes')
    then('footer displays "ðŸŒ² go on then,"')
    then('relative path to wish file is shown')
      sothat('user can easily copy/paste to open')
```

### usecase.2 = --open flag auto-opens wish
```
given('init.behavior is executed with --open <opener>')
  when('init succeeds')
    then('executes: <opener> <pathToWishFile>')
      sothat('user workflow is uninterrupted')
  when('<opener> is "vim"')
    then('runs: vim .behavior/vYYYY_MM_DD.name/0.wish.md')
  when('<opener> is "codium"')
    then('runs: codium .behavior/vYYYY_MM_DD.name/0.wish.md')
  when('<opener> command fails')
    then('warns but does not fail the overall init')
      sothat('behavior is still initialized even if opener absent')
```

### usecase.3 = relative path in output
```
given('init.behavior completes')
  when('success message is shown')
    then('wish path is relative to cwd, not absolute')
      sothat('path is shorter and easier to work with')
```

---

## subcomponent contracts

### computeOutputTree
```
given('computeOutputTree contract')
  then('exposes: computeOutputTree(input: { created: string[], kept: string[], updated: string[] }) => string')
  then('returns formatted tree string with:')
    - header: "ðŸ¦« oh, behave!"
    - tree lines with box-draw chars (â”œâ”€, â””â”€)
    - "+" for created, "âœ“" for kept, "â†»" for updated
    - sorted by filename
```

### computeFooterOutput
```
given('computeFooterOutput contract')
  then('exposes: computeFooterOutput(input: { wishPathRel: string }) => string')
  then('returns formatted footer:')
    - "ðŸŒ² go on then,"
    - "   â””â”€ <wishPathRel>"
```

### openFileWithOpener
```
given('openFileWithOpener contract')
  then('exposes: openFileWithOpener(input: { opener: string, filePath: string }) => void')
  then('executes shell command: <opener> <filePath>')
  then('returns void on success')
  then('throws OpenerUnavailableError on failure (fail-fast)')
  then('orchestrator catches OpenerUnavailableError specifically')
```

### OpenerUnavailableError
```
given('OpenerUnavailableError contract')
  then('extends HelpfulError')
  then('uses default HelpfulError constructor')
  then('used for control flow - orchestrator catches this specifically')
```

---

## composition boundaries

### init.behavior.ts orchestrator changes
```
given('init.behavior CLI implementation')
  then('adds --open <opener> to schema as optional string')
  then('composes computeOutputTree for file list')
  then('composes computeFooterOutput for success message')
  then('wraps openFileWithOpener in try/catch when --open provided')
  then('catches OpenerUnavailableError specifically and warns')
  then('rethrows unexpected errors (fail-fast for real bugs)')
  then('replaces console.log loops with single computeOutputTree call')
```

### domain operation locations
```
src/
â”œâ”€â”€ domain.operations/
â”‚   â””â”€â”€ behavior/
â”‚       â”œâ”€â”€ init/
â”‚       â”‚   â”œâ”€â”€ initBehaviorDir.ts          # prior - no change
â”‚       â”‚   â””â”€â”€ computeOutputTree.ts        # NEW
â”‚       â””â”€â”€ render/
â”‚           â””â”€â”€ computeFooterOutput.ts      # NEW
â”œâ”€â”€ infra/
â”‚   â””â”€â”€ shell/
â”‚       â””â”€â”€ openFileWithOpener.ts           # NEW
â””â”€â”€ contract/
    â””â”€â”€ cli/
        â””â”€â”€ init.behavior.ts                # MODIFY - orchestrate new components
```

---

## implementation plan

### phase 1: domain operations (pure functions)

#### 1.1 computeOutputTree.ts
```ts
/**
 * .what = compute tree-style output for behavior init file actions
 * .why = vibed, scannable output that shows file actions clearly
 */
export const computeOutputTree = (input: {
  created: string[];
  kept: string[];
  updated: string[];
}): string => {
  // combine and sort all files
  // map each to tree line with appropriate symbol
  // first n-1 use â”œâ”€, last uses â””â”€
  // return joined string
};
```

**symbols:**
- `+` = created (new file)
- `âœ“` = kept (already found)
- `â†»` = updated (found and modified)

**format:**
```
ðŸ¦« oh, behave!
   â”œâ”€ + .ref.[feedback].v1.[given].by_human.md
   â”œâ”€ âœ“ 0.wish.md
   â”œâ”€ + 1.vision.md
   ...
   â””â”€ + 5.1.execution.phase0_to_phaseN.v1.src
```

#### 1.2 computeFooterOutput.ts
```ts
/**
 * .what = compute footer output with relative wish path
 * .why = easy-to-copy path for open of the wish file
 */
export const computeFooterOutput = (input: {
  wishPathRel: string;
}): string => {
  return `ðŸŒ² go on then,\n   â””â”€ ${input.wishPathRel}`;
};
```

### phase 2: infra operation (shell interaction)

#### 2.1 OpenerUnavailableError.ts
```ts
import { HelpfulError } from 'helpful-errors';

/**
 * .what = error thrown when opener command is unavailable or fails
 * .why = named error for control flow - orchestrator catches this specifically
 */
export class OpenerUnavailableError extends HelpfulError {}
```

#### 2.2 openFileWithOpener.ts
```ts
/**
 * .what = open a file with specified editor/opener
 * .why = streamline user workflow by auto-open of wish file
 */
export const openFileWithOpener = (input: {
  opener: string;
  filePath: string;
}): void => {
  // use execSync with shell: true
  // on error: throw OpenerUnavailableError with cause
  // orchestrator catches OpenerUnavailableError specifically
};
```

### phase 3: orchestrator update

#### 3.1 modify init.behavior.ts
- add `open: z.string().optional()` to schema
- replace file list loop with `computeOutputTree()` call
- replace success message with `computeFooterOutput()` call
- when `--open` provided:
  - try `openFileWithOpener()` (fail-fast throws on error)
  - catch error at orchestrator level
  - warn user but continue (init already succeeded)
- compute `wishPathRel` = `${behaviorDirRel}/0.wish.md`

---

## test coverage criteria

### unit tests

#### computeOutputTree.test.ts
```
given('computeOutputTree')
  when('all files are created')
    then('all lines show "+" prefix')
  when('all files are kept')
    then('all lines show "âœ“" prefix')
  when('mixed created and kept')
    then('correct symbol per file action')
  when('files are provided')
    then('output is sorted alphabetically')
  when('last file in list')
    then('uses â””â”€ instead of â”œâ”€')
  when('empty input')
    then('returns header only')
```

#### computeFooterOutput.test.ts
```
given('computeFooterOutput')
  when('wishPathRel provided')
    then('returns formatted footer with path')
  when('path has special characters')
    then('preserves path exactly')
```

### integration tests

#### openFileWithOpener.integration.test.ts
```
given('openFileWithOpener')
  when('opener is "echo" (safe test command)')
    then('completes without error')
  when('opener is nonexistent command')
    then('throws OpenerUnavailableError')
    then('error.cause contains original shell error')
  when('file path has spaces')
    then('handles path correctly')
```

### acceptance tests (end-to-end)

#### init.behavior.acceptance.test.ts
```
given('[case1] init.behavior with --open echo')
  when('[t0] command executed')
    then('output contains "ðŸ¦« oh, behave!"')
    then('output contains tree-style format')
    then('output contains "ðŸŒ² go on then,"')
    then('output contains relative wish path')
    then('echo command was invoked with wish path')

given('[case2] init.behavior without --open')
  when('[t0] command executed')
    then('output contains vibed format')
    then('no opener command is invoked')

given('[case3] init.behavior with failed opener')
  when('[t0] command executed with --open nonexistent')
    then('behavior files are still created')
    then('warn is shown about opener failure')
    then('exit code is 0 (init succeeded)')
```

---

## file changes summary

| file | action | purpose |
|------|--------|---------|
| `src/domain.operations/behavior/init/computeOutputTree.ts` | CREATE | pure function for tree output |
| `src/domain.operations/behavior/init/computeOutputTree.test.ts` | CREATE | unit tests |
| `src/domain.operations/behavior/render/computeFooterOutput.ts` | CREATE | pure function for footer |
| `src/domain.operations/behavior/render/computeFooterOutput.test.ts` | CREATE | unit tests |
| `src/infra/shell/OpenerUnavailableError.ts` | CREATE | named error for control flow |
| `src/infra/shell/openFileWithOpener.ts` | CREATE | shell command executor |
| `src/infra/shell/openFileWithOpener.integration.test.ts` | CREATE | integration tests |
| `src/contract/cli/init.behavior.ts` | MODIFY | orchestrate new components |
| `src/contract/cli/init.behavior.acceptance.test.ts` | CREATE | e2e acceptance tests |

---

## edge cases to handle

1. **empty behavior dir** - all files created, all show `+`
2. **rerun (idempotent)** - all files kept, all show `âœ“`
3. **partial files found** - mix of `+` and `âœ“`
4. **opener not found** - throws `OpenerUnavailableError`, orchestrator catches and warns
5. **opener times out** - throws `OpenerUnavailableError`, orchestrator catches and warns
6. **path with spaces** - quote properly in shell command
7. **unicode terminal support** - assume modern terminal (reasonable for devs)

note: `OpenerUnavailableError` is caught at orchestrator level only. the `openFileWithOpener`
operation itself is fail-fast. unexpected errors (not `OpenerUnavailableError`) propagate
and crash - this avoids hidden failures from real bugs.

---

## constraints

- no new dependencies - use node built-ins (child_process, path)
- idempotent - safe to rerun
- fail-fast in domain operations - orchestrator decides error policy
- follow prior patterns - (input, context?) signature, arrow functions, .what/.why headers
