# blackbox criteria = experience bounds

## usecase.1 = open mode feedback creation

### output format experience

given('a user runs give.feedback skill')
  when('feedback is created successfully')
    then('output shows relative paths from git root')
      sothat('user can read paths without visual noise of absolute paths')
    then('output uses tree-style format with emoji header')
      sothat('user sees a friendly, scannable summary')
    then('output format matches pattern: ðŸ¦« wassup? â”œâ”€ {relativePath} â””â”€ {actionTaken}')
      sothat('user gets consistent, predictable output structure')

given('a user runs give.feedback --open codium')
  when('feedback is created successfully')
    then('feedback file opens in codium editor')
      sothat('user can immediately start to write feedback')
    then('output shows "opened in codium" as the action taken')
      sothat('user knows the file was opened')

given('a user runs give.feedback without --open flag')
  when('feedback is created successfully')
    then('output shows tip about --open option')
      sothat('user discovers the convenience feature')

### idempotent behavior (findsert pattern)

given('a user runs give.feedback')
  when('feedback file already exists')
    then('output says "already exists" with relative path')
      sothat('user knows file was found, not created')
    then('output shows tip about --version flag for new version creation')
      sothat('user knows how to create v2, v3, etc if needed')
    then('file is not overwritten')
      sothat('prior feedback is preserved')

given('a user runs give.feedback --open codium')
  when('feedback file already exists')
    then('output says "already exists"')
      sothat('user knows file was found')
    then('output shows tip about --version flag')
      sothat('user knows the option exists')
    then('file opens in codium editor')
      sothat('user can continue to edit prior feedback')

given('a user runs give.feedback --talk')
  when('feedback file already exists')
    then('output says "already exists"')
      sothat('user knows file was found')
    then('output shows tip about --version flag')
      sothat('user knows the option exists')
    then('repl mode starts')
      sothat('user can continue to add feedback to prior file')

### error experience

given('a user runs give.feedback')
  when('artifact is not found')
    then('error message shows what glob pattern was searched')
      sothat('user can debug why artifact was not found')


## usecase.2 = interactive repl feedback mode

### repl invocation

given('a user runs give.feedback --talk --against execution')
  when('command is invoked')
    then('repl mode starts with severity defaulted to "blocker"')
      sothat('user can immediately start to type feedback')
    then('repl displays current severity indicator')
      sothat('user knows what severity their feedback will have')

### severity toggle

given('a user is in repl mode')
  when('user presses shift+tab')
    then('severity toggles between "blocker" and "nitpick"')
      sothat('user can quickly change feedback severity')
    then('severity indicator updates visually')
      sothat('user sees immediate feedback on the toggle')

### feedback entry (inline multiline)

given('a user is in repl mode')
  when('user types text')
    then('multiline input is supported inline (no external editor)')
      sothat('user can write detailed feedback without context switch')
    then('shift+enter inserts a newline instead of submit')
      sothat('user can add lines via familiar keybind')
    then('alt+enter also inserts a newline')
      sothat('user has alternate keybind for newline')
    then('text is preserved until submitted or cleared')
      sothat('user can compose feedback without lost work')

### feedback submission (realtime file mutation)

given('a user is in repl mode with feedback text entered')
  when('user presses enter')
    then('feedback file is mutated immediately with "# blocker.N" or "# nitpick.N" block')
      sothat('file reflects feedback in realtime, visible in editor')
    then('N increments from a shared counter across both severities (e.g., blocker.1, nitpick.2, blocker.3 â€” never both blocker.1 and nitpick.1 in the same file)')
      sothat('user can reference specific feedback by number')
    then('input area clears for next feedback')
      sothat('user can continue to add more feedback')
    then('confirmation shows the header that was written (e.g., "# blocker.3")')
      sothat('user knows exactly what was saved')

given('a user submits feedback for a header that already exists')
  when('user presses enter')
    then('prior block content is replaced (upsert semantics)')
      sothat('user can revise feedback without manual file edits')

### change log for undo support

given('a user submits or modifies feedback')
  when('file mutation occurs')
    then('change event is appended to .log/changes.jsonl in behavior dir')
      sothat('history of changes is tracked')
    then('change event contains { index, severity, before, after }')
      sothat('prior state can be restored')

given('a user wants to undo a change')
  when('user presses ctrl-z after submit')
    then('prior content is restored from change log')
      sothat('user can recover from mistakes')
    then('undo confirmation shows what was restored')
      sothat('user sees what changed')

given('a user wants to redo after undo')
  when('user presses ctrl-shift-z or ctrl-y after undo')
    then('undone content is reapplied')
      sothat('user can toggle between states')

### current feedback indicator (footer below input)

given('a user is in repl mode')
  when('user is about to type feedback')
    then('footer shows next header that will be used (e.g., "# blocker.3 >")')
      sothat('user knows exactly what number their feedback will have')
    then('footer appears below the input area (like claude code)')
      sothat('user types above and sees status below')
    then('footer updates when severity is toggled')
      sothat('user sees the number change if they switch to nitpick')

### feedback clear (input buffer)

given('a user is in repl mode with feedback text entered but not yet submitted')
  when('user presses ctrl-c')
    then('current input buffer is cleared')
      sothat('user can start over')
    then('hint shows "ctrl-z to restore" after clear')
      sothat('user knows they can recover if cleared by mistake')

given('a user just pressed ctrl-c to clear input buffer')
  when('user presses ctrl-z')
    then('cleared input text is restored to buffer')
      sothat('user can recover accidentally cleared feedback')

### feedback history navigation

given('a user is in repl mode with empty input')
  when('user presses up arrow')
    then('previous feedback text is loaded into input')
      sothat('user can edit and resubmit prior feedback')

given('a user is in repl mode that views previous feedback')
  when('user presses down arrow')
    then('next feedback in history is shown, or input clears if at end')
      sothat('user can navigate through feedback history')

### repl exit

given('a user is in repl mode with empty input')
  when('user presses ctrl-c')
    then('repl mode exits gracefully')
      sothat('user can return to shell')
    then('summary of feedback added is shown')
      sothat('user sees what was accomplished')


## edge cases

### empty feedback handler

given('a user is in repl mode with empty input')
  when('user presses enter')
    then('no feedback is submitted')
      sothat('empty entries are not saved')
    then('repl remains in input mode')
      sothat('user can continue to compose')

### repl startup with prior feedback

given('a user runs --talk against an artifact with prior feedback file')
  when('repl mode starts')
    then('prompt shows next number based on prior items (e.g., "# blocker.4 >" if 3 blockers exist)')
      sothat('user knows exactly where they are in the sequence')
    then('repl shows count of prior feedback items')
      sothat('user knows the current state')
