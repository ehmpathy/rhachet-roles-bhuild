# blueprint: give.feedback tune (v1)

## overview

tune the give.feedback skill to deliver two modes:

1. **open mode** (default) - create feedback file with tree output, findsert semantics, --open support
2. **repl mode** (`--talk`) - extends open mode; performs all open mode steps first, then launches an interactive ink-based repl that mutates the feedback file for the user

---

## architecture

### file structure (new + extended)

```
src/
â”œâ”€â”€ contract/
â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ give.feedback.ts                    [EXTEND] add --open flag, --talk flag
â”‚
â”œâ”€â”€ domain.objects/
â”‚   â””â”€â”€ BehaviorFeedbackChangeEvent.ts                  [NEW] change log entry type
â”‚
â”œâ”€â”€ domain.operations/
â”‚   â””â”€â”€ behavior/
â”‚       â””â”€â”€ feedback/
â”‚           â”œâ”€â”€ giveFeedback.ts                 [EXTEND] findsert + output format
â”‚           â”œâ”€â”€ computeFeedbackOutput.ts        [NEW] tree output for give.feedback
â”‚           â”œâ”€â”€ getFeedbackFile.ts            [NEW] parse # blocker.N / # nitpick.N blocks
â”‚           â”œâ”€â”€ setFeedbackFile.ts           [NEW] upsert block into feedback file
â”‚           â”œâ”€â”€ emitChangeEvent.ts              [NEW] append to .log/changes.jsonl
â”‚           â””â”€â”€ repl/
â”‚               â”œâ”€â”€ FeedbackRepl.tsx            [NEW] ink component for repl
â”‚               â”œâ”€â”€ useFeedbackState.ts         [NEW] react hook for repl state
â”‚               â”œâ”€â”€ renderFeedbackRepl.ts       [NEW] ink render entry point
â”‚               â””â”€â”€ computeReplFooter.ts        [NEW] footer with severity + index
â”‚
â”œâ”€â”€ domain.roles/
â”‚   â””â”€â”€ behaver/
â”‚       â””â”€â”€ skills/
â”‚           â””â”€â”€ give.feedback.sh                [EXTEND] pass --open and --talk to cli
â”‚
â””â”€â”€ .test/
    â””â”€â”€ utils/
        â”œâ”€â”€ invokeGiveFeedbackSkill.ts          [NEW] skill invocation test utility
        â””â”€â”€ genTestFeedbackRepo.ts              [NEW] test fixture generator
```

---

## domain objects

### BehaviorFeedbackChangeEvent [NEW]

```typescript
// src/domain.objects/BehaviorFeedbackChangeEvent.ts

interface BehaviorFeedbackChangeEvent {
  timestamp: string;
  severity: 'blocker' | 'nitpick';
  index: number;
  before: string | null;
  after: string | null;
}
class BehaviorFeedbackChangeEvent extends DomainLiteral<BehaviorFeedbackChangeEvent>
  implements BehaviorFeedbackChangeEvent {}
```

**purpose**: typed change log entry for undo/redo support

---

## domain operations

### 1. giveFeedback.ts [EXTEND]

**current behavior**: throws BadRequestError if file exists

**new behavior**:
- findsert semantics: return `{ found: true }` if file exists
- return structured output suitable for tree format
- accept `--talk` flag to trigger repl mode
- **[BUGFIX]** when --version N specified, update template version declaration (e.g., `[feedback].v2.` not `[feedback].v1.`)

**signature change**:
```typescript
export const giveFeedback = (
  input: {
    against: string;
    behavior?: string;
    version?: number;
    template?: string;
    force?: boolean;
    talk?: boolean;    // [NEW]
    open?: string;     // [NEW]
  },
  context?: { cwd?: string },
): {
  feedbackFile: Artifact<typeof GitFile>; // feedback file artifact for downstream use
  artifactFile: string;
  behaviorDir: string;
  found: boolean;      // [NEW] true if file already existed
} => { ... }
```

---

### 2. computeFeedbackOutput.ts [NEW]

**purpose**: generate tree-style output for give.feedback

**signature**:
```typescript
export const computeFeedbackOutput = (input: {
  feedbackPathRel: string;
  found: boolean;
  opener?: string;
}): string => { ... }
```

**output format** (created, with --open):
```
ðŸ¦« wassup?
   â”œâ”€ .behavior/v2026_01_09.hook-adapter/5.1.execution....[feedback].v1.[given].by_human.md
   â””â”€ opened in codium
```

or (created, without --open):
```
ðŸ¦« wassup?
   â”œâ”€ .behavior/v2026_01_09.hook-adapter/5.1.execution....[feedback].v1.[given].by_human.md
   â””â”€ tip: use --open codium to open automatically
```

or (found, with --open):
```
ðŸ¦« wassup?
   â”œâ”€ .behavior/v2026_01_09.hook-adapter/5.1.execution....[feedback].v1.[given].by_human.md
   â”œâ”€ tip: use --version 2 to create a new version
   â””â”€ opened in codium
```

or (found, without --open):
```
ðŸ¦« wassup?
   â”œâ”€ .behavior/v2026_01_09.hook-adapter/5.1.execution....[feedback].v1.[given].by_human.md
   â”œâ”€ tip: use --version 2 to create a new version
   â””â”€ tip: use --open codium to open automatically
```

---

### feedback block format contract

a feedback block is delimited by triple horizontal rules and a header:

```markdown
---
---
---

# blocker.1

the feedback content goes here.
can be multiline.

---
---
---
```

**rules**:
- block starts with `---\n---\n---\n\n# {blocker|nitpick}.{N}`
- block ends with `---\n---\n---`
- N is a 1-indexed integer from a shared counter across both severities (e.g., blocker.1, nitpick.2, blocker.3 â€” never both blocker.1 and nitpick.1 in the same file)
- content is all text between header and end delimiter
- content can contain ANY characters â€” no restrictions, no escapes needed (triple `---` delimiter chosen because it never appears in normal feedback text && is still hand-writeable)

---

### 3. getFeedbackFile.ts [NEW]

**purpose**: parse prior feedback file to extract block counts per the block format contract

**signature**:
```typescript
export const getFeedbackFile = (input: {
  file: Artifact<typeof GitFile>;
}): {
  feedbackCount: number;
  blocks: Array<{ severity: 'blocker' | 'nitpick'; index: number; content: string }>;
} => { ... }
```

---

### 4. setFeedbackFile.ts [NEW]

**purpose**: upsert a `# blocker.N` or `# nitpick.N` block into feedback file

**signature**:
```typescript
export const setFeedbackFile = (input: {
  file: Artifact<typeof GitFile>; // Artifact from `rhachet-artifact`, GitFile from `rhachet-artifact-git`
  set: {
    add: {
      severity: 'blocker' | 'nitpick';
      index: number;
      content: string;
    };
  };
}): { before: string | null; after: string } => { ... }
```

**behavior**:
- if block exists, replace content (upsert)
- if block does not exist, append new block
- return before/after for change log

---

### 5. emitChangeEvent.ts [NEW]

**purpose**: append change event to `.log/changes.jsonl`

**signature**:
```typescript
export const emitChangeEvent = (input: {
  changeLog: Artifact<typeof GitFile>; // .log/changes.jsonl
  event: BehaviorFeedbackChangeEvent;
}): void => { ... }
```

**behavior**:
- create `.log/` directory if not exists (via artifact)
- use atomic append
- emit jsonl format (one JSON object per line)

---

### 6. FeedbackRepl.tsx [NEW]

**purpose**: ink component for interactive repl

**features**:
- ink Box + Spacer for footer layout
- ink-multiline-input for inline multiline
- shift+tab to toggle severity
- shift+enter / alt+enter for newline
- enter to submit
- ctrl-c to clear (or exit if empty)
- ctrl-z to undo
- up/down to navigate history

**structure**:
```tsx
const FeedbackRepl = ({ file, changeLog, onExit }) => {
  const state = useFeedbackState({ file, changeLog });

  return (
    <Box flexDirection="column" height={15}>
      <MultilineInput
        value={state.inputValue}
        onChange={state.setInputValue}
        onSubmit={state.handleSubmit}
        keyBindings={{
          submit: (key) => key.return && !key.shift && !key.meta,
          newline: (key) => (key.shift && key.return) || (key.meta && key.return),
        }}
      />
      <Spacer />
      <Box>
        <Text color={state.severity === 'blocker' ? 'red' : 'yellow'}>
          # {state.severity}.{state.nextIndex} &gt;
        </Text>
        <Text dimColor> (shift+tab to toggle)</Text>
      </Box>
    </Box>
  );
};
```

---

### 7. useFeedbackState.ts [NEW]

**purpose**: react hook to manage repl state

**signature**:
```typescript
export const useFeedbackState = (input: {
  file: Artifact<typeof GitFile>;
  changeLog: Artifact<typeof GitFile>; // .log/changes.jsonl for undo support
}): {
  inputValue: string;
  setInputValue: (val: string) => void;
  severity: 'blocker' | 'nitpick';
  toggleSeverity: () => void;
  nextIndex: number;
  handleSubmit: (text: string) => void;
  handleUndo: () => void;
  handleRedo: () => void;
  history: string[];
  historyIndex: number;
  navigateHistory: (direction: 'up' | 'down') => void;
} => { ... }
```

---

### 8. renderFeedbackRepl.ts [NEW]

**purpose**: entry point to render ink repl

**signature**:
```typescript
export const renderFeedbackRepl = (input: {
  file: Artifact<typeof GitFile>;      // feedback file to mutate
  changeLog: Artifact<typeof GitFile>; // .log/changes.jsonl for undo support
}): Promise<{ feedbackCount: number }> => { ... }
```

---

### 9. computeReplFooter.ts [NEW]

**purpose**: compute footer text for repl

**signature**:
```typescript
export const computeReplFooter = (input: {
  severity: 'blocker' | 'nitpick';
  nextIndex: number;
}): string => { ... }
```

---

## cli changes

### give.feedback.ts [EXTEND]

add `--talk` flag to zod schema:

```typescript
const schemaOfArgs = z.object({
  named: z.object({
    behavior: z.string().optional(),
    against: z.string().optional(),
    version: z.coerce.number().optional(),
    template: z.string().optional(),
    force: z.boolean().default(false),
    open: z.string().optional(),
    talk: z.boolean().default(false),  // [NEW]
  }),
  ordered: z.array(z.string()).default([]),
});
```

### give.feedback.sh [EXTEND]

pass `--open` and `--talk` flags through:

```bash
if [[ -n "$OPEN" ]]; then
  ARGS+=("--open" "$OPEN")
fi

if [[ "$TALK" == "true" ]]; then
  ARGS+=("--talk")
fi
```

---

## dependencies

### new runtime deps

```json
{
  "dependencies": {
    "ink": "^5.0.0",
    "ink-multiline-input": "^0.1.0",
    "picocolors": "^1.0.0",
    "react": "^18.0.0"
  }
}
```

### reused deps

- `helpful-errors` (BadRequestError)
- `zod` (cli arg validation)
- `fs/promises` (file operations)

### new dev deps

```json
{
  "devDependencies": {
    "ink-testing-library": "^4.0.0"
  }
}
```

---

## test approach: FeedbackRepl.tsx

### ink-testing-library

the official [ink-testing-library](https://github.com/vadimdemedes/ink-testing-library) provides utilities for test of ink components:

- `render()` - renders component and returns test utilities
- `lastFrame()` - returns the last rendered output (for snapshot assertions)
- `frames` - array of all rendered outputs (for transition assertions)
- `rerender()` - rerender with different props
- `stdin.write()` - simulate keyboard input

### key simulation via stdin.write

ink's `useInput` hook parses stdin and provides a key object with modifier flags:

```typescript
useInput((input, key) => {
  // key.shift, key.ctrl, key.tab, key.return, key.escape, etc.
  if (key.shift && key.tab) toggleSeverity();
  if (key.ctrl && input === 'z') handleUndo();
});
```

to test key combinations, write the appropriate ANSI escape sequences:

| key combo | stdin.write value | notes |
|-----------|-------------------|-------|
| enter | `\r` | submit feedback |
| shift+enter | `\x1b[13;2u` or library helper | newline in input |
| tab | `\t` | (unused) |
| shift+tab | `\x1b[Z` | toggle severity |
| ctrl+c | `\x03` | clear or exit |
| ctrl+z | `\x1a` | undo |
| up arrow | `\x1b[A` | history prev |
| down arrow | `\x1b[B` | history next |
| text | `'hello'` | direct character input |

### test structure for FeedbackRepl.tsx

```typescript
import { render } from 'ink-testing-library';
import { FeedbackRepl } from './FeedbackRepl';

describe('FeedbackRepl', () => {
  given('[case1] fresh repl with empty feedback file', () => {
    const scene = useBeforeAll(async () => {
      const file = genTestArtifact({ content: '# feedback\n' });
      const changeLog = genTestArtifact({ content: '' });
      return { file, changeLog };
    });

    when('[t0] repl renders', () => {
      then('footer shows blocker.1 by default', () => {
        const { lastFrame } = render(
          <FeedbackRepl file={scene.file} changeLog={scene.changeLog} onExit={jest.fn()} />
        );
        expect(lastFrame()).toContain('# blocker.1');
      });

      then('output matches snapshot', () => {
        const { lastFrame } = render(
          <FeedbackRepl file={scene.file} changeLog={scene.changeLog} onExit={jest.fn()} />
        );
        expect(lastFrame()).toMatchSnapshot();
      });
    });

    when('[t1] user presses shift+tab', () => {
      then('severity toggles to nitpick', async () => {
        const { lastFrame, stdin } = render(
          <FeedbackRepl file={scene.file} changeLog={scene.changeLog} onExit={jest.fn()} />
        );
        stdin.write('\x1b[Z'); // shift+tab
        await delay(10);
        expect(lastFrame()).toContain('# nitpick.1');
      });
    });

    when('[t2] user types and presses enter', () => {
      then('feedback is submitted to file', async () => {
        const { stdin } = render(
          <FeedbackRepl file={scene.file} changeLog={scene.changeLog} onExit={jest.fn()} />
        );
        stdin.write('this is feedback');
        stdin.write('\r'); // enter
        await delay(10);
        const content = await scene.file.get();
        expect(content).toContain('# blocker.1');
        expect(content).toContain('this is feedback');
      });
    });
  });
});
```

### snapshot strategy

use jest snapshots for:
- initial render state (footer, prompt)
- post-toggle render state
- post-submit confirmation message
- error states

```typescript
then('initial render matches snapshot', () => {
  const { lastFrame } = render(<FeedbackRepl {...props} />);
  expect(lastFrame()).toMatchSnapshot();
});
```

snapshot files committed to `.test/__snapshots__/` enable:
- visual review in PRs of CLI output changes
- regression detection for output format
- aesthetic verification of colors and layout

### test cases for FeedbackRepl.tsx

| category | test case | assertion |
|----------|-----------|-----------|
| **render** | initial render | footer shows `# blocker.1 >` |
| **render** | with prior feedback | footer shows `# blocker.N+1 >` |
| **severity** | shift+tab once | toggles to nitpick |
| **severity** | shift+tab twice | toggles back to blocker |
| **input** | type text | text appears in input area |
| **input** | shift+enter | inserts newline, no submit |
| **submit** | enter with text | file mutated, input cleared |
| **submit** | enter with empty | no mutation, stays in input |
| **undo** | ctrl+z after submit | prior content restored |
| **redo** | ctrl+y after undo | undone content reapplied |
| **history** | up arrow | loads previous feedback |
| **history** | down arrow | loads next or clears |
| **clear** | ctrl+c with text | clears input buffer |
| **exit** | ctrl+c with empty | calls onExit, shows summary |
| **snapshot** | all key states | output matches snapshot |

### test of useFeedbackState hook

test the hook in isolation via `@testing-library/react-hooks` or inline component:

```typescript
const TestHarness = ({ file, changeLog, onState }) => {
  const state = useFeedbackState({ file, changeLog });
  useEffect(() => onState(state), [state]);
  return null;
};

test('toggleSeverity switches between blocker and nitpick', () => {
  let captured;
  render(<TestHarness file={file} changeLog={changeLog} onState={s => captured = s} />);
  expect(captured.severity).toBe('blocker');
  act(() => captured.toggleSeverity());
  expect(captured.severity).toBe('nitpick');
});
```

### references

- [ink-testing-library](https://github.com/vadimdemedes/ink-testing-library) â€” official test utilities
- [ink useInput docs](https://github.com/vadimdemedes/ink#useinputinputhandler-options) â€” keyboard input handler
- [jest snapshot test](https://jestjs.io/docs/snapshot-testing) â€” snapshot assertion patterns
- [ANSI escape sequences](https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797) â€” key code reference

---

## test coverage plan

### unit tests

| file | test file | cases |
|------|-----------|-------|
| `computeFeedbackOutput.ts` | `computeFeedbackOutput.test.ts` | tree format, found vs created, opener vs tip |
| `getFeedbackFile.ts` | `getFeedbackFile.test.ts` | empty file, blockers only, mixed, malformed |
| `setFeedbackFile.ts` | `setFeedbackFile.test.ts` | insert new, upsert replace, before/after tracked |
| `computeReplFooter.ts` | `computeReplFooter.test.ts` | blocker.1, nitpick.5, color codes |
| `BehaviorFeedbackChangeEvent.ts` | `BehaviorFeedbackChangeEvent.test.ts` | instantiation, serialization |
| `initFeedbackTemplate.ts` | `initFeedbackTemplate.test.ts` | **[NEW]** --version updates template version declaration |
| `useFeedbackState.ts` | `useFeedbackState.test.ts` | severity toggle, nextIndex calc, submit handler, undo/redo |
| `FeedbackRepl.tsx` | `FeedbackRepl.test.tsx` | render + snapshot, key combos, state transitions (see detailed test approach above) |

### integration tests

| file | test file | cases |
|------|-----------|-------|
| `giveFeedback.ts` | `giveFeedback.integration.test.ts` | findsert new, findsert found, --open flag, --version flag |
| `emitChangeEvent.ts` | `emitChangeEvent.integration.test.ts` | create .log dir, append events, jsonl format |
| `setFeedbackFile.ts` | `setFeedbackFile.integration.test.ts` | real file mutations, concurrent safety |

### end-to-end integration tests

| scenario | test file | cases |
|----------|-----------|-------|
| skill invocation | `give.feedback.integration.test.ts` | open mode output format, error output format |
| repl startup | `feedbackRepl.integration.test.ts` | repl renders, severity toggle, footer updates |

### acceptance tests (blackbox)

| usecase | test file | cases |
|---------|-----------|-------|
| open mode creation | `give.feedback.acceptance.test.ts` | tree output with relative paths |
| open mode findsert | `give.feedback.acceptance.test.ts` | "already exists" + --version tip |
| open mode --open | `give.feedback.acceptance.test.ts` | "opened in codium" output |
| repl mode | `give.feedback.acceptance.test.ts` | severity default, toggle, submit, file mutation |
| repl undo | `give.feedback.acceptance.test.ts` | ctrl-z restores prior content |
| repl exit | `give.feedback.acceptance.test.ts` | ctrl-c shows summary |

---

## test utilities [NEW]

### invokeGiveFeedbackSkill.ts

```typescript
export const invokeGiveFeedbackSkill = (input: {
  against: string;
  behavior?: string;
  dir: string;
  open?: string;
  talk?: boolean;
}): { stdout: string; exitCode: number } => { ... }
```

### genTestFeedbackRepo.ts

```typescript
export const genTestFeedbackRepo = (input: {
  prefix: string;
  artifact: string;
  template?: string;
}): { repoDir: string; behaviorDir: string; cleanup: () => void } => { ... }
```

---

## implementation phases

### phase 1: open mode tune

**scope**: output format + findsert + --open

**files**:
1. `computeFeedbackOutput.ts` + unit tests
2. `giveFeedback.ts` extend for findsert + output
3. `give.feedback.ts` cli extend for --open
4. `give.feedback.sh` pass --open
5. integration tests for open mode
6. acceptance tests for open mode

**criteria coverage**:
- usecase.1 output format experience âœ“
- usecase.1 idempotent behavior âœ“
- usecase.1 error experience âœ“

---

### phase 2: repl mode core

**depends on**: phase 1 (repl mode extends open mode â€” runs all open mode steps first, then launches repl)

**scope**: basic repl with severity toggle + submit

**files**:
1. add ink, ink-multiline-input, picocolors, react deps
2. enable tsx support:
   - tsconfig.json: add `"jsx": "react-jsx"` to compilerOptions, add `**/*.tsx` to include
   - tsconfig.build.json: add `src/**/*.tsx` to include
   - biome.jsonc: add `**/src/**/*.tsx` to files.includes
3. `BehaviorFeedbackChangeEvent.ts` + unit tests
4. `getFeedbackFile.ts` + unit tests
5. `setFeedbackFile.ts` + unit tests
6. `emitChangeEvent.ts` + integration tests
7. `useFeedbackState.ts` + unit tests
8. `computeReplFooter.ts` + unit tests
9. `FeedbackRepl.tsx`
10. `renderFeedbackRepl.ts`
11. `giveFeedback.ts` extend for --talk (--open added in phase 1)
12. `give.feedback.ts` cli extend for --talk (--open added in phase 1)
13. `give.feedback.sh` pass --talk (--open added in phase 1)

**criteria coverage**:
- usecase.2 repl invocation âœ“
- usecase.2 severity toggle âœ“
- usecase.2 feedback entry âœ“
- usecase.2 feedback submission âœ“
- usecase.2 current feedback indicator âœ“

---

### phase 3: repl mode undo/redo + history

**depends on**: phase 2

**scope**: change log, undo/redo, history navigation

**files**:
1. extend `useFeedbackState.ts` for undo/redo
2. extend `FeedbackRepl.tsx` for ctrl-z, ctrl-y
3. extend `useFeedbackState.ts` for history navigation
4. extend `FeedbackRepl.tsx` for up/down arrow
5. integration tests for undo/redo
6. integration tests for history navigation
7. acceptance tests for full repl behavior

**criteria coverage**:
- usecase.2 change log for undo support âœ“
- usecase.2 feedback clear âœ“
- usecase.2 feedback history navigation âœ“
- usecase.2 repl exit âœ“
- edge cases âœ“

---

## risk assessment

| risk | mitigation |
|------|------------|
| ink bundle size | tree-shake unused ink components |
| ink compat with tsx | test in ci before merge |
| multiline input edge cases | snapshot tests for key combos |
| concurrent file mutation | use atomic operations, test concurrency |
| change log corruption | jsonl format is append-safe |

---

## references

- [0.wish.md](./0.wish.md)
- [2.criteria.blackbox.md](./2.criteria.blackbox.md)
- [3.1.research.patterns._.code.prod.v1.i1.md](./3.1.research.patterns._.code.prod.v1.i1.md)
- [3.1.research.patterns._.code.test.v1.i1.md](./3.1.research.patterns._.code.test.v1.i1.md)
- [3.1.research.patterns._.oss.levers.v2.md](./3.1.research.patterns._.oss.levers.v2.md)
