# research: production codepath patterns for give.feedback tune (v1)

## summary

| pattern | file | action | rationale |
|---------|------|--------|-----------|
| tree output | `computeOutputTree.ts` | **[REUSE]** | exact match for ðŸ¦« wassup? tree format |
| footer output | `computeFooterOutput.ts` | **[EXTEND]** | adapt for repl status line |
| editor open | `openFileWithOpener.ts` | **[REUSE]** | same --open pattern as init.behavior |
| findsert | `initBehaviorDir.ts` | **[REUSE]** | idempotent file create pattern |
| cli args | `getCliArgs.ts` | **[REUSE]** | zod schema validation for --talk, --against |
| give.feedback | `giveFeedback.ts` | **[EXTEND]** | add --talk mode, findsert semantics |
| template init | `initFeedbackTemplate.ts` | **[REUSE]** | placeholder substitution |

---

## 1. tree output pattern

**file**: `src/domain.operations/behavior/init/computeOutputTree.ts`

**action**: **[REUSE]**

**quote** [1]:
```typescript
export const computeOutputTree = (input: {
  created: string[];
  kept: string[];
  updated: string[];
}): string => {
  const symbolCreated = '+';
  const symbolKept = 'âœ“';
  const symbolUpdated = 'â†»';
  // ...
  const header = 'ðŸ¦« oh, behave!';
  const branch = isLast ? 'â””â”€' : 'â”œâ”€';
  return `   ${branch} ${entry.symbol} ${entry.file}`;
};
```

**relation to wish**: the wish specifies output format:
```
ðŸ¦« wassup?
   â”œâ”€ .behavior/v2026_01_09.hook-adapter/5.1.execution...
   â””â”€ opened in codium
```

this pattern provides the exact tree structure with branch chars (â”œâ”€, â””â”€) and emoji header. can reuse directly with new header text.

---

## 2. footer output pattern

**file**: `src/domain.operations/behavior/render/computeFooterOutput.ts`

**action**: **[EXTEND]**

**quote** [2]:
```typescript
export const computeFooterOutput = (input: {
  wishPathRel: string;
  opener?: string;
}): string => {
  const dim = '\x1b[2m';
  const reset = '\x1b[0m';
  const lines = [`ðŸŒ² go on then,`, `   â”œâ”€ ${input.wishPathRel}`];
  if (input.opener) {
    lines.push(`   â””â”€ ${dim}opened in ${input.opener}${reset}`);
  } else {
    lines.push(`   â””â”€ ${dim}tip: use --open to open the wish automatically${reset}`);
  }
};
```

**relation to wish**: the wish specifies:
- show "opened in codium" if --open used
- show tip about --open if not used
- for repl mode, show status footer below input (e.g., "# blocker.3 >")

the ansi dim/reset pattern and conditional tip logic can be extended for repl status line.

---

## 3. editor open pattern

**file**: `src/infra/shell/openFileWithOpener.ts`

**action**: **[REUSE]**

**quote** [3]:
```typescript
export const openFileWithOpener = (input: {
  opener: string;
  filePath: string;
}): void => {
  const command = `${input.opener} "${input.filePath}"`;
  try {
    execSync(command, { stdio: 'inherit' });
  } catch (error) {
    throw new OpenerUnavailableError(
      `opener '${input.opener}' unavailable or failed`,
    );
  }
};
```

**relation to wish**: the wish specifies:
- `give.feedback --open codium` should open file in codium
- same pattern as init.behavior

this is exactly the same requirement. reuse directly.

---

## 4. findsert pattern

**file**: `src/domain.operations/behavior/init/initBehaviorDir.ts`

**action**: **[REUSE]**

**quote** [4]:
```typescript
export const initBehaviorDir = (input: {
  behaviorDir: string;
  behaviorDirRel: string;
}): { created: string[]; kept: string[] } => {
  // findsert: skip if exists
  if (existsSync(targetPath)) {
    kept.push(templateName);
    continue;
  }
  writeFileSync(targetPath, content);
  created.push(templateName);
};
```

**relation to wish**: the wish specifies idempotent behavior:
- if feedback file exists, say "already exists"
- show tip about --version for new version creation
- file is not overwritten

the findsert pattern (find or insert) that tracks created/kept lists is exactly this. reuse directly.

---

## 5. cli args pattern

**file**: `src/infra/cli/getCliArgs.ts`

**action**: **[REUSE]**

**quote** [5]:
```typescript
const schemaOfArgs = z.object({
  named: z.object({
    behavior: z.string().optional(),
    against: z.string().optional(),
    version: z.coerce.number().optional(),
    template: z.string().optional(),
    force: z.boolean().default(false),
    open: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

**relation to wish**: the wish specifies new cli args:
- `--talk` for repl mode
- `--against execution` for artifact target

the zod schema pattern supports easy extension for new flags. reuse and extend schema.

---

## 6. give.feedback current implementation

**file**: `src/domain.operations/behavior/feedback/giveFeedback.ts`

**action**: **[EXTEND]**

**quote** [6]:
```typescript
export const giveFeedback = (
  input: {
    against: string;
    behavior?: string;
    version?: number;
    template?: string;
    force?: boolean;
  },
  context?: { cwd?: string },
): { feedbackFile: string; artifactFile: string; behaviorDir: string } => {
  // ...
  if (existsSync(feedbackPath)) {
    throw new BadRequestError(
      `feedback file already exists: ${feedbackPath}. use --version to create a new version.`,
    );
  }
```

**relation to wish**: current implementation throws on duplicate. wish specifies:
- findsert semantics (find it, say "already exists", open or start repl)
- new --talk flag for repl mode
- output tree format instead of plain message

needs extension to:
1. change from throw to findsert
2. add --talk mode that starts ink repl
3. return output suitable for tree format

---

## 7. template init pattern

**file**: `src/domain.operations/behavior/feedback/initFeedbackTemplate.ts`

**action**: **[REUSE]**

**quote** [7]:
```typescript
export const initFeedbackTemplate = (input: {
  behaviorDirRel: string;
  behaviorRefName: string;
}): string => {
  const template = readFileSync(templatePath, 'utf-8');
  return template
    .replace(/\$BEHAVIOR_DIR_REL/g, input.behaviorDirRel)
    .replace(/\$BEHAVIOR_REF_NAME/g, input.behaviorRefName);
};
```

**relation to wish**: the wish does not change template behavior. the placeholder substitution pattern is already correct. reuse directly.

---

## implementation notes

### patterns to compose for open mode

```
giveFeedback (extended)
  â†’ findsert pattern (from initBehaviorDir)
  â†’ openFileWithOpener (reuse)
  â†’ computeOutputTree (reuse, new header)
  â†’ computeFooterOutput (extend, --open tip)
```

### new patterns needed for --talk repl mode

| need | source |
|------|--------|
| ink Box/Spacer layout | new (from oss research) |
| ink-multiline-input | new (from oss research) |
| severity toggle state | new |
| file mutation on submit | new |
| change log jsonl | new |
| undo/redo via change log | new |

the open mode can reuse almost all prior patterns. the --talk repl mode requires new ink-based components per the oss research.

---

## citations

[1] src/domain.operations/behavior/init/computeOutputTree.ts
[2] src/domain.operations/behavior/render/computeFooterOutput.ts
[3] src/infra/shell/openFileWithOpener.ts
[4] src/domain.operations/behavior/init/initBehaviorDir.ts
[5] src/infra/cli/getCliArgs.ts (schema pattern from give.feedback.ts cli)
[6] src/domain.operations/behavior/feedback/giveFeedback.ts
[7] src/domain.operations/behavior/feedback/initFeedbackTemplate.ts
