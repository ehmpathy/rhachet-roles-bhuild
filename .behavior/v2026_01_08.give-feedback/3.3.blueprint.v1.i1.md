# blueprint: give.feedback

## overview

implement the `give.feedback` skill to generate feedback files for any behavior artifact.

**inputs**:
- wish: `.behavior/v2026_01_08.give-feedback/0.wish.md`
- criteria: `.behavior/v2026_01_08.give-feedback/2.criteria.blackbox.md`
- patterns: `.behavior/v2026_01_08.give-feedback/3.1.research.patterns._.v1.i1.md`
- distill: `.behavior/v2026_01_08.give-feedback/3.2.distill.domain._.v1.i1.md`

---

## phase.0 = domain.objects

### 0.1 create BehaviorArtifact

**file**: `src/domain.objects/BehaviorArtifact.ts`

```ts
interface BehaviorArtifact {
  path: string;
  name: string;
  version: number | null;
  attempt: number | null;
  filename: string;
}
```

**tests**: `src/domain.objects/BehaviorArtifact.test.ts`
- unit: instantiation with all fields
- unit: unique key is path

### 0.2 create BehaviorFeedback

**file**: `src/domain.objects/BehaviorFeedback.ts`

```ts
interface BehaviorFeedback {
  path: string;
  against: RefByUnique<typeof BehaviorArtifact>;
  version: number;
  filename: string;
}
```

**tests**: `src/domain.objects/BehaviorFeedback.test.ts`
- unit: instantiation with RefByUnique against
- unit: unique key is path

---

## phase.1 = domain.operations (leaf operations)

### 1.1 create computeBehaviorFeedbackName

**file**: `src/domain.operations/behavior/feedback/computeBehaviorFeedbackName.ts`

**contract**:
```ts
export const computeBehaviorFeedbackName = (input: {
  artifactFileName: string;
  feedbackVersion: number;
}): string
```

**mechanism**:
1. append `.[feedback].v${feedbackVersion}.[given].by_human.md` to artifactFileName

**tests**: `src/domain.operations/behavior/feedback/computeBehaviorFeedbackName.test.ts`

| case | artifactFileName | feedbackVersion | expected |
|------|------------------|-----------------|----------|
| execution with version/attempt | `5.1.execution.phase0.v1.i1.md` | 1 | `5.1.execution.phase0.v1.i1.md.[feedback].v1.[given].by_human.md` |
| criteria without version | `2.criteria.blackbox.md` | 1 | `2.criteria.blackbox.md.[feedback].v1.[given].by_human.md` |
| wish without version | `0.wish.md` | 1 | `0.wish.md.[feedback].v1.[given].by_human.md` |
| feedback v2 | `0.wish.md` | 2 | `0.wish.md.[feedback].v2.[given].by_human.md` |

### 1.2 create getLatestArtifactByName

**file**: `src/domain.operations/behavior/feedback/getLatestArtifactByName.ts`

**contract**:
```ts
export const getLatestArtifactByName = (
  input: { behaviorDir: string; artifactName: string },
  context?: { cwd?: string },
): BehaviorArtifact | null
```

**mechanism**:
1. glob for `*.<artifactName>*.md` in behaviorDir
2. exclude files with `[feedback]` in name
3. exclude `.src` files (only `.md`)
4. parse version (vX) and attempt (iX) from each filename
5. sort by version desc, then attempt desc
6. return first (latest) or null if none

**tests**: `src/domain.operations/behavior/feedback/getLatestArtifactByName.test.ts`

| case | files in dir | artifactName | expected |
|------|--------------|--------------|----------|
| single execution | `5.1.execution.v1.i1.md` | `execution` | returns that file |
| multiple versions | `5.1.execution.v1.i1.md`, `5.1.execution.v2.i1.md` | `execution` | returns v2 |
| multiple attempts | `5.1.execution.v1.i1.md`, `5.1.execution.v1.i2.md` | `execution` | returns i2 |
| excludes feedback | `5.1.execution.v1.i1.md`, `5.1.execution.v1.i1.[feedback].v1.[given].by_human.md` | `execution` | returns non-feedback |
| criteria.blackbox vs blueprint | `2.criteria.blackbox.md`, `2.criteria.blueprint.md` | `criteria.blackbox` | returns blackbox only |
| no version/attempt | `0.wish.md` | `wish` | returns wish |
| no match | `0.wish.md` | `execution` | returns null |

### 1.3 create initFeedbackTemplate

**file**: `src/domain.operations/behavior/feedback/initFeedbackTemplate.ts`

**contract**:
```ts
export const initFeedbackTemplate = (
  input: {
    templatePath: string;
    targetPath: string;
    artifactFileName: string;
    behaviorDirRel: string;
  },
  context?: { cwd?: string },
): void
```

**mechanism**:
1. read template content from templatePath
2. replace `$BEHAVIOR_REF_NAME` with artifactFileName
3. replace `$BEHAVIOR_DIR_REL` with behaviorDirRel
4. write to targetPath

**tests**: `src/domain.operations/behavior/feedback/initFeedbackTemplate.test.ts`

| case | template content | artifactFileName | expected in output |
|------|------------------|------------------|-------------------|
| replaces $BEHAVIOR_REF_NAME | `target: $BEHAVIOR_REF_NAME` | `5.1.execution.v1.i1.md` | `target: 5.1.execution.v1.i1.md` |
| replaces $BEHAVIOR_DIR_REL | `path: $BEHAVIOR_DIR_REL/file.md` | - | `path: .behavior/v.../file.md` |
| replaces both | `$BEHAVIOR_DIR_REL/$BEHAVIOR_REF_NAME` | `0.wish.md` | `.behavior/v.../0.wish.md` |

---

## phase.2 = domain.operations (compose operations)

### 2.1 create getBehaviorDirForFeedback

**file**: `src/domain.operations/behavior/feedback/getBehaviorDirForFeedback.ts`

**contract**:
```ts
export const getBehaviorDirForFeedback = (
  input: { behavior?: string; force?: boolean },
  context?: { cwd?: string },
): { behaviorDir: string; resolvedVia: 'bind' | 'flag' }
```

**mechanism**:
1. get current branch via `getCurrentBranch`
2. lookup bind via `getBranchBehaviorBind`
3. if `--behavior` provided:
   - resolve via `getBehaviorDir`
   - if bound && resolved differs && !force: throw `BadRequestError`
   - if bound && resolved matches: return `{ behaviorDir: bound, resolvedVia: 'bind' }`
   - if !bound || force: return `{ behaviorDir: resolved, resolvedVia: 'flag' }`
4. if no `--behavior`:
   - if bound: return `{ behaviorDir: bound, resolvedVia: 'bind' }`
   - if !bound: throw `BadRequestError` (--behavior required)

**tests**: `src/domain.operations/behavior/feedback/getBehaviorDirForFeedback.test.ts`

| case | bound | --behavior | --force | expected |
|------|-------|------------|---------|----------|
| bound, no flag | `give-feedback` | - | - | returns bind |
| bound, flag matches | `give-feedback` | `give-feedback` | - | returns bind |
| bound, flag differs, no force | `give-feedback` | `other` | false | throws |
| bound, flag differs, force | `give-feedback` | `other` | true | returns flag |
| not bound, flag provided | - | `give-feedback` | - | returns flag |
| not bound, no flag | - | - | - | throws |
| flag not found | - | `nonexistent` | - | throws (from getBehaviorDir) |
| flag ambiguous | - | `criteria` | - | throws (from getBehaviorDir) |

### 2.2 create giveFeedback

**file**: `src/domain.operations/behavior/feedback/giveFeedback.ts`

**contract**:
```ts
export const giveFeedback = (
  input: {
    against: string;
    behavior?: string;
    version?: number;
    template?: string;
    force?: boolean;
  },
  context?: { cwd?: string },
): { feedbackFile: string; artifactFile: string; behaviorDir: string }
```

**mechanism**:
1. resolve behavior directory via `getBehaviorDirForFeedback`
2. find latest artifact via `getLatestArtifactByName`
   - if null: throw `BadRequestError` (no artifact found)
3. compute feedback filename via `computeBehaviorFeedbackName`
4. check if feedback file already exists
   - if exists: throw `BadRequestError` (feedback already exists)
5. resolve template path (default: `${behaviorDir}/.ref.[feedback].v1.[given].by_human.md`)
   - if not exists: throw `BadRequestError` (template not found)
6. init feedback file via `initFeedbackTemplate`
7. return result

**tests**: `src/domain.operations/behavior/feedback/giveFeedback.test.ts`

| case | expected |
|------|----------|
| creates feedback for execution artifact | feedback file created with correct name |
| creates feedback for criteria.blackbox | feedback file created |
| creates feedback for wish | feedback file created |
| respects --version flag | feedback filename uses v2 |
| uses custom --template | reads from custom template |
| fails if artifact not found | throws with pattern shown |
| fails if feedback exists | throws with "already exists" |
| fails if template not found | throws with "template not found" |

---

## phase.3 = contract/cli

### 3.1 create give.feedback.ts CLI entry point

**file**: `src/contract/cli/give.feedback.ts`

**contract**:
```ts
export const giveFeedback = (): void
```

**schema**:
```ts
const schemaOfArgs = z.object({
  named: z.object({
    against: z.string(),
    behavior: z.string().optional(),
    version: z.coerce.number().optional(),
    template: z.string().optional(),
    force: z.boolean().optional(),
    // rhachet passthrough
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

**mechanism**:
1. parse args via `getCliArgs({ schema: schemaOfArgs })`
2. call `giveFeedback` operation
3. log result to stdout

### 3.2 export from index.ts

**file**: `src/index.ts`

add `giveFeedback` to `cli` export object:
```ts
import { giveFeedback } from './contract/cli/give.feedback';

export const cli = {
  // ... prior exports
  giveFeedback,
};
```

---

## phase.4 = domain.roles skill

### 4.1 create give.feedback.sh

**file**: `src/domain.roles/behaver/skills/give.feedback.sh`

```bash
#!/usr/bin/env bash
######################################################################
# .what = generate a feedback file for a behavior artifact
#
# .why  = enables structured feedback on any behavior artifact
#         - creates feedback files linked to target artifacts
#         - supports versioned feedback (v1, v2, etc.)
#         - replaces template placeholders with artifact references
#
# .when = use this skill when you need to:
#         - provide feedback on an execution artifact
#         - review criteria, blueprint, or research artifacts
#         - create structured response templates for human review
#
# .how  = thin dispatcher to TypeScript implementation
#
# .args:
#   --against <name>    (required) artifact name to target
#                       e.g., execution, criteria.blackbox, wish, blueprint
#   --behavior <name>   (optional) behavior directory name
#                       required if branch is not bound to a behavior
#   --version <N>       (optional) feedback version number (default: 1)
#   --template <path>   (optional) custom template file path
#   --force             (optional) override bind mismatch
#
# .examples:
#   # generate feedback for latest execution artifact (branch must be bound)
#   npx rhachet run --skill give.feedback --against execution
#
#   # generate feedback for criteria.blackbox with explicit behavior
#   npx rhachet run --skill give.feedback --against criteria.blackbox --behavior give-feedback
#
#   # generate v2 feedback on same artifact
#   npx rhachet run --skill give.feedback --against execution --version 2
#
#   # use custom template
#   npx rhachet run --skill give.feedback --against wish --template ./my-template.md
#
#   # override bind mismatch with --force
#   npx rhachet run --skill give.feedback --against blueprint --behavior other-feature --force
#
# .output:
#   - creates: ${behaviorDir}/${artifactFileName}.[feedback].v${version}.[given].by_human.md
#   - logs: feedback file path and target artifact to stdout
#
# .errors:
#   - no artifact found: shows glob pattern used
#   - feedback exists: prevents overwrite, suggests --version
#   - template not found: indicates template path needed
#   - bind mismatch: suggests --force to override
######################################################################

set -euo pipefail

exec npx tsx -e "import('rhachet-roles-bhuild').then(m => m.cli.giveFeedback())" -- "$@"
```

---

## phase.5 = integration tests

integration tests call domain operations directly without rhachet dispatch.

### 5.1 giveFeedback operation integration test

**file**: `src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts`

**pattern**: direct operation call with temp git repo (follows `applyPlan.integration.test.ts`)

**note**: uses shared `genBehaviorFixture` from `blackbox/.test/infra/` (extended in phase.6.1)

```ts
import fs from 'fs';
import path from 'path';
import { given, then, when, useBeforeAll } from 'test-fns';

import { genTestGitRepo } from '../../../../../blackbox/.test/infra/genTestGitRepo';
import { genBehaviorFixture } from '../../../../../blackbox/.test/infra/genBehaviorFixture';
import { giveFeedback } from './giveFeedback';

describe('giveFeedback.integration', () => {
  given('[case1] behavior with execution artifact', () => {
    let testRepo: { repoDir: string; cleanup: () => void };
    let behaviorDir: string;

    beforeAll(() => {
      testRepo = genTestGitRepo({
        prefix: 'giveFeedback-int-',
        branchName: 'feature/test',
      });
      const result = genBehaviorFixture({
        repoDir: testRepo.repoDir,
        behaviorName: 'test-feature',
        withFeedbackTemplate: true,
        withArtifacts: ['5.1.execution.v1.i1.md', '2.criteria.blackbox.md'],
      });
      behaviorDir = result.behaviorDir;
    });

    afterAll(() => {
      testRepo.cleanup();
    });

    when('[t0] giveFeedback invoked for execution', () => {
      then('feedback file is created', () => {
        const result = giveFeedback(
          { against: 'execution', behavior: 'test-feature' },
          { cwd: testRepo.repoDir },
        );
        expect(fs.existsSync(result.feedbackFile)).toBe(true);
      });

      then('$BEHAVIOR_REF_NAME is replaced in content', () => {
        const feedbackPath = path.join(
          behaviorDir,
          '5.1.execution.v1.i1.md.[feedback].v1.[given].by_human.md',
        );
        const content = fs.readFileSync(feedbackPath, 'utf-8');
        expect(content).toContain('5.1.execution.v1.i1.md');
        expect(content).not.toContain('$BEHAVIOR_REF_NAME');
      });

      then('$BEHAVIOR_DIR_REL is replaced in content', () => {
        const feedbackPath = path.join(
          behaviorDir,
          '5.1.execution.v1.i1.md.[feedback].v1.[given].by_human.md',
        );
        const content = fs.readFileSync(feedbackPath, 'utf-8');
        expect(content).toContain('.behavior/v2025_01_01.test-feature');
        expect(content).not.toContain('$BEHAVIOR_DIR_REL');
      });
    });

    when('[t1] giveFeedback invoked twice with same version', () => {
      then('second invocation throws "already exists"', () => {
        expect(() =>
          giveFeedback(
            { against: 'execution', behavior: 'test-feature' },
            { cwd: testRepo.repoDir },
          ),
        ).toThrow(/already exists/);
      });
    });

    when('[t2] giveFeedback invoked with --version 2', () => {
      then('feedback v2 file is created', () => {
        giveFeedback(
          { against: 'execution', behavior: 'test-feature', version: 2 },
          { cwd: testRepo.repoDir },
        );
        const v2Path = path.join(
          behaviorDir,
          '5.1.execution.v1.i1.md.[feedback].v2.[given].by_human.md',
        );
        expect(fs.existsSync(v2Path)).toBe(true);
      });
    });
  });

  given('[case2] behavior with multiple artifact versions', () => {
    let testRepo: { repoDir: string; cleanup: () => void };

    beforeAll(() => {
      testRepo = genTestGitRepo({
        prefix: 'giveFeedback-multi-',
        branchName: 'feature/multi',
      });
      genBehaviorFixture({
        repoDir: testRepo.repoDir,
        behaviorName: 'multi-version',
        withFeedbackTemplate: true,
        withArtifacts: [
          '5.1.execution.v1.i1.md',
          '5.1.execution.v1.i2.md',
          '5.1.execution.v2.i1.md',
        ],
      });
    });

    afterAll(() => {
      testRepo.cleanup();
    });

    when('[t0] giveFeedback invoked', () => {
      const result = useBeforeAll(async () =>
        giveFeedback(
          { against: 'execution', behavior: 'multi-version' },
          { cwd: testRepo.repoDir },
        ),
      );

      then('targets latest version (v2.i1)', () => {
        expect(result.artifactFile).toContain('v2.i1.md');
      });

      then('feedback filename references v2.i1', () => {
        expect(result.feedbackFile).toContain('v2.i1.md.[feedback]');
      });
    });
  });

  given('[case3] behavior without template', () => {
    let testRepo: { repoDir: string; cleanup: () => void };

    beforeAll(() => {
      testRepo = genTestGitRepo({
        prefix: 'giveFeedback-notemplate-',
        branchName: 'feature/notemplate',
      });
      const behaviorDir = path.join(
        testRepo.repoDir,
        '.behavior',
        'v2025_01_01.no-template',
      );
      fs.mkdirSync(behaviorDir, { recursive: true });
      fs.writeFileSync(path.join(behaviorDir, '0.wish.md'), 'wish = test');
      // no template file created
    });

    afterAll(() => {
      testRepo.cleanup();
    });

    when('[t0] giveFeedback invoked', () => {
      then('throws "template not found"', () => {
        expect(() =>
          giveFeedback(
            { against: 'wish', behavior: 'no-template' },
            { cwd: testRepo.repoDir },
          ),
        ).toThrow(/template not found/i);
      });
    });
  });
});
```

---

## phase.6 = acceptance tests

acceptance tests invoke skills via `npx rhachet run` (consumer pattern).

### 6.1 symmetric skill invocation helpers

**refactor**: `blackbox/.test/infra/runRhachetSkill.ts` → `runSkillViaRhachetRun.ts`

rename `runRhachetSkill` to `runSkillViaRhachetRun` for symmetry:
- function name: `runRhachetSkill` → `runSkillViaRhachetRun`
- type name: `SkillResult` → `SkillRunResult`
- update filename and exports

**file**: `blackbox/.test/infra/runSkillViaDirectExec.ts` (new)

generic helper for direct bash spawn of shell skills:

```ts
import { execSync } from 'child_process';

export interface SkillExecResult {
  stdout: string;
  exitCode: number;
}

/**
 * .what = runs a shell skill command via direct bash spawn
 * .why  = tests the shell command directly without rhachet dispatch
 */
export const runSkillViaDirectExec = (input: {
  commandPath: string;
  args: string;
  targetDir: string;
}): SkillExecResult => {
  try {
    const stdout = execSync(
      `bash "${input.commandPath}" ${input.args}`,
      {
        cwd: input.targetDir,
        env: { ...process.env, PATH: process.env.PATH },
        stdio: ['pipe', 'pipe', 'pipe'],
      },
    ).toString('utf-8');
    return { stdout: stdout.trim(), exitCode: 0 };
  } catch (error: unknown) {
    const execError = error as {
      stdout?: Buffer | string;
      stderr?: Buffer | string;
      status?: number;
    };
    const stdout = (execError.stdout ?? '').toString().trim();
    const stderr = (execError.stderr ?? '').toString().trim();
    return {
      stdout: [stdout, stderr].filter(Boolean).join('\n'),
      exitCode: execError.status ?? 1,
    };
  }
};
```

**file**: `blackbox/.test/infra/index.ts`

add export:
```ts
export { runSkillViaDirectExec, type SkillExecResult } from './runSkillViaDirectExec';
```

### 6.2 extend genBehaviorFixture

**file**: `blackbox/.test/infra/genBehaviorFixture.ts`

add feedback template support:

```ts
export const genBehaviorFixture = (input: {
  repoDir: string;
  behaviorName: string;
  withCriteria?: boolean;
  withDecomposed?: boolean;
  withFeedbackTemplate?: boolean;  // NEW
  withArtifacts?: string[];        // NEW: list of artifact filenames
  datePrefix?: string;
}): { behaviorDir: string } => {
  // ... prior code ...

  // optionally create feedback template
  if (input.withFeedbackTemplate) {
    fs.writeFileSync(
      path.join(behaviorDir, '.ref.[feedback].v1.[given].by_human.md'),
      'feedback for $BEHAVIOR_REF_NAME in $BEHAVIOR_DIR_REL',
    );
  }

  // optionally create specified artifacts
  for (const artifact of input.withArtifacts ?? []) {
    fs.writeFileSync(path.join(behaviorDir, artifact), `# ${artifact}`);
  }

  return { behaviorDir };
};
```

### 6.3 blackbox acceptance tests

**file**: `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts`

**pattern**: follows `skill.init.behavior.acceptance.test.ts` and `skill.bind.behavior.acceptance.test.ts`

```ts
import fs from 'fs';
import path from 'path';
import { given, then, useBeforeAll, when } from 'test-fns';

import {
  genConsumerRepo,
  genBehaviorFixture,
  genTestGitRepo,
  runSkillViaRhachetRun,
  runSkillViaDirectExec,
  type ConsumerRepo,
} from '../.test/infra';

const COMMAND_PATH = path.join(
  __dirname,
  '../../src/domain.roles/behaver/skills/give.feedback.sh',
);

describe('give.feedback', () => {
  // ========================================
  // consumer invocation tests (via rhachet)
  // ========================================

  given('[case1] consumer: behavior with execution artifact', () => {
    let consumer: ConsumerRepo;

    beforeAll(() => {
      consumer = genConsumerRepo({ prefix: 'give-feedback-test-' });
      genBehaviorFixture({
        repoDir: consumer.repoDir,
        behaviorName: 'test-feature',
        withFeedbackTemplate: true,
        withArtifacts: ['5.1.execution.v1.i1.md'],
      });
    });

    afterAll(() => {
      consumer.cleanup();
    });

    when('[t0] --against execution is invoked', () => {
      then('exits with code 0', () => {
        execSync('git checkout -b feedback-test-1', { cwd: consumer.repoDir });

        const result = runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against execution --behavior test-feature',
          repoDir: consumer.repoDir,
        });

        expect(result.exitCode).toBe(0);
      });

      then('creates feedback file', () => {
        execSync('git checkout -b feedback-test-2', { cwd: consumer.repoDir });

        runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against execution --behavior test-feature',
          repoDir: consumer.repoDir,
        });

        const behaviorDir = path.join(
          consumer.repoDir,
          '.behavior',
          'v2025_01_01.test-feature',
        );
        const files = fs.readdirSync(behaviorDir);
        const hasFeedback = files.some((f) => f.includes('[feedback]'));
        expect(hasFeedback).toBe(true);
      });

      then('output confirms feedback created', () => {
        execSync('git checkout -b feedback-test-3', { cwd: consumer.repoDir });

        const result = runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against execution --behavior test-feature',
          repoDir: consumer.repoDir,
        });

        expect(result.output).toContain('feedback');
        expect(result.output).toContain('execution');
      });
    });

    when('[t1] --version 2 is invoked after v1 exists', () => {
      then('creates v2 feedback file', () => {
        execSync('git checkout -b feedback-v2-test', { cwd: consumer.repoDir });

        runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against execution --behavior test-feature --version 1',
          repoDir: consumer.repoDir,
        });

        runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against execution --behavior test-feature --version 2',
          repoDir: consumer.repoDir,
        });

        const behaviorDir = path.join(
          consumer.repoDir,
          '.behavior',
          'v2025_01_01.test-feature',
        );
        const files = fs.readdirSync(behaviorDir);
        const hasV1 = files.some((f) => f.includes('[feedback].v1.'));
        const hasV2 = files.some((f) => f.includes('[feedback].v2.'));
        expect(hasV1).toBe(true);
        expect(hasV2).toBe(true);
      });
    });
  });

  given('[case2] consumer: artifact not found', () => {
    let consumer: ConsumerRepo;

    beforeAll(() => {
      consumer = genConsumerRepo({ prefix: 'give-feedback-notfound-' });
      genBehaviorFixture({
        repoDir: consumer.repoDir,
        behaviorName: 'empty-feature',
        withFeedbackTemplate: true,
        // no artifacts
      });
    });

    afterAll(() => {
      consumer.cleanup();
    });

    when('[t0] --against nonexistent invoked', () => {
      const result = useBeforeAll(async () =>
        runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against nonexistent --behavior empty-feature',
          repoDir: consumer.repoDir,
        }),
      );

      then('exits with non-zero code', () => {
        expect(result.exitCode).not.toBe(0);
      });

      then('output mentions no artifact found', () => {
        expect(result.output).toContain('no artifact found');
      });
    });
  });

  given('[case3] consumer: feedback already exists', () => {
    let consumer: ConsumerRepo;

    beforeAll(() => {
      consumer = genConsumerRepo({ prefix: 'give-feedback-exists-' });
      genBehaviorFixture({
        repoDir: consumer.repoDir,
        behaviorName: 'exists-feature',
        withFeedbackTemplate: true,
        withArtifacts: ['5.1.execution.v1.i1.md'],
      });
      execSync('git checkout -b exists-test', { cwd: consumer.repoDir });
      runSkillViaRhachetRun({
        repo: 'bhuild',
        skill: 'give.feedback',
        args: '--against execution --behavior exists-feature',
        repoDir: consumer.repoDir,
      });
    });

    afterAll(() => {
      consumer.cleanup();
    });

    when('[t0] same feedback invoked again', () => {
      const result = useBeforeAll(async () =>
        runSkillViaRhachetRun({
          repo: 'bhuild',
          skill: 'give.feedback',
          args: '--against execution --behavior exists-feature',
          repoDir: consumer.repoDir,
        }),
      );

      then('exits with non-zero code', () => {
        expect(result.exitCode).not.toBe(0);
      });

      then('output mentions already exists', () => {
        expect(result.output).toContain('already exists');
      });
    });
  });

  // ========================================
  // direct invocation tests (via bash spawn)
  // ========================================

  given('[case4] direct: creates feedback with placeholders replaced', () => {
    when('[t0] invoked with --against execution', () => {
      let testRepo: { repoDir: string; cleanup: () => void };
      let behaviorDir: string;

      beforeAll(() => {
        testRepo = genTestGitRepo({
          prefix: 'give-feedback-test-',
          branchName: 'feature/direct-test',
        });
        const fixture = genBehaviorFixture({
          repoDir: testRepo.repoDir,
          behaviorName: 'direct-feature',
          withFeedbackTemplate: true,
          withArtifacts: ['5.1.execution.v1.i1.md'],
        });
        behaviorDir = fixture.behaviorDir;
      });

      afterAll(() => {
        testRepo.cleanup();
      });

      then('feedback file contains artifact filename', () => {
        runSkillViaDirectExec({
          commandPath: COMMAND_PATH,
          args: '--against execution --behavior direct-feature',
          targetDir: testRepo.repoDir,
        });

        const feedbackFiles = fs.readdirSync(behaviorDir).filter(
          (f) => f.includes('[feedback]'),
        );
        expect(feedbackFiles.length).toBe(1);

        const content = fs.readFileSync(
          path.join(behaviorDir, feedbackFiles[0]!),
          'utf-8',
        );
        expect(content).toContain('5.1.execution.v1.i1.md');
        expect(content).not.toContain('$BEHAVIOR_REF_NAME');
      });

      then('feedback file contains behavior dir path', () => {
        const feedbackFiles = fs.readdirSync(behaviorDir).filter(
          (f) => f.includes('[feedback]'),
        );
        const content = fs.readFileSync(
          path.join(behaviorDir, feedbackFiles[0]!),
          'utf-8',
        );
        expect(content).toContain('.behavior/');
        expect(content).not.toContain('$BEHAVIOR_DIR_REL');
      });
    });
  });

  given('[case5] direct: selects latest artifact version', () => {
    when('[t0] multiple versions present', () => {
      let testRepo: { repoDir: string; cleanup: () => void };
      let behaviorDir: string;

      beforeAll(() => {
        testRepo = genTestGitRepo({
          prefix: 'give-feedback-test-',
          branchName: 'feature/multi-version',
        });
        const fixture = genBehaviorFixture({
          repoDir: testRepo.repoDir,
          behaviorName: 'multi-feature',
          withFeedbackTemplate: true,
          withArtifacts: [
            '5.1.execution.v1.i1.md',
            '5.1.execution.v1.i2.md',
            '5.1.execution.v2.i1.md',
          ],
        });
        behaviorDir = fixture.behaviorDir;
      });

      afterAll(() => {
        testRepo.cleanup();
      });

      then('targets v2.i1 (latest)', () => {
        const result = runSkillViaDirectExec({
          commandPath: COMMAND_PATH,
          args: '--against execution --behavior multi-feature',
          targetDir: testRepo.repoDir,
        });

        expect(result.exitCode).toBe(0);
        expect(result.stdout).toContain('v2.i1');

        const feedbackFiles = fs.readdirSync(behaviorDir).filter(
          (f) => f.includes('[feedback]'),
        );
        expect(feedbackFiles[0]).toContain('v2.i1.md.[feedback]');
      });
    });
  });

  given('[case6] direct: template not found', () => {
    when('[t0] behavior has no template', () => {
      let testRepo: { repoDir: string; cleanup: () => void };

      beforeAll(() => {
        const { repoDir, cleanup } = genTestGitRepo({
          prefix: 'give-feedback-notemplate-',
          branchName: 'feature/no-template',
        });
        testRepo = { repoDir, cleanup };

        // create behavior WITHOUT template
        const behaviorDir = path.join(
          repoDir,
          '.behavior',
          'v2025_01_01.no-template',
        );
        fs.mkdirSync(behaviorDir, { recursive: true });
        fs.writeFileSync(path.join(behaviorDir, '0.wish.md'), 'wish = test');
      });

      afterAll(() => {
        testRepo.cleanup();
      });

      then('fails with helpful error', () => {
        const result = runSkillViaDirectExec({
          commandPath: COMMAND_PATH,
          args: '--against wish --behavior no-template',
          targetDir: testRepo.repoDir,
        });

        expect(result.exitCode).toBe(1);
        expect(result.stdout).toContain('template not found');
      });
    });
  });

  given('[case7] direct: artifact name pattern match', () => {
    let testRepo: { repoDir: string; cleanup: () => void };
    let behaviorDir: string;

    beforeAll(() => {
      testRepo = genTestGitRepo({
        prefix: 'give-feedback-test-',
        branchName: 'feature/pattern-test',
      });
      const fixture = genBehaviorFixture({
        repoDir: testRepo.repoDir,
        behaviorName: 'pattern-feature',
        withFeedbackTemplate: true,
        withArtifacts: [
          '2.criteria.blackbox.md',
          '2.criteria.blueprint.md',
          '3.1.research.domain._.v1.md',
          '3.1.research.claims._.v1.md',
        ],
      });
      behaviorDir = fixture.behaviorDir;
    });

    afterAll(() => {
      testRepo.cleanup();
    });

    when('[t0] --against criteria.blackbox', () => {
      then('matches only blackbox, not blueprint', () => {
        const result = runSkillViaDirectExec({
          commandPath: COMMAND_PATH,
          args: '--against criteria.blackbox --behavior pattern-feature',
          targetDir: testRepo.repoDir,
        });

        expect(result.exitCode).toBe(0);
        expect(result.stdout).toContain('criteria.blackbox');
        expect(result.stdout).not.toContain('blueprint');
      });
    });

    when('[t1] --against research.domain', () => {
      then('matches only domain, not claims', () => {
        const result = runSkillViaDirectExec({
          commandPath: COMMAND_PATH,
          args: '--against research.domain --behavior pattern-feature',
          targetDir: testRepo.repoDir,
        });

        expect(result.exitCode).toBe(0);
        expect(result.stdout).toContain('research.domain');
        expect(result.stdout).not.toContain('claims');
      });
    });
  });
});
```

### 6.4 acceptance test criteria coverage

| criteria section | test case | invocation |
|------------------|-----------|------------|
| usecase.1: not bound, flag | case1, case4-7 | consumer + direct |
| usecase.2: feedback filename | case4, case5 | direct |
| usecase.2: placeholder replace | case4 | direct |
| usecase.2: --version flag | case1 [t1] | consumer |
| usecase.2: latest artifact | case5 | direct |
| usecase.3: pattern match | case7 | direct |
| usecase.4: template not found | case6 | direct |
| usecase.5: artifact not found | case2 | consumer |
| usecase.5: feedback exists | case3 | consumer |
| usecase.6: --version 2 after v1 | case1 [t1] | consumer |

---

## file manifest

| phase | file | type |
|-------|------|------|
| 0.1 | `src/domain.objects/BehaviorArtifact.ts` | domain.object |
| 0.1 | `src/domain.objects/BehaviorArtifact.test.ts` | unit test |
| 0.2 | `src/domain.objects/BehaviorFeedback.ts` | domain.object |
| 0.2 | `src/domain.objects/BehaviorFeedback.test.ts` | unit test |
| 1.1 | `src/domain.operations/behavior/feedback/computeBehaviorFeedbackName.ts` | operation |
| 1.1 | `src/domain.operations/behavior/feedback/computeBehaviorFeedbackName.test.ts` | unit test |
| 1.2 | `src/domain.operations/behavior/feedback/getLatestArtifactByName.ts` | operation |
| 1.2 | `src/domain.operations/behavior/feedback/getLatestArtifactByName.test.ts` | unit test |
| 1.3 | `src/domain.operations/behavior/feedback/initFeedbackTemplate.ts` | operation |
| 1.3 | `src/domain.operations/behavior/feedback/initFeedbackTemplate.test.ts` | unit test |
| 2.1 | `src/domain.operations/behavior/feedback/getBehaviorDirForFeedback.ts` | operation |
| 2.1 | `src/domain.operations/behavior/feedback/getBehaviorDirForFeedback.test.ts` | unit test |
| 2.2 | `src/domain.operations/behavior/feedback/giveFeedback.ts` | operation |
| 2.2 | `src/domain.operations/behavior/feedback/giveFeedback.test.ts` | unit test |
| 3.1 | `src/contract/cli/give.feedback.ts` | cli |
| 3.2 | `src/index.ts` | export (modify) |
| 4.1 | `src/domain.roles/behaver/skills/give.feedback.sh` | skill |
| 5.1 | `src/domain.operations/behavior/feedback/giveFeedback.integration.test.ts` | integration test |
| 6.1 | `blackbox/.test/infra/runRhachetSkill.ts` → `runSkillViaRhachetRun.ts` | test infra (rename) |
| 6.1 | `blackbox/.test/infra/runSkillViaDirectExec.ts` | test infra (new) |
| 6.1 | `blackbox/.test/infra/index.ts` | test infra (modify) |
| 6.2 | `blackbox/.test/infra/genBehaviorFixture.ts` | test infra (modify) |
| 6.3 | `blackbox/role=behaver/skill.give.feedback.acceptance.test.ts` | acceptance test |

---

## dependencies

**external** (already in repo):
- `zod` - arg schema validation
- `domain-objects` - DomainLiteral base
- `helpful-errors` - BadRequestError
- `test-fns` - given/when/then test helpers

**internal** (reuse):
- `getBranchBehaviorBind` - bind lookup
- `getBehaviorDir` - name resolution
- `getCurrentBranch` - git branch
- `getCliArgs` - CLI arg parse

---

## execution order

```
phase.0 → phase.1 → phase.2 → phase.3 → phase.4 → phase.5 → phase.6
   ↓         ↓         ↓         ↓         ↓         ↓         ↓
 objects    leaf     compose    cli      skill    integ     acpt
            ops       ops                         tests    tests
```

each phase must pass all tests before proceed to next.
