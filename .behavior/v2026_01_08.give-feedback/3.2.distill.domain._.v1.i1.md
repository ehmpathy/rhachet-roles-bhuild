# distill: domain model for give.feedback

## usecases

### usecase.1 = generate feedback file for a behavior artifact

```ts
/**
 * .what = generate a feedback file for a target behavior artifact
 * .why  = enables humans to provide structured feedback on any behavior artifact
 */
const result = await giveFeedback(
  {
    against: 'execution',           // artifact name to target
    behavior: 'give-feedback',      // optional if branch is bound
    version: 1,                     // feedback version (default: 1)
    template: undefined,            // optional custom template path
    force: false,                   // override bind mismatch
  },
  context,
);

// result
{
  feedbackFile: '.behavior/v2026_01_08.give-feedback/5.1.execution.phase0_to_phaseN.v1.i1.[feedback].v1.[given].by_human.md',
  artifactFile: '5.1.execution.phase0_to_phaseN.v1.i1.md',
  behaviorDir: '.behavior/v2026_01_08.give-feedback',
}
```

---

## domain.objects

### BehaviorArtifact

represents a file within a behavior directory that can receive feedback.

```ts
/**
 * .what = a behavior artifact that can be targeted for feedback
 * .why  = provides identity and version info for artifact resolution
 */
interface BehaviorArtifact {
  /** full path to the artifact file */
  path: string;

  /** artifact name extracted from filename (e.g., 'execution', 'criteria.blackbox') */
  name: string;

  /** version number if present in filename (vX), null otherwise */
  version: number | null;

  /** attempt number if present in filename (iX), null otherwise */
  attempt: number | null;

  /** the base filename without path */
  filename: string;
}

class BehaviorArtifact extends DomainLiteral<BehaviorArtifact> implements BehaviorArtifact {
  public static unique = ['path'] as const;
}
```

### FeedbackFile

represents a feedback artifact generated against a target behavior artifact.

```ts
/**
 * .what = a feedback artifact linked to a target behavior artifact
 * .why  = tracks the relationship between feedback and its target
 */
interface FeedbackFile {
  /** full path to the feedback file */
  path: string;

  /** reference to the artifact this feedback targets */
  against: RefByUnique<typeof BehaviorArtifact>;

  /** feedback version (v1, v2, etc.) */
  version: number;

  /** the base filename */
  filename: string;
}

class FeedbackFile extends DomainLiteral<FeedbackFile> implements FeedbackFile {
  public static unique = ['path'] as const;
}
```

---

## domain.operations

### getLatestArtifactByName

[EXTEND from getLatestBlueprintByBehavior]

```ts
/**
 * .what = resolve the latest artifact by name from a behavior directory
 * .why  = enables feedback to target the most recent version of any artifact
 *
 * .note = version precedence:
 *         - v3.i2 > v2.i3 (version wins)
 *         - v2.i3 > v2.i1 (latest attempt within version)
 *         - files with [feedback] in name are excluded
 */
export const getLatestArtifactByName = (
  input: {
    behaviorDir: string;
    artifactName: string;  // e.g., 'execution', 'criteria.blackbox', 'wish'
  },
  context?: { cwd?: string },
): BehaviorArtifact | null => {
  // glob pattern: *.<artifactName>*(.vX)?(.iX)?.md
  // exclude: files with [feedback] in name
  // sort by version desc, then attempt desc
  // return latest or null if none found
};
```

### getBehaviorDirForFeedback

[COMPOSE from getBranchBehaviorBind + getBehaviorDir]

```ts
/**
 * .what = resolve behavior directory for feedback generation
 * .why  = handles bind lookup, --behavior flag, and --force override logic
 */
export const getBehaviorDirForFeedback = (
  input: {
    behavior?: string;   // --behavior flag value
    force?: boolean;     // --force flag
  },
  context?: { cwd?: string },
): { behaviorDir: string; resolvedVia: 'bind' | 'flag' } => {
  // 1. get current branch
  // 2. lookup bind via getBranchBehaviorBind
  // 3. if --behavior provided:
  //    - resolve via getBehaviorDir
  //    - if bound && differs && !force: throw BadRequestError
  //    - if bound && matches: return bind (no force needed)
  //    - if !bound || force: return resolved
  // 4. if no --behavior:
  //    - if bound: return bind
  //    - if !bound: throw BadRequestError (--behavior required)
};
```

### initFeedbackTemplate

[EXTEND from initBehaviorDir template logic]

```ts
/**
 * .what = instantiate a feedback file from a template
 * .why  = creates the feedback file with placeholders replaced
 */
export const initFeedbackTemplate = (
  input: {
    templatePath: string;
    targetPath: string;
    artifactFileName: string;
    behaviorDirRel: string;
  },
  context?: { cwd?: string },
): void => {
  // 1. read template content
  // 2. replace $BEHAVIOR_REF_NAME with artifactFileName
  // 3. replace $BEHAVIOR_DIR_REL with behaviorDirRel
  // 4. write to targetPath
};
```

### computeFeedbackFileName

[NEW - pure computation]

```ts
/**
 * .what = compute the feedback filename for a target artifact
 * .why  = centralizes the filename convention logic
 */
export const computeFeedbackFileName = (
  input: {
    artifactFileName: string;  // e.g., '5.1.execution.phase0_to_phaseN.v1.i1.md'
    feedbackVersion: number;          // e.g., 1
  },
): string => {
  // pattern: ${artifactFileName}.[feedback].v${version}.[given].by_human.md
  // e.g., '5.1.execution.phase0_to_phaseN.v1.i1.md.[feedback].v1.[given].by_human.md'
};
```

### giveFeedback

[COMPOSE - main orchestrator]

```ts
/**
 * .what = generate a feedback file for a target behavior artifact
 * .why  = main entry point for the give.feedback skill
 */
export const giveFeedback = (
  input: {
    against: string;       // artifact name to target
    behavior?: string;     // optional behavior name/path
    version?: number;      // feedback version (default: 1)
    template?: string;     // optional custom template path
    force?: boolean;       // override bind mismatch
  },
  context?: { cwd?: string },
): {
  feedbackFile: string;
  artifactFile: string;
  behaviorDir: string;
} => {
  // 1. resolve behavior directory
  const { behaviorDir } = getBehaviorDirForFeedback(
    { behavior: input.behavior, force: input.force },
    context,
  );

  // 2. find latest artifact by name
  const artifact = getLatestArtifactByName(
    { behaviorDir, artifactName: input.against },
    context,
  );
  if (!artifact) throw BadRequestError('no artifact found', { ... });

  // 3. compute feedback filename
  const feedbackFileName = computeFeedbackFileName({
    artifactFileName: artifact.filename,
    feedbackVersion: input.version ?? 1,
  });

  // 4. check if feedback already exists
  const feedbackPath = join(behaviorDir, feedbackFileName);
  if (existsSync(feedbackPath)) throw BadRequestError('feedback already exists', { ... });

  // 5. resolve template path
  const templatePath = input.template ?? join(behaviorDir, '.ref.[feedback].v1.[given].by_human.md');
  if (!existsSync(templatePath)) throw BadRequestError('template not found', { ... });

  // 6. instantiate feedback file
  initFeedbackTemplate({
    templatePath,
    targetPath: feedbackPath,
    artifactFileName: artifact.filename,
    behaviorDirRel: relative(context?.cwd ?? process.cwd(), behaviorDir),
  });

  // 7. return result
  return {
    feedbackFile: feedbackPath,
    artifactFile: artifact.path,
    behaviorDir,
  };
};
```

---

## contract/cli

### give.feedback.ts

[REUSE from init.behavior.ts pattern]

```ts
import { z } from 'zod';

const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    against: z.string(),
    behavior: z.string().optional(),
    version: z.coerce.number().optional(),
    template: z.string().optional(),
    force: z.boolean().optional(),
    // rhachet passthrough args
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});

/**
 * .what = CLI entry point for give.feedback skill
 * .why  = enables invocation via rhachet skill dispatch
 */
export const giveFeedback = (): void => {
  const { named } = getCliArgs({ schema: schemaOfArgs });

  const result = giveFeedbackOp({
    against: named.against,
    behavior: named.behavior,
    version: named.version,
    template: named.template,
    force: named.force,
  });

  console.log(`feedback file created: ${result.feedbackFile}`);
  console.log(`target artifact: ${result.artifactFile}`);
};
```

---

## domain.roles skill

### give.feedback.sh

[REUSE shell dispatcher pattern]

```bash
#!/usr/bin/env bash
######################################################################
# .what = generate feedback file for a behavior artifact
# .how  = thin dispatcher to TypeScript implementation
######################################################################

set -euo pipefail

exec npx tsx -e "import('rhachet-roles-bhuild').then(m => m.cli.giveFeedback())" -- "$@"
```

---

## summary

| layer | artifact | decision | rationale |
|-------|----------|----------|-----------|
| domain.objects | BehaviorArtifact | [NEW] | represents target artifact with version/attempt |
| domain.objects | FeedbackFile | [NEW] | represents feedback linked to target |
| domain.operations | getLatestArtifactByName | [EXTEND] | generalize from getLatestBlueprintByBehavior |
| domain.operations | getBehaviorDirForFeedback | [COMPOSE] | combine bind lookup + flag resolution |
| domain.operations | initFeedbackTemplate | [EXTEND] | add $BEHAVIOR_REF_NAME placeholder |
| domain.operations | computeFeedbackFileName | [NEW] | pure filename computation |
| domain.operations | giveFeedback | [COMPOSE] | main orchestrator |
| contract/cli | give.feedback.ts | [REUSE] | CLI entry point pattern |
| domain.roles | give.feedback.sh | [REUSE] | shell dispatcher pattern |

### access.daos

none required â€” all operations are filesystem-based via node fs module.
