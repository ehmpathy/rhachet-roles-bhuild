# blackbox criteria: give.feedback

## usecase.1 = resolve behavior directory

given('branch is bound to a behavior via bind.behavior')
  when('give.feedback is invoked WITHOUT --behavior flag')
    then('behavior directory is resolved from the current bind')
      sothat('user does not need to specify --behavior when already bound')

given('branch is bound to a behavior via bind.behavior')
  when('give.feedback is invoked WITH --behavior <name> that matches the bound behavior')
    then('behavior directory is resolved from the current bind')
    then('--force is NOT required')
      sothat('redundant specification is allowed without friction')

given('branch is bound to a behavior via bind.behavior')
  when('give.feedback is invoked WITH --behavior <name> that differs from bound behavior, WITHOUT --force')
    then('exit code is non-zero')
    then('error message indicates branch is already bound to a different behavior')
    then('error message suggests --force to override')
      sothat('user does not accidentally target wrong behavior')

given('branch is bound to a behavior via bind.behavior')
  when('give.feedback is invoked WITH --behavior <name> that differs from bound behavior, WITH --force')
    then('behavior directory is resolved from the --behavior flag')
    then('current bind is ignored')
      sothat('explicit override is possible when intentional')

given('branch is NOT bound to any behavior')
  when('give.feedback is invoked WITH --behavior <name> flag')
    then('behavior directory is resolved from the --behavior flag')
    then('exit code is 0')

given('branch is NOT bound to any behavior')
  when('give.feedback is invoked WITHOUT --behavior flag')
    then('exit code is non-zero')
    then('error message indicates --behavior is required when not bound')
      sothat('user knows how to fix the invocation')

given('--behavior <name> is provided')
  when('no behavior directory matches the name')
    then('exit code is non-zero')
    then('error message indicates behavior not found')
    then('error message shows available behaviors')
      sothat('user can correct typos or see valid options')

given('--behavior <name> is provided')
  when('multiple behavior directories match the name')
    then('exit code is non-zero')
    then('error message indicates ambiguous match')
    then('error message lists all matched behaviors')
      sothat('user can provide a more specific name')

---

## usecase.2 = generate feedback file for any behavior artifact

given('behavior directory is resolved')
  when('give.feedback --against <artifact-name> is invoked WITHOUT --version')
    then('feedback file is created in the behavior directory')
      sothat('user can provide feedback on the target artifact')
    then('feedback filename follows pattern: ${targetArtifactFileName}.[feedback].v1.[given].by_human.md')
      sothat('feedback is clearly linked to its target artifact')
    then('$BEHAVIOR_REF_NAME placeholders inside file are replaced with actual artifact filename')
      sothat('internal references point to the correct artifact')
    then('exit code is 0')
    then('output confirms which artifact file feedback was generated against')

given('behavior directory is resolved')
  when('give.feedback --against <artifact-name> --version <N> is invoked')
    then('feedback filename follows pattern: ${targetArtifactFileName}.[feedback].v<N>.[given].by_human.md')
      sothat('user can create multiple versions of feedback on same artifact')
    then('e.g., --version 2 produces [feedback].v2.[given].by_human.md')

given('behavior directory has multiple artifacts of the same name')
  when('give.feedback --against <artifact-name> is invoked')
    then('feedback is generated against the latest artifact of that name')
      sothat('user feedback targets the most recent work')
    then('latest is determined by version (vX) and attempt (iX) in filename')
    then('files that contain [feedback] in name are excluded from target selection')
      sothat('prior feedback artifacts do not pollute target selection')

---

## usecase.3 = artifact name pattern resolution

given('--against value is provided')
  when('give.feedback resolves target artifact')
    then('target is found via glob pattern: *.<artifact-name>*(.vX)?(.iX)?.md')
    then('vX = version, iX = attempt')
    then('only .md files are considered (not .src files)')
      sothat('feedback targets rendered artifacts, not source prompts')

given('user provides --against execution')
  when('give.feedback resolves target')
    then('files like 5.1.execution.phase0_to_phaseN.v1.i1.md are matched')

given('user provides --against criteria.blackbox')
  when('give.feedback resolves target')
    then('files like 2.criteria.blackbox.md are matched')
    then('files like 2.criteria.blueprint.md are NOT matched')
      sothat('sub-types enable precise target selection')

given('user provides --against criteria.blueprint')
  when('give.feedback resolves target')
    then('files like 2.criteria.blueprint.md are matched')

given('user provides --against research.domain')
  when('give.feedback resolves target')
    then('files like 3.1.research.domain._.v1.md are matched')
    then('files like 3.1.research.claims._.v1.md are NOT matched')

given('user provides --against research.claims')
  when('give.feedback resolves target')
    then('files like 3.1.research.claims._.v1.md are matched')

given('user provides --against blueprint')
  when('give.feedback resolves target')
    then('files like 3.3.blueprint.v1.md are matched')

given('user provides --against wish')
  when('give.feedback resolves target')
    then('files like 0.wish.md are matched')

given('user provides --against vision')
  when('give.feedback resolves target')
    then('files like 1.vision.md are matched')

---

## usecase.4 = custom template selection

given('behavior directory contains .ref.[feedback].v1.[given].by_human.md template')
  when('give.feedback --against <artifact-name> is invoked')
    then('feedback file uses the template from behavior directory')
      sothat('per-behavior feedback templates are supported')

given('behavior directory does NOT contain a feedback template')
  when('give.feedback --against <artifact-name> is invoked')
    then('exit code is non-zero')
    then('error message indicates template file not found')
      sothat('user knows a template is required')

given('user wants to use a non-default template')
  when('give.feedback --against <artifact-name> --template path/to/template.md is invoked')
    then('feedback file uses the specified template')
      sothat('user can choose custom feedback formats')

---

## usecase.5 = edge cases and error handlers

given('behavior directory has no .md files that match the artifact name pattern')
  when('give.feedback --against <artifact-name> is invoked')
    then('exit code is non-zero')
    then('error message indicates no .md files found that match pattern')
    then('error message shows the glob pattern that was used')
      sothat('user can verify their --against value')

given('feedback file already exists for the target artifact')
  when('give.feedback --against <artifact-name> is invoked')
    then('prior feedback file is preserved (not overwritten)')
    then('exit code is non-zero')
    then('error message indicates feedback already exists for that artifact')
      sothat('user does not accidentally lose prior feedback')

---

## usecase.6 = idempotency and safety

given('give.feedback was already run against an artifact')
  when('new version (vX) of that artifact is created and give.feedback is run again')
    then('new feedback file is created for the new artifact version')
    then('prior feedback file remains untouched')
      sothat('each artifact version can have its own feedback')

given('user runs give.feedback twice in a row without changes')
  when('second invocation occurs with same --version (or both default)')
    then('second invocation fails with "feedback already exists" error')
      sothat('duplicate feedback files are prevented')

given('feedback v1 already exists for an artifact')
  when('give.feedback --version 2 is invoked against same artifact')
    then('feedback v2 file is created')
    then('feedback v1 file remains untouched')
      sothat('user can provide multiple rounds of feedback on same artifact')
