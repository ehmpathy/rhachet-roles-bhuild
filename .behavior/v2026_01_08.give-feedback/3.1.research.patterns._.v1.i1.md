# research: patterns for give.feedback

## pattern.1 = shell skill dispatcher [REUSE]

thin shell script that delegates to TypeScript CLI entry point via package export.

### citations

[1] `src/domain.roles/behaver/skills/init.behavior.sh:1-9`
```bash
#!/usr/bin/env bash
######################################################################
# .what = initialize a .behavior directory for bhuild thoughtroute
# .how  = thin dispatcher to TypeScript implementation
######################################################################

set -euo pipefail

exec npx tsx -e "import('rhachet-roles-bhuild').then(m => m.cli.initBehavior())" -- "$@"
```

[2] `src/domain.roles/behaver/skills/bind.behavior.sh:1-9`
```bash
#!/usr/bin/env bash
######################################################################
# .what = bind, unbind, or query branch-to-behavior binding
# .how  = thin dispatcher to TypeScript implementation
######################################################################

set -euo pipefail

exec npx tsx -e "import('rhachet-roles-bhuild').then(m => m.cli.bindBehavior())" -- "$@"
```

### relation to wish

the wish states: "we had a simple skill, similar to init.behavior, called `give.feedback`" [wish:3]. this pattern provides the shell entry point for skill invocation via rhachet.

### decision

[REUSE] — create `give.feedback.sh` with identical structure, dispatch to `m.cli.giveFeedback()`.

---

## pattern.2 = CLI entry point with Zod schema [REUSE]

TypeScript CLI entry points use `getCliArgs({ schema })` for typed arg parse with Zod validation.

### citations

[3] `src/contract/cli/init.behavior.ts:43-55`
```typescript
const schemaOfArgs = z.object({
  named: z.object({
    // skill-specific args
    name: z.string(),
    dir: z.string().optional(),
    // rhachet passthrough args (optional, ignored)
    repo: z.string().optional(),
    role: z.string().optional(),
    skill: z.string().optional(),
    s: z.string().optional(),
  }),
  ordered: z.array(z.string()).default([]),
});
```

[4] `src/contract/cli/init.behavior.ts:61-62`
```typescript
export const initBehavior = (): void => {
  const { named } = getCliArgs({ schema: schemaOfArgs });
```

[5] `src/infra/cli/getCliArgs.ts:103-106`
```typescript
export const getCliArgs = <T extends CliSchemaWithRhachetArgs>(input: {
  schema: T;
  argv?: string[];
}): z.infer<T> => {
```

### relation to wish

the wish requires `--against`, `--behavior`, `--template` flags [wish:5,29,36]. this pattern provides type-safe arg parse.

### decision

[REUSE] — define `schemaOfArgs` with `against`, `behavior`, `template`, `version`, `force` fields.

---

## pattern.3 = CLI export via index.ts [REUSE]

CLI entry points are exported from `src/index.ts` under `cli.*` namespace.

### citations

[6] `src/index.ts:4-16`
```typescript
// CLI entry points for portable skill dispatch
import { bindBehavior } from './contract/cli/bind.behavior';
import { bootBehavior } from './contract/cli/boot.behavior';
import { decomposeBehavior } from './contract/cli/decompose.behavior';
import { initBehavior } from './contract/cli/init.behavior';
import { reviewBehavior } from './contract/cli/review.behavior';

export const cli = {
  bindBehavior,
  bootBehavior,
  decomposeBehavior,
  initBehavior,
  reviewBehavior,
};
```

### relation to wish

shell dispatcher imports via `import('rhachet-roles-bhuild').then(m => m.cli.X())` [1]. must export `giveFeedback` for dispatch to work.

### decision

[REUSE] — add `giveFeedback` to `cli` export object.

---

## pattern.4 = behavior directory resolution via bind lookup [REUSE]

`getBranchBehaviorBind` finds which behavior (if any) a branch is bound to by search for `.bind/*.flag` files.

### citations

[7] `src/domain.operations/behavior/bind/getBranchBehaviorBind.ts:11-14`
```typescript
export const getBranchBehaviorBind = (
  input: { branchName?: string },
  context?: { cwd?: string },
): { behaviorDir: string | null; binds: string[] } => {
```

[8] `src/domain.operations/behavior/bind/getBranchBehaviorBind.ts:29-31`
```typescript
  // search for .behavior/*/.bind/${flagFileName}
  const behaviorRoot = join(cwd, '.behavior');
  if (!existsSync(behaviorRoot)) return { behaviorDir: null, binds: [] };
```

[9] `src/contract/cli/init.behavior.ts:70-74`
```typescript
  // check if branch already bound
  const bindResult = getBranchBehaviorBind(
    { branchName: currentBranch },
    context,
  );
```

### relation to wish

the wish states: "its optional if the current branch is bound already, via the `bind.behavior get` lookup" [wish:38].

### decision

[REUSE] — call `getBranchBehaviorBind` to resolve behavior directory when `--behavior` not provided.

---

## pattern.5 = behavior directory resolution via name match [REUSE]

`getBehaviorDir` finds behavior directory by fuzzy name match, fails if not found or ambiguous.

### citations

[10] `src/domain.operations/behavior/getBehaviorDir.ts:12-15`
```typescript
export const getBehaviorDir = (input: {
  name: string;
  targetDir?: string;
}): string => {
```

[11] `src/domain.operations/behavior/getBehaviorDir.ts:28-30`
```typescript
  const matches = allBehaviors
    .filter((name) => name.includes(input.name))
    .map((name) => join(behaviorRoot, name));
```

[12] `src/domain.operations/behavior/getBehaviorDir.ts:32-36`
```typescript
  if (matches.length === 0) {
    const availableList = allBehaviors.map((b) => `  ${b}`).join('\n');
    throw new BadRequestError(
      `no behavior found matching '${input.name}'\navailable behaviors:\n${availableList}`,
    );
```

[13] `src/domain.operations/behavior/getBehaviorDir.ts:39-43`
```typescript
  if (matches.length > 1) {
    const matchList = matches.map((m) => `  ${m}`).join('\n');
    throw new BadRequestError(
      `multiple behaviors match '${input.name}'\nmatches:\n${matchList}`,
    );
```

### relation to wish

the wish requires `--behavior` flag for explicit target [wish:36]. criteria requires "error message shows available behaviors" [criteria:44] and "error message lists all matched behaviors" [criteria:51].

### decision

[REUSE] — call `getBehaviorDir` when `--behavior` is provided to resolve to full path.

---

## pattern.6 = latest artifact resolution by version/attempt [EXTEND]

`getLatestBlueprintByBehavior` finds latest `.blueprint.vX.iX.md` file by parse version numbers from filenames.

### citations

[14] `src/domain.operations/behavior/bind/getLatestBlueprintByBehavior.ts:5-11`
```typescript
/**
 * .what = resolve the latest blueprint version from a behavior directory
 * .why  = both hooks and review.deliverable need this logic
 *
 * .note = version precedence:
 *         - v3.i2 > v2.i3 (major version wins)
 *         - v2.i3 > v2.i1 (latest iteration within major)
 */
```

[15] `src/domain.operations/behavior/bind/getLatestBlueprintByBehavior.ts:15-16`
```typescript
  // find all blueprint files matching pattern: *.blueprint.v*.i*.md
  const blueprintPattern = /\.blueprint\.v(\d+)\.i(\d+)\.md$/;
```

[16] `src/domain.operations/behavior/bind/getLatestBlueprintByBehavior.ts:47-52`
```typescript
  // sort by major version (desc), then by iteration (desc)
  blueprints.sort((a, b) => {
    if (a.majorVersion !== b.majorVersion)
      return b.majorVersion - a.majorVersion;
    return b.iteration - a.iteration;
  });
```

### relation to wish

the wish states: "latestExecutionFile is computed based on *.execution.*.v*.i*.md && does not have [feedback] in it" [wish:15-16]. criteria states: "latest is determined by version (vX) and attempt (iX) in filename" [criteria:79].

### decision

[EXTEND] — generalize to `getLatestArtifactByName({ behaviorDir, artifactName })` that:
- accepts dynamic artifact name (execution, blueprint, criteria.blackbox, etc.)
- builds glob pattern from artifact name
- excludes files with `[feedback]` in name
- handles files without version/attempt (e.g., `0.wish.md`)

---

## pattern.7 = template file instantiation with placeholder replace [EXTEND]

`initBehaviorDir` reads template files and replaces `$BEHAVIOR_DIR_REL` placeholder before write.

### citations

[17] `src/domain.operations/behavior/init/initBehaviorDir.ts:46-48`
```typescript
    // read template and replace variable
    let content = readFileSync(templatePath, 'utf-8');
    content = content.replace(/\$BEHAVIOR_DIR_REL/g, input.behaviorDirRel);
```

[18] `src/domain.operations/behavior/init/templates/.ref.[feedback].v1.[given].by_human.md:1-2`
```markdown
emit your response to the feedback into
- $BEHAVIOR_DIR_REL/.ref.[feedback].v1.[taken].by_robot.md
```

### relation to wish

the wish states: "inside of it, also replace .ref with ${latestExecutionFileName} too" [wish:24]. template contains `$BEHAVIOR_REF_NAME` placeholder that must be replaced with actual artifact filename.

### decision

[EXTEND] — create `initFeedbackTemplate({ templatePath, targetArtifactFileName, behaviorDirRel })` that:
- reads template file
- replaces `$BEHAVIOR_REF_NAME` with target artifact filename
- replaces `$BEHAVIOR_DIR_REL` with behavior directory relative path
- writes to output path

---

## pattern.8 = findsert file creation [REUSE]

`initBehaviorDir` uses findsert pattern: create if not found, skip if exists.

### citations

[19] `src/domain.operations/behavior/init/initBehaviorDir.ts:40-44`
```typescript
    // findsert: skip if exists
    if (existsSync(targetPath)) {
      kept.push(templateName);
      continue;
    }
```

### relation to wish

criteria states: "prior feedback file is preserved (not overwritten)" [criteria:162] and "error message indicates feedback already exists" [criteria:164].

### decision

[REUSE] — check if feedback file exists before creation, fail with helpful error if already exists.

---

## pattern.9 = fail-fast with BadRequestError [REUSE]

domain operations throw `BadRequestError` for user input errors with helpful messages.

### citations

[20] `src/domain.operations/behavior/getBehaviorDir.ts:34-36`
```typescript
    throw new BadRequestError(
      `no behavior found matching '${input.name}'\navailable behaviors:\n${availableList}`,
    );
```

[21] `src/domain.operations/behavior/getBehaviorDir.ts:41-43`
```typescript
    throw new BadRequestError(
      `multiple behaviors match '${input.name}'\nmatches:\n${matchList}`,
    );
```

### relation to wish

the wish states: "if not already bound though, it should be required and failfast if not given" [wish:40]. criteria has many error message requirements [criteria:18-20,29-31,36-37,etc.].

### decision

[REUSE] — use `BadRequestError` for all user-input validation errors.

---

## pattern.10 = getCurrentBranch for branch context [REUSE]

`getCurrentBranch` gets current git branch name for bind lookup.

### citations

[22] `src/contract/cli/init.behavior.ts:67-68`
```typescript
  // get current branch
  const currentBranch = getCurrentBranch({}, context);
```

[23] `src/contract/cli/bind.behavior.ts:75`
```typescript
  const branchName = getCurrentBranch({}, context);
```

### relation to wish

behavior directory resolution requires current branch to lookup bind [wish:38].

### decision

[REUSE] — call `getCurrentBranch` to get branch name for bind lookup.

---

## summary

| pattern | decision | rationale |
|---------|----------|-----------|
| shell skill dispatcher | [REUSE] | identical structure for all skills |
| CLI entry point with Zod | [REUSE] | proven arg parse pattern |
| CLI export via index.ts | [REUSE] | required for portable dispatch |
| bind lookup | [REUSE] | resolves behavior when not explicit |
| name match resolution | [REUSE] | resolves `--behavior` flag |
| latest artifact resolution | [EXTEND] | generalize beyond blueprint |
| template instantiation | [EXTEND] | add `.ref` placeholder replace |
| findsert pattern | [REUSE] | prevents overwrite |
| BadRequestError | [REUSE] | consistent error pattern |
| getCurrentBranch | [REUSE] | required for bind lookup |
