# blueprint: test shards for integration + acceptance tests

## overview

implement a hybrid shard strategy for both integration and acceptance tests:
- **explicit shards**: slow tests get dedicated shards (1 shard per explicit entry)
- **dynamic shards**: rest of tests distributed via Jest's `--shard` across N shards

this enables faster CI while we use free GitHub-hosted runners.

**target**: drop acceptance test walltime from ~7 minutes via parallelization.

---

## architecture: reusable composite actions

to eliminate duplication, extract shared shard logic into `.github/actions/`:

```
.github/
â”œâ”€â”€ actions/
â”‚   â””â”€â”€ test-shards-setup/
â”‚       â””â”€â”€ action.yml    # generates matrix from jest.*.shards.jsonc
â””â”€â”€ workflows/
    â””â”€â”€ .test.yml         # uses the composite action
```

**key insight**: composite actions can encapsulate step logic; matrix strategy stays at job level.

---

## config files

### `jest.integration.shards.jsonc`

```jsonc
{
  // explicit shards â€” each entry becomes one dedicated shard
  // use for slow tests that would bottleneck dynamic distribution
  "explicit": [],

  // dynamic shards â€” rest of tests distributed via Jest --shard
  "dynamic": {
    "shards": 2
  }
}
```

### `jest.acceptance.shards.jsonc`

```jsonc
{
  // explicit shards â€” each entry becomes one dedicated shard
  // candidates based on test size (lines of code as proxy):
  //   - skill.bind.behavior.acceptance.test.ts (545 lines)
  //   - skill.review.deliverable.acceptance.test.ts (381 lines)
  //   - skill.init.behavior.acceptance.test.ts (352 lines)
  // NOTE: actual runtime data should drive explicit shard curation
  "explicit": [],

  // dynamic shards â€” rest of tests distributed via Jest --shard
  // per wish: at least 3 dynamic shards
  "dynamic": {
    "shards": 3
  }
}
```

**total acceptance shards** = `explicit.length + dynamic.shards` = 0 + 3 = 3

---

## composite action: `.github/actions/test-shards-setup/action.yml`

single reusable action that generates matrix from any `jest.*.shards.jsonc` config:

```yaml
name: test-shards-setup
description: generate shard matrix from jest.*.shards.jsonc config

inputs:
  config-file:
    description: path to the shards config file (e.g., jest.integration.shards.jsonc)
    required: true
  test-type:
    description: label for notices (e.g., integration, acceptance)
    required: true

outputs:
  enabled:
    description: "'true' if config exists and shards are enabled"
    value: ${{ steps.generate.outputs.enabled }}
  matrix:
    description: "JSON array of shard configs for matrix strategy"
    value: ${{ steps.generate.outputs.matrix }}
  explicit-patterns:
    description: "pipe-delimited patterns for --testPathIgnorePatterns"
    value: ${{ steps.generate.outputs.explicit-patterns }}

runs:
  using: composite
  steps:
    - name: generate matrix from ${{ inputs.config-file }}
      id: generate
      shell: bash
      run: |
        config_file="${{ inputs.config-file }}"
        test_type="${{ inputs.test-type }}"

        # check if config exists
        if [[ ! -f "$config_file" ]]; then
          echo "::notice::$config_file not found, $test_type shard mode disabled"
          echo 'enabled=false' >> $GITHUB_OUTPUT
          exit 0
        fi

        echo 'enabled=true' >> $GITHUB_OUTPUT

        # read config (strip comments for jq)
        config=$(grep -v '^\s*//' "$config_file" | jq -c '.')

        # extract explicit shards
        explicit=$(echo "$config" | jq -c '.explicit // []')
        explicit_count=$(echo "$explicit" | jq 'length')

        # extract dynamic shard count
        dynamic_count=$(echo "$config" | jq '.dynamic.shards // 0')

        # build matrix
        matrix="[]"

        # add explicit shards
        for i in $(seq 0 $((explicit_count - 1))); do
          patterns=$(echo "$explicit" | jq -c ".[$i].patterns")
          matrix=$(echo "$matrix" | jq -c ". + [{\"type\": \"explicit\", \"index\": $i, \"patterns\": $patterns}]")
        done

        # add dynamic shards
        for i in $(seq 1 $dynamic_count); do
          matrix=$(echo "$matrix" | jq -c ". + [{\"type\": \"dynamic\", \"shard\": $i, \"total\": $dynamic_count}]")
        done

        # collect all explicit patterns for exclusion
        explicit_patterns=$(echo "$explicit" | jq -r '.[].patterns[]' 2>/dev/null | paste -sd '|' || echo '')

        echo "matrix=$matrix" >> $GITHUB_OUTPUT
        echo "explicit-patterns=$explicit_patterns" >> $GITHUB_OUTPUT

        echo "::notice::$test_type shard mode enabled with $(echo "$matrix" | jq 'length') shards"
```

---

## workflow changes

### 1. `test-shards-setup-integration` job (uses composite action)

```yaml
test-shards-setup-integration:
  runs-on: ubuntu-24.04
  outputs:
    enabled: ${{ steps.setup.outputs.enabled }}
    matrix: ${{ steps.setup.outputs.matrix }}
    explicit-patterns: ${{ steps.setup.outputs.explicit-patterns }}
  steps:
    - name: checkout
      uses: actions/checkout@v4
      with:
        sparse-checkout: jest.integration.shards.jsonc
        sparse-checkout-cone-mode: false

    - name: setup shards
      id: setup
      uses: ./.github/actions/test-shards-setup
      with:
        config-file: jest.integration.shards.jsonc
        test-type: integration
```

### 2. `test-shards-setup-acceptance` job (uses composite action)

```yaml
test-shards-setup-acceptance:
  runs-on: ubuntu-24.04
  outputs:
    enabled: ${{ steps.setup.outputs.enabled }}
    matrix: ${{ steps.setup.outputs.matrix }}
    explicit-patterns: ${{ steps.setup.outputs.explicit-patterns }}
  steps:
    - name: checkout
      uses: actions/checkout@v4
      with:
        sparse-checkout: jest.acceptance.shards.jsonc
        sparse-checkout-cone-mode: false

    - name: setup shards
      id: setup
      uses: ./.github/actions/test-shards-setup
      with:
        config-file: jest.acceptance.shards.jsonc
        test-type: acceptance
```

### 3. `test-shards-integration` job

runs integration test matrix:

```yaml
test-shards-integration:
  runs-on: ubuntu-24.04
  needs: [install, test-shards-setup-integration]
  if: needs.test-shards-setup-integration.outputs.enabled == 'true'
  strategy:
    fail-fast: false
    matrix:
      shard: ${{ fromJson(needs.test-shards-setup-integration.outputs.matrix) }}
  steps:
    - name: checkout
      uses: actions/checkout@v4

    - name: set node-version
      uses: actions/setup-node@v4
      with:
        node-version-file: ".nvmrc"

    - name: get node-modules from cache
      uses: actions/cache/restore@v4
      with:
        path: ./node_modules
        key: ${{ needs.install.outputs.node-modules-cache-key }}

    - name: get aws auth, if creds supplied
      if: ${{ inputs.creds-aws-role-arn }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.creds-aws-role-arn }}
        aws-region: ${{ inputs.creds-aws-region }}

    - name: start:testdb
      run: npm run start:testdb --if-present

    - name: start:livedb:dev
      run: npm run start:livedb:dev --if-present

    - name: build
      run: npm run build

    - name: test:integration (explicit ${{ matrix.shard.index }})
      if: matrix.shard.type == 'explicit'
      run: |
        patterns='${{ join(matrix.shard.patterns, '|') }}'
        THOROUGH=true npm run test:integration -- --testPathPattern="$patterns"
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

    - name: test:integration (dynamic ${{ matrix.shard.shard }}/${{ matrix.shard.total }})
      if: matrix.shard.type == 'dynamic'
      run: |
        exclude='${{ needs.test-shards-setup-integration.outputs.explicit-patterns }}'
        if [[ -n "$exclude" ]]; then
          THOROUGH=true npm run test:integration -- --testPathIgnorePatterns="$exclude" --shard=${{ matrix.shard.shard }}/${{ matrix.shard.total }}
        else
          THOROUGH=true npm run test:integration -- --shard=${{ matrix.shard.shard }}/${{ matrix.shard.total }}
        fi
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
```

### 4. `test-shards-acceptance` job

runs acceptance test matrix:

```yaml
test-shards-acceptance:
  runs-on: ubuntu-24.04
  needs: [install, test-shards-setup-acceptance]
  if: needs.test-shards-setup-acceptance.outputs.enabled == 'true'
  strategy:
    fail-fast: false
    matrix:
      shard: ${{ fromJson(needs.test-shards-setup-acceptance.outputs.matrix) }}
  steps:
    - name: checkout
      uses: actions/checkout@v4

    - name: set node-version
      uses: actions/setup-node@v4
      with:
        node-version-file: ".nvmrc"

    - name: get node-modules from cache
      uses: actions/cache/restore@v4
      with:
        path: ./node_modules
        key: ${{ needs.install.outputs.node-modules-cache-key }}

    - name: get aws auth, if creds supplied
      if: ${{ inputs.creds-aws-role-arn }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.creds-aws-role-arn }}
        aws-region: ${{ inputs.creds-aws-region }}

    - name: start:testdb
      run: npm run start:testdb --if-present

    - name: start:livedb:dev
      run: npm run start:livedb:dev --if-present

    - name: build
      run: npm run build

    - name: test:acceptance (explicit ${{ matrix.shard.index }})
      if: matrix.shard.type == 'explicit'
      run: |
        patterns='${{ join(matrix.shard.patterns, '|') }}'
        THOROUGH=true npm run test:acceptance -- --testPathPattern="$patterns"
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

    - name: test:acceptance (dynamic ${{ matrix.shard.shard }}/${{ matrix.shard.total }})
      if: matrix.shard.type == 'dynamic'
      run: |
        exclude='${{ needs.test-shards-setup-acceptance.outputs.explicit-patterns }}'
        if [[ -n "$exclude" ]]; then
          THOROUGH=true npm run test:acceptance -- --testPathIgnorePatterns="$exclude" --shard=${{ matrix.shard.shard }}/${{ matrix.shard.total }}
        else
          THOROUGH=true npm run test:acceptance -- --shard=${{ matrix.shard.shard }}/${{ matrix.shard.total }}
        fi
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
```

### 5. update `test-integration` to dual-purpose

```yaml
test-integration:
  runs-on: ubuntu-24.04
  needs: [install, test-shards-setup-integration, test-shards-integration]
  if: always() && needs.install.result == 'success' && needs.test-shards-setup-integration.result == 'success'
  steps:
    # early return: if shard mode enabled, just report results
    - name: report shard results
      if: needs.test-shards-setup-integration.outputs.enabled == 'true'
      run: |
        if [[ "${{ needs.test-shards-integration.result }}" == "success" ]]; then
          echo "ðŸ‘Œ all integration test shards passed"
        else
          echo "::error::integration test shards failed"
          exit 1
        fi

    # otherwise: full test flow (no shards, backwards compatible)
    - name: checkout
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      uses: actions/checkout@v4

    - name: set node-version
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      uses: actions/setup-node@v4
      with:
        node-version-file: ".nvmrc"

    - name: get node-modules from cache
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      uses: actions/cache/restore@v4
      with:
        path: ./node_modules
        key: ${{ needs.install.outputs.node-modules-cache-key }}

    - name: get aws auth, if creds supplied
      if: needs.test-shards-setup-integration.outputs.enabled != 'true' && inputs.creds-aws-role-arn
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.creds-aws-role-arn }}
        aws-region: ${{ inputs.creds-aws-region }}

    - name: start:testdb
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      run: npm run start:testdb --if-present

    - name: start:livedb:dev
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      run: npm run start:livedb:dev --if-present

    - name: build
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      run: npm run build

    - name: test:integration
      if: needs.test-shards-setup-integration.outputs.enabled != 'true'
      run: THOROUGH=true npm run test:integration
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
```

### 6. update `test-acceptance-locally` to dual-purpose

```yaml
test-acceptance-locally:
  runs-on: ubuntu-24.04
  needs: [install, test-shards-setup-acceptance, test-shards-acceptance]
  if: always() && needs.install.result == 'success' && needs.test-shards-setup-acceptance.result == 'success'
  steps:
    # early return: if shard mode enabled, just report results
    - name: report shard results
      if: needs.test-shards-setup-acceptance.outputs.enabled == 'true'
      run: |
        if [[ "${{ needs.test-shards-acceptance.result }}" == "success" ]]; then
          echo "ðŸ‘Œ all acceptance test shards passed"
        else
          echo "::error::acceptance test shards failed"
          exit 1
        fi

    # otherwise: full test flow (no shards, backwards compatible)
    - name: checkout
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true'
      uses: actions/checkout@v4

    - name: set node-version
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true'
      uses: actions/setup-node@v4
      with:
        node-version-file: ".nvmrc"

    - name: get node-modules from cache
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true'
      uses: actions/cache/restore@v4
      with:
        path: ./node_modules
        key: ${{ needs.install.outputs.node-modules-cache-key }}

    - name: get aws auth, if creds supplied
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true' && inputs.creds-aws-role-arn
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.creds-aws-role-arn }}
        aws-region: ${{ inputs.creds-aws-region }}

    - name: start:testdb
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true'
      run: npm run start:testdb --if-present

    - name: start:livedb:dev
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true'
      run: npm run start:livedb:dev --if-present

    - name: test:acceptance:locally
      if: needs.test-shards-setup-acceptance.outputs.enabled != 'true'
      run: THOROUGH=true npm run test:acceptance --if-present
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
```

---

## files to create

| file | purpose |
|------|---------|
| `.github/actions/test-shards-setup/action.yml` | composite action: generates matrix from config |
| `jest.integration.shards.jsonc` | config for integration test shards |
| `jest.acceptance.shards.jsonc` | config for acceptance test shards |

## files to modify

| file | changes |
|------|---------|
| `.github/workflows/.test.yml` | add shard setup jobs (use composite action), shard runner jobs, dual-purpose updates |

---

## what the composite action eliminates

**before (duplicated)**:
- 40+ lines of bash matrix generation logic Ã— 2 (integration + acceptance)
- same jq parse, same loop structures, same output format

**after (DRY)**:
- one 50-line composite action
- each setup job = 3 lines (checkout + uses action with inputs)

---

## test coverage

### unit tests

none required â€” no new domain logic is introduced. the shard config is static JSON; the composite action is bash + jq.

### integration tests

none required â€” the shard behavior is tested via CI execution itself.

### acceptance tests

the prior acceptance tests remain unchanged. the shard feature is validated by:

1. **config present**: matrix jobs spawn, tests run in parallel
2. **config absent**: falls back to non-sharded execution

### blackbox behavior verification

| scenario | expected behavior | how to verify |
|----------|-------------------|---------------|
| shard config present | matrix jobs spawn, tests run in parallel | CI logs show multiple shard jobs |
| shard config absent | single test job runs (backwards compatible) | CI logs show single test job |
| explicit shard | runs only matched patterns | CI logs show `--testPathPattern` flag |
| dynamic shard | runs with `--shard=N/M`, excludes explicit patterns | CI logs show `--shard` and `--testPathIgnorePatterns` flags |
| shard job fails | `test-integration`/`test-acceptance-locally` reports failure | CI shows red status |
| all shards pass | `test-integration`/`test-acceptance-locally` reports success | CI shows green status |

---

## edge cases

### no explicit shards

```jsonc
{ "explicit": [], "dynamic": { "shards": 3 } }
```

- matrix contains only dynamic shards
- `explicit-patterns` is empty, `--testPathIgnorePatterns` is skipped

### no dynamic shards

```jsonc
{ "explicit": [...], "dynamic": { "shards": 0 } }
```

- matrix contains only explicit shards
- all tests must be covered by explicit patterns (or they won't run)

### config file absent

- composite action outputs `enabled=false`
- `test-shards-*` jobs are skipped
- `test-integration`/`test-acceptance-locally` runs tests directly
- **fully backwards compatible** â€” behaves exactly as before

---

## execution plan

### phase 1: create composite action

1. create `.github/actions/test-shards-setup/action.yml`

### phase 2: create config files

1. create `jest.integration.shards.jsonc` with 2 dynamic shards
2. create `jest.acceptance.shards.jsonc` with 3 dynamic shards

### phase 3: update workflow

1. add `test-shards-setup-integration` job (uses composite action)
2. add `test-shards-setup-acceptance` job (uses composite action)
3. add `test-shards-integration` job
4. add `test-shards-acceptance` job
5. update `test-integration` to dual-purpose
6. update `test-acceptance-locally` to dual-purpose

### phase 4: validate

1. push to branch
2. verify CI runs with shards
3. compare walltime before/after
4. iterate on shard count based on observed times

### phase 5: optimize (future)

1. identify slowest tests via CI time data
2. add slow tests to explicit shards
3. tune dynamic shard count for optimal parallelism

---

## expected walltime improvement

**before**: ~7 minutes (sequential acceptance tests)

**after**: ~7 / 3 â‰ˆ 2-3 minutes (parallel with 3 dynamic shards)

actual improvement depends on:
- test distribution across shards (jest's `--shard` aims for even splits)
- setup overhead per shard (checkout, cache restore, build)
- longest-run test (bounds minimum walltime)

---

## tradeoffs

| aspect | pro | con |
|--------|-----|-----|
| composite action | DRY, single source of truth for matrix logic | one more file to maintain |
| dynamic shards | automatic distribution, no maintenance | can't control which tests run together |
| explicit shards | isolate slow tests, predictable wall time | manual maintenance of patterns |
| config files | version-controlled, self-documented | another file to maintain |
| workflow complexity | flexible, backwards compatible | more jobs in CI visualization |
| parallel acceptance | faster walltime | more GitHub Actions minutes consumed |
