# vision: pat-for-cicd (github app tokens via credential firewall)

> replace the banned pat with short-lived tokens from the bhuild-beaver github app, resolved through `rhachet/keychain` â€” a universal credential firewall that guarantees only short-lived tokens reach downstream processes

---

## the outcome world

### before: the banned pat

vlad merges a feature for radio task dispatch via gh.issues. tests pass locally, ci is green. life is good.

then github flags the pat as a bot. the token is banned. ci turns red overnight. acceptance tests that push/pull radio tasks to the demo repo fail with auth errors. vlad can't run integration tests locally either â€” the same pat was shared across both environments.

a single long-lived secret, shared between local dev and ci, becomes a single point of failure. when it dies, all of it dies. and there's no safety net â€” any process that touches the env can see the raw credential.

### after: credential firewall via `rhachet/keychain`

vlad pushes a commit. ci kicks off. the `rhachet/keychain` step reads `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` (a JSON blob with app credentials), mints a fresh 1-hour token, and writes it to `$GITHUB_ENV`. the original secret never reaches the test steps. tests run. token expires.

locally, vlad does the same:

```sh
source use.keychain.sh
npm run test:acceptance -- skill.radio.task.push.via-gh-issues
```

`use.keychain.sh` loads credentials, detects which ones are long-lived, resolves them into short-lived tokens, unsets the originals, and exports only the resolved values. no long-lived credential ever reaches a child process.

### the "aha" moment

> "the keychain isn't just a credential loader â€” it's a firewall. it reads raw credentials, resolves them into the shortest-lived form possible, and refuses to pass through what it can't translate. tests never see private keys. ci never leaks long-lived tokens. one gate, both environments."

---

## user experience

### usecase 1: developer runs tests locally

**goal**: developer sources keychain, gets only short-lived tokens, runs tests

**timeline**:
1. one-time setup: add credentials to `~/.config/rhachet/keychain.env`
2. before test run: `source use.keychain.sh`
3. keychain detects each credential type, resolves long-lived â†’ short-lived
4. exports only resolved values, unsets originals
5. tests run â€” only short-lived tokens in env

**contract**:
```sh
# ~/.config/rhachet/keychain.env (one-time setup)
export OPENAI_API_KEY=sk-...
export ANTHROPIC_API_KEY=sk-ant-...
export TAVILY_API_KEY=tvly-...
export BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN='{"appId":"123456","privateKey":"-----BEGIN RSA PRIVATE KEY-----\n...","owner":"ehmpathy"}'
```

```sh
# before tests
source use.keychain.sh

# output:
# ğŸ” rhachet/keychain
# â”œâ”€ OPENAI_API_KEY Â·Â·Â· pass (api key, no short-lived alt)
# â”œâ”€ ANTHROPIC_API_KEY Â·Â·Â· pass (api key, no short-lived alt)
# â”œâ”€ TAVILY_API_KEY Â·Â·Â· pass (api key, no short-lived alt)
# â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN Â·Â·Â· resolved (github app â†’ 1h token)
# â”‚  â”œâ”€ as: bhuild-beaver[bot]
# â”‚  â”œâ”€ org: ehmpathy
# â”‚  â””â”€ repos: rhachet-roles-bhuild-demo
# â””â”€ done. 4 keys loaded, 1 resolved, 0 blocked.

npm run test:acceptance -- skill.radio.task.push.via-gh-issues
# BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN = ghs_... (short-lived)
# the JSON blob with the private key is gone from env
```

### usecase 2: ci runs tests via credential firewall

**goal**: ci passes raw secrets to keychain step, keychain resolves and sanitizes, test steps only see short-lived tokens

**timeline**:
1. github repo stores `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` as a JSON blob secret
2. test workflow passes raw secret only to the `rhachet/keychain` step
3. keychain resolves â†’ writes short-lived token to `$GITHUB_ENV`
4. subsequent test steps see only the resolved token â€” original secret never in their env
5. tests run with fresh 1-hour token

**contract**:
```yaml
# in .test.yml, per test job

# step 1: keychain resolves credentials
# raw secret is ONLY visible to this step
- name: resolve credentials
  uses: rhachet/keychain@v1
  env:
    BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN: ${{ secrets.BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN }}
  # internally:
  #   detects JSON app creds â†’ mints short-lived token
  #   writes: echo "BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN=ghs_..." >> $GITHUB_ENV
  #   original secret stays in this step only

# step 2: tests see only the resolved token via $GITHUB_ENV
- name: test:integration
  run: npm run test:integration
  # no env: block â€” BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN already in env from $GITHUB_ENV
  # value is ghs_... (short-lived), not the JSON blob
```

**key insight**: the raw secret (JSON with private key) is only in the keychain step's `env:`. it never appears in `$GITHUB_ENV`. only the resolved short-lived token does. subsequent steps have zero access to the private key.

**what `.test.yml` looks like**:
```yaml
# no changes to the secret name â€” still BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
# no new vars or secrets â€” same single secret, just a different value (JSON instead of pat)
# one new step per job: rhachet/keychain resolve
```

### usecase 3: keychain as universal credential firewall

**goal**: every credential goes through the keychain gate â€” no raw long-lived credential ever reaches a downstream process

**the guarantee**:

| credential type detected | keychain behavior |
|---|---|
| github app creds (JSON with `appId` + `privateKey`) | resolve â†’ short-lived installation token, export token |
| short-lived token (e.g., `ghs_...`) | pass through |
| long-lived pat (`ghp_...`) | **fail fast** â€” refuse to export, block the run |
| api key with no short-lived alt (e.g., `sk-...`) | pass through with note (can't translate) |
| unrecognized format | pass through with note |

the keychain enforces a **minimum-privilege, minimum-lifespan** policy:
- if a credential can be translated to a shorter-lived form â†’ translate it
- if a credential is long-lived and translatable but raw â†’ block it (force the safe path)
- if a credential has no short-lived alternative â†’ pass it through (api keys, etc.)

this means: once a repo adopts the keychain, you **cannot accidentally leak a long-lived github credential** to tests or ci processes. the firewall catches it.

### usecase 4: future â€” rhachet keychain store

**goal**: when rhachet keychain store ships, credential storage moves from env files to the store â€” but the firewall contract stays the same

**timeline**:
1. `use.keychain.sh` reads from rhachet keychain store instead of `keychain.env`
2. same firewall logic: detect, resolve, sanitize
3. `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` contract unchanged â€” downstream tests never notice

the current design is forward-compatible: the credential source changes, but the firewall layer and the test contract stay stable.

---

## mental model

### how developers describe it to a friend

> "we have a credential firewall called rhachet/keychain. you give it your raw credentials â€” api keys, github app private keys, whatever. it figures out which ones can be turned into short-lived tokens, resolves them, and only exports the short-lived versions. the raw credentials never reach your tests or ci processes. same tool locally and in github actions."

### key clarification: private key is per-app, not per-installation

the bhuild-beaver github app has **one** private key (at the app level). the **installation** on `ehmpathy` org scoped to `rhachet-roles-bhuild-demo` controls which repos the token can access. so:

- store the app private key once (in the JSON blob)
- the installation guarantees the minted token can only touch the demo repo
- no need for separate keys per repo or per environment

### the firewall analogy

```
raw credentials (long-lived, broad)
        â”‚
        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   rhachet    â”‚  detect â†’ resolve â†’ sanitize
 â”‚   keychain   â”‚
 â”‚  (firewall)  â”‚  blocks: long-lived pats
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  resolves: app creds â†’ short-lived tokens
        â”‚          passes: api keys (no alt)
        â–¼
 short-lived tokens only
        â”‚
        â–¼
   tests / ci processes
```

### analogies that fit

| analogy               | maps to                                               |
| --------------------- | ----------------------------------------------------- |
| airport security      | keychain firewall (inspect, resolve, block contraband) |
| hotel keycard machine | `getGithubTokenFromGithubAppKey()` (mints keycards)   |
| passport              | app private key (proves identity, not used directly)   |
| flight pass           | short-lived token (scoped, expires, used directly)     |
| customs declaration   | JSON blob (declares what credentials you have)         |
| contraband detector   | pat detection â†’ fail fast                             |

### terms: developer vs system

| developer says              | system says                                             |
| --------------------------- | ------------------------------------------------------- |
| "load my keys"              | `source use.keychain.sh`                                |
| "the demo repo token"       | `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN`                  |
| "resolve credentials"       | `rhachet/keychain` firewall step                        |
| "mint a token"              | `getGithubTokenFromGithubAppKey()` in `src/infra/`      |
| "block long-lived creds"    | keychain detects `ghp_...` â†’ fail fast                  |
| "ci token for tests"        | same env var, resolved by keychain before tests run     |

---

## what changes

### new: `rhachet/keychain` (credential firewall)

| component                       | detail                                                             |
| ------------------------------- | ------------------------------------------------------------------ |
| `use.keychain.sh` (local)       | replaces `use.apikeys.sh` â€” loads, resolves, sanitizes, exports    |
| `rhachet/keychain@v1` (ci)      | github action â€” reads secrets, resolves, writes to `$GITHUB_ENV`   |
| `src/infra/getGithubTokenFromGithubAppKey.ts` | resolves JSON app creds â†’ short-lived installation token |
| credential type detection        | inspects each env var to determine if resolvable                   |
| fail-fast on raw long-lived pats | `ghp_...` detected â†’ block, refuse to export                      |
| silent unset of raw credentials  | after resolve, originals removed from env without trace            |

### ci/cd changes

| file                           | change                                                         |
| ------------------------------ | -------------------------------------------------------------- |
| `.github/workflows/.test.yml`  | add `rhachet/keychain@v1` step per test job (before test steps)|
| `.github/workflows/.test.yml`  | remove `env: BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` from test steps (now in `$GITHUB_ENV`) |
| `.github/workflows/test.yml`   | no change to secret passthrough â€” still `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` |
| `.github/workflows/publish.yml`| same keychain step for test jobs                                |

### github repo config changes

| config                                          | change                                            |
| ----------------------------------------------- | ------------------------------------------------- |
| `secrets.BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN`  | update value: pat â†’ JSON blob with app credentials |

one secret, same name, new value format. zero new vars or secrets to add.

### new prodcode

| file                                            | detail                                              |
| ----------------------------------------------- | --------------------------------------------------- |
| `src/infra/getGithubTokenFromGithubAppKey.ts`   | JWT sign via Node `crypto`, call GitHub API for installation token |

### no other prodcode changes needed

the prior prodcode (`getGithubTokenByAuthArg.ts`, `daoRadioTaskViaGhIssues.ts`, etc.) already works with any token passed via `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN`. the keychain resolves the JSON blob into a plain token before tests run â€” downstream code never sees the JSON.

---

## evaluation

### how well does it solve the goals?

| goal                              | solution                                                  | score       |
| --------------------------------- | --------------------------------------------------------- | ----------- |
| unblock ci (banned pat)           | app token replaces pat                                    | âœ… excellent |
| local test auth                   | `use.keychain.sh` resolves app creds â†’ short-lived token  | âœ… excellent |
| ci test auth                      | `rhachet/keychain@v1` resolves before tests               | âœ… excellent |
| portable across environments      | one env var, same JSON blob, same resolution logic        | âœ… excellent |
| credential security               | firewall guarantees no long-lived creds reach tests       | âœ… excellent |
| narrow permissions                | issues:write + metadata:read only (installation-scoped)   | âœ… excellent |
| short-lived tokens                | 1 hour max, minted fresh each run                         | âœ… excellent |
| minimal workflow changes           | one new step per job, same secret name                    | âœ… excellent |
| no prodcode changes (downstream)  | env var contract unchanged                                | âœ… excellent |
| forward-compatible                | keychain store replaces env file later                    | âœ… excellent |

### pros

- **credential firewall**: no long-lived credential reaches downstream processes, ever
- **no more bot flags**: app tokens are designed for automation; pats are not
- **narrow scope**: issues:write on one demo repo only â€” least privilege
- **short-lived**: 1 hour tokens vs indefinite pat lifespan
- **one env var**: `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` stays the same, just polymorphic value
- **same secret name in ci**: no new vars or secrets to add â€” just update the value
- **identical local and ci path**: keychain firewall works the same in both
- **blocks raw pats**: if someone tries to use a `ghp_...` token, keychain refuses â€” forces the safe path
- **infrastructure exists**: bhuild-beaver app already provisioned, Node `crypto` handles JWT

### cons

- **new component**: `rhachet/keychain` needs to be built (action + local shell)
- **one-time local setup**: developers add app credentials to `keychain.env` (once)
- **JSON blob in secret**: slightly unusual, but cleaner than multiple vars

### edgecases and pit of success

| edgecase                            | pit of success design                                                        |
| ----------------------------------- | ---------------------------------------------------------------------------- |
| app not installed on demo repo      | token resolution fails loud with clear error from github api                 |
| private key rotated                 | update one secret value (JSON blob); all environments auto-heal              |
| token expires mid-test              | 1 hour is 6x longer than typical test suite (~10 min)                        |
| developer forgets local setup       | `use.keychain.sh` prints clear instructions with required vars               |
| someone sets a raw pat as the value | keychain detects `ghp_...` â†’ **fail fast**, refuses to export                |
| private key in child process env    | keychain resolves and unsets before children start â€” private key never leaks  |
| JSON blob logged in ci              | github actions auto-masks `secrets.*` values in logs                         |
| app permissions changed             | declastruct detects drift via `provision/github.apps/`                       |
| future keychain store migration     | swap credential source; firewall layer and test contract unchanged           |

---

## summary

`rhachet/keychain` is a universal credential firewall. it reads raw credentials (JSON app creds, api keys, tokens), resolves long-lived ones into the shortest-lived form possible, blocks what it can't trust, and exports only the sanitized values. tests and ci processes never see private keys or raw pats.

for this wish: store the bhuild-beaver app credentials as a JSON blob in `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN`. the keychain detects the JSON, mints a 1-hour installation token via `getGithubTokenFromGithubAppKey()`, and exports just the token. same env var name, same downstream contract, one new firewall step.

> credentials go in. only keycards come out. ğŸ”
