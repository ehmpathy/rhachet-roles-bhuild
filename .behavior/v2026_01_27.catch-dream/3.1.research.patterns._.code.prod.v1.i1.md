# research: prod codepath patterns for catch.dream ðŸŒ™

## summary

the prior `init.behavior` implementation provides a complete template for the `catch.dream` skill. most patterns can be reused directly, with only the domain-specific logic that needs new implementation.

---

## pattern.1 = portable skill dispatch

**[REUSE]**

shell skills dispatch to TypeScript via dynamic import:

```bash
exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.initBehavior())" -- "$@"
```

> citation [1]: `src/domain.roles/behaver/skills/init.behavior.sh:32`
> ```bash
> exec node -e "import('rhachet-roles-bhuild').then(m => m.cli.initBehavior())" -- "$@"
> ```

this pattern is package-manager agnostic and resolves via the package.json `exports` field.

**for catch.dream:**
- create `src/domain.roles/dreamer/skills/catch.dream.sh`
- dispatch to `m.cli.catchDream()`

---

## pattern.2 = cli module registration

**[EXTEND]**

cli entry points are registered in `src/index.ts` with `withEmojiSpaceShim`:

> citation [2]: `src/index.ts:13-19`
> ```typescript
> export const cli = {
>   bindBehavior: () => withEmojiSpaceShim({ logic: async () => bindBehavior() }),
>   bootBehavior: () => withEmojiSpaceShim({ logic: async () => bootBehavior() }),
>   // ...
>   initBehavior: () => withEmojiSpaceShim({ logic: async () => initBehavior() }),
> };
> ```

**for catch.dream:**
- add `catchDream: () => withEmojiSpaceShim({ logic: async () => catchDream() })`

---

## pattern.3 = cli arg schema with rhachet passthrough

**[REUSE]**

zod schema validates args while it accepts rhachet passthrough args:

> citation [3]: `src/contract/cli/init.behavior.ts:29-42`
> ```typescript
> const schemaOfArgs = z.object({
>   named: z.object({
>     // skill-specific args
>     name: z.string(),
>     dir: z.string().optional(),
>     open: z.string().optional(),
>     // rhachet passthrough args (optional, ignored)
>     repo: z.string().optional(),
>     role: z.string().optional(),
>     skill: z.string().optional(),
>     s: z.string().optional(),
>   }),
>   ordered: z.array(z.string()).default([]),
> });
> ```

**for catch.dream:**
- same pattern: `name` required, `open` optional
- no `dir` arg needed (always uses git root)

---

## pattern.4 = cli arg parse with getCliArgs

**[REUSE]**

type-safe arg parse with validation:

> citation [4]: `src/contract/cli/init.behavior.ts:49`
> ```typescript
> const { named } = getCliArgs({ schema: schemaOfArgs });
> ```

> citation [5]: `src/infra/cli/getCliArgs.ts:103-106`
> ```typescript
> export const getCliArgs = <T extends CliSchemaWithRhachetArgs>(input: {
>   schema: T;
>   argv?: string[];
> }): z.infer<T> => {
> ```

**for catch.dream:**
- direct reuse of `getCliArgs({ schema: schemaOfArgs })`

---

## pattern.5 = isodate generation

**[REUSE]**

date stamp in `YYYY_MM_DD` format:

> citation [6]: `src/contract/cli/init.behavior.ts:72-74`
> ```typescript
> const now = new Date();
> const isoDate = `${now.getFullYear()}_${String(now.getMonth() + 1).padStart(2, '0')}_${String(now.getDate()).padStart(2, '0')}`;
> ```

**for catch.dream:**
- exact reuse for dream file date prefix

---

## pattern.6 = findsert file operation

**[EXTEND]**

findsert = create if not found, skip if present (idempotent):

> citation [7]: `src/domain.operations/behavior/init/initBehaviorDir.ts:40-44`
> ```typescript
> // findsert: skip if exists
> if (existsSync(targetPath)) {
>   kept.push(templateName);
>   continue;
> }
> ```

**for catch.dream:**
- extend for dream file findsert
- new logic: search for prior dream by name (any date prefix)
- new logic: if prior found, return path to prior (not new)

---

## pattern.7 = directory creation (idempotent)

**[REUSE]**

recursive directory creation:

> citation [8]: `src/domain.operations/behavior/init/initBehaviorDir.ts:30-31`
> ```typescript
> // create behavior directory (idempotent)
> mkdirSync(input.behaviorDir, { recursive: true });
> ```

**for catch.dream:**
- reuse for `.dream/` folder bootstrap

---

## pattern.8 = opener with error handler

**[REUSE]**

open file in editor with graceful failure:

> citation [9]: `src/infra/shell/openFileWithOpener.ts:9-25`
> ```typescript
> export const openFileWithOpener = (input: {
>   opener: string;
>   filePath: string;
> }): void => {
>   const command = `${input.opener} "${input.filePath}"`;
>   try {
>     execSync(command, { stdio: 'inherit' });
>   } catch (error) {
>     throw new OpenerUnavailableError(
>       `opener '${input.opener}' unavailable or failed`,
>       { cause: error instanceof Error ? error : undefined },
>     );
>   }
> };
> ```

> citation [10]: `src/contract/cli/init.behavior.ts:123-135`
> ```typescript
> if (named.open) {
>   try {
>     openFileWithOpener({ opener: named.open, filePath: wishPathRel });
>     openerUsed = named.open;
>   } catch (error) {
>     if (error instanceof OpenerUnavailableError) {
>       console.log('');
>       console.log(`âš ï¸  ${error.message}`);
>     } else {
>       throw error;
>     }
>   }
> }
> ```

**for catch.dream:**
- direct reuse of `openFileWithOpener`
- same error handler pattern

---

## pattern.9 = tree-style output format

**[EXTEND]**

output with tree structure via unicode box-draw chars:

> citation [11]: `src/domain.operations/behavior/render/computeFooterOutput.ts:9-17`
> ```typescript
> const dim = '\x1b[2m';
> const reset = '\x1b[0m';
>
> // build output lines
> const lines = [`ðŸŒ² go on then,`, `   â”œâ”€ ${input.wishPathRel}`];
>
> // add opener line or tip based on whether opener was used
> if (input.opener) {
>   lines.push(`   â””â”€ ${dim}opened in ${input.opener}${reset}`);
> ```

**for catch.dream:**
- extend for `ðŸŒ™ dream caught|found` format
- same tree structure: `â”œâ”€` for path, `â””â”€` for opener/tip

---

## pattern.10 = empty --open validation

**[REUSE]**

validate that --open has a value if provided:

> citation [12]: `src/contract/cli/init.behavior.ts:54-64`
> ```typescript
> if (named.open !== undefined && named.open.trim() === '') {
>   console.error('â›ˆï¸  error: --open requires an editor name');
>   console.error('');
>   console.error('please specify what editor to open with. for example:');
>   console.error('  --open codium');
>   // ...
>   process.exit(1);
> }
> ```

**for catch.dream:**
- direct reuse of validation pattern

---

## pattern.11 = ansi dim for secondary info

**[REUSE]**

dim text for tips and secondary information:

> citation [13]: `src/contract/cli/init.behavior.ts:149-150`
> ```typescript
> const dim = '\x1b[2m';
> const reset = '\x1b[0m';
> ```

> citation [14]: `src/domain.operations/behavior/render/computeFooterOutput.ts:19-21`
> ```typescript
> lines.push(
>   `   â””â”€ ${dim}tip: use --open to open the wish automatically${reset}`,
> );
> ```

**for catch.dream:**
- reuse for tips and secondary output

---

## new patterns required

### pattern.new.1 = dream name normalization

**[NEW]**

convert input to kebab-case, replace special chars with `-`:

- spaces â†’ `-`
- uppercase â†’ lowercase
- special chars â†’ `-`
- collapse consecutive `-`

no prior pattern exists; requires new implementation.

---

### pattern.new.2 = dream file search by name

**[NEW]**

find prior dream by name (any date prefix):

```typescript
// glob: .dream/*.${dreamName}.dream.md
// returns: path to prior dream or null
```

requires new `findDreamByName` operation.

---

### pattern.new.3 = fuzzy match search

**[NEW]**

find similar dream names from past week:

```typescript
// compare edit distance or prefix match
// filter by date within past 7 days
// return: list of { name, date, path }
```

requires new `findFuzzyDreamMatches` operation.

---

### pattern.new.4 = readme findsert for .dream/

**[NEW]**

create `.dream/.readme.md` that explains the dreamcatcher:

```markdown
# .dream/ ðŸŒ™

this folder catches dreams â€” transient visions that strike in flow state.

## how to use

catch a dream:
\`\`\`sh
npx rhachet run --skill catch.dream --name "my-idea" --open codium
\`\`\`

review dreams: browse this folder

graduate to behavior: `npx rhachet run --skill init.behavior --name "my-idea"`

ðŸŒ™
```

---

## summary table

| pattern                 | action   | source                                               |
| ----------------------- | -------- | ---------------------------------------------------- |
| portable skill dispatch | [REUSE]  | init.behavior.sh:32                                  |
| cli module registration | [EXTEND] | index.ts:13-19                                       |
| cli arg schema          | [REUSE]  | init.behavior.ts:29-42                               |
| cli arg parse           | [REUSE]  | getCliArgs.ts:103-106                                |
| isodate generation      | [REUSE]  | init.behavior.ts:72-74                               |
| findsert file           | [EXTEND] | initBehaviorDir.ts:40-44                             |
| directory creation      | [REUSE]  | initBehaviorDir.ts:30-31                             |
| opener with error       | [REUSE]  | openFileWithOpener.ts:9-25, init.behavior.ts:123-135 |
| tree-style output       | [EXTEND] | computeFooterOutput.ts:9-17                          |
| empty --open validation | [REUSE]  | init.behavior.ts:54-64                               |
| ansi dim                | [REUSE]  | init.behavior.ts:149-150                             |
| dream name normalization | [NEW]    | â€”                                                    |
| dream file search       | [NEW]    | â€”                                                    |
| fuzzy match search      | [NEW]    | â€”                                                    |
| readme findsert         | [NEW]    | â€”                                                    |

---

ðŸŒ™
