# distill: domain objects and operations for catch.dream ğŸŒ™

## summary

catch.dream is a lightweight findsert operation on dream artifacts. the domain is intentionally minimal â€” two literals (`DreamArtifact`, `DreamCandidate`) and pure operations. mirrors `BehaviorArtifact` pattern. complexity lives in normalization and fuzzy match, not in entity relationships.

---

## usecases â†’ contracts

### usecase.1 = catch a new dream

```typescript
// contract: catch.dream CLI
runCatchDream({
  name: 'config-reload',
  open: 'codium',
})
// â†’ creates .dream/2026_01_27.config-reload.dream.md
// â†’ opens in codium
// â†’ outputs "ğŸŒ™ dream caught"
```

### usecase.2 = return to prior dream

```typescript
// same contract, different outcome
runCatchDream({
  name: 'config-reload',  // already exists from 2026_01_20
  open: 'codium',
})
// â†’ no new file
// â†’ opens prior .dream/2026_01_20.config-reload.dream.md
// â†’ outputs "ğŸŒ™ dream found"
```

### usecase.3 = typo recovery via fuzzy match

```typescript
// after catch creates file, fuzzy match prompts for recovery
runCatchDream({
  name: 'config-relod',  // typo
  open: 'codium',
})
// â†’ creates .dream/2026_01_27.config-relod.dream.md
// â†’ opens in codium (no latency)
// â†’ outputs "ğŸ’­ related dreams from past week"
// â†’ prompts for reuse selection
```

---

## domain.objects

### literal.1 = DreamArtifact

the core literal â€” a persisted dream in the `.dream/` folder. mirrors `BehaviorArtifact` pattern.

```typescript
import { IsoDateStamp } from 'iso-time';

interface DreamArtifact {
  /**
   * full path to the artifact file
   * e.g., ".dream/2026_01_27.config-reload.dream.md"
   */
  path: string;

  /**
   * the normalized dream name extracted from filename
   * e.g., "config-reload"
   */
  name: string;

  /**
   * the date when this dream was first captured
   * format: YYYY_MM_DD via IsoDateStamp
   * e.g., "2026_01_27"
   */
  date: IsoDateStamp;

  /**
   * the base filename without path
   * e.g., "2026_01_27.config-reload.dream.md"
   */
  filename: string;
}

class DreamArtifact extends DomainLiteral<DreamArtifact> implements DreamArtifact {
  public static primary = ['path'] as const;
  public static unique = ['path'] as const;
}
```

**identity semantics:**
- mirrors `BehaviorArtifact` pattern from `src/domain.objects/BehaviorArtifact.ts`
- `path` is both primary and unique key
- `date` represents when the dream was *first* captured
- `path` is derived: `.dream/${date}.${name}.dream.md`

---

### literal.2 = DreamCandidate

a fuzzy match candidate â€” dream artifact with distance score.

```typescript
interface DreamCandidate {
  /**
   * the matched dream artifact
   */
  dream: DreamArtifact;

  /**
   * how close the match is (lower = closer)
   * e.g., edit distance
   */
  distance: number;
}

class DreamCandidate extends DomainLiteral<DreamCandidate> implements DreamCandidate {
  public static nested = { dream: DreamArtifact };
}
```

---

## domain.operations

### operation.1 = normalizeDreamName

**[NEW]** â€” pure transformation, no prior pattern.

```typescript
/**
 * .what = converts raw input to kebab-case dream name
 * .why = ensures consistent file name across all dreams
 */
const normalizeDreamName = (
  input: { raw: string },
): string => {
  return input.raw
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')  // special chars â†’ dash
    .replace(/-+/g, '-')           // collapse dashes
    .replace(/^-|-$/g, '');        // trim edge dashes
};
```

---

### operation.2 = getOneDreamByName (getOne)

find a prior dream by its normalized name.

```typescript
import { IsoDateStamp } from 'iso-time';

/**
 * .what = finds a dream artifact by its name, regardless of date
 * .why = enables reuse of prior dreams via findsert pattern
 */
const getOneDreamByName = async (
  input: { name: string; dreamDir: string },
): Promise<DreamArtifact | null> => {
  // glob: .dream/*.${name}.dream.md
  const pattern = `${input.dreamDir}/*.${input.name}.dream.md`;
  const matches = await glob(pattern);

  if (matches.length === 0) return null;
  if (matches.length > 1) {
    throw new UnexpectedCodePathError(
      'multiple dreams with same name found',
      { name: input.name, matches },
    );
  }

  // parse the match to extract date
  const match = matches[0];
  const filename = path.basename(match);
  const date = filename.split('.')[0] as IsoDateStamp; // YYYY_MM_DD

  return new DreamArtifact({
    path: match,
    name: input.name,
    date,
    filename,
  });
};
```

---

### operation.3 = getAllDreamsFromPastWeek (getAll, filtered)

list all dreams from the past 7 days for fuzzy match.

```typescript
import { IsoDateStamp } from 'iso-time';

/**
 * .what = retrieves all dreams created within the past week
 * .why = provides candidate pool for fuzzy match recovery
 */
const getAllDreamsFromPastWeek = async (
  input: { dreamDir: string },
): Promise<DreamArtifact[]> => {
  const pattern = `${input.dreamDir}/*.dream.md`;
  const matches = await glob(pattern);

  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - 7);

  const dreams: DreamArtifact[] = [];
  for (const match of matches) {
    const filename = path.basename(match);
    const date = filename.split('.')[0] as IsoDateStamp;
    const fileDate = parseIsoDate(date);

    if (fileDate >= cutoffDate) {
      const name = extractDreamNameFromFilename(filename);
      dreams.push(new DreamArtifact({
        path: match,
        name,
        date,
        filename,
      }));
    }
  }

  return dreams;
};
```

---

### operation.4 = getAllDreamsBySimilarity

**[NEW]** â€” find similar dream names via edit distance.

```typescript
/**
 * .what = finds dreams with similar names from the past week
 * .why = enables typo recovery without latency on happy path
 */
const getAllDreamsBySimilarity = async (
  input: {
    name: string;
    dreamDir: string;
    threshold?: number;  // default: 3 (edit distance)
  },
): Promise<DreamCandidate[]> => {
  const recentDreams = await getAllDreamsFromPastWeek({ dreamDir: input.dreamDir });
  const threshold = input.threshold ?? 3;

  const candidates: DreamCandidate[] = [];
  for (const dream of recentDreams) {
    if (dream.name === input.name) continue; // skip exact match

    const distance = computeEditDistance(input.name, dream.name);
    if (distance <= threshold) {
      candidates.push(new DreamCandidate({ dream, distance }));
    }
  }

  // sort by distance (closest first)
  return candidates.sort((a, b) => a.distance - b.distance);
};
```

---

### operation.5 = setDream (findsert)

the core findsert operation â€” find or create dream artifact.

```typescript
import { toIsoDateStamp } from 'iso-time';

/**
 * .what = finds prior dream or creates new one (findsert pattern)
 * .why = ensures dreams are not duplicated while it enables capture
 */
const setDream = async (
  input: {
    findsert: {
      name: string;
      dreamDir: string;
    };
  },
): Promise<{ dream: DreamArtifact; outcome: 'caught' | 'found' }> => {
  // check for prior dream
  const dreamFound = await getOneDreamByName({
    name: input.findsert.name,
    dreamDir: input.findsert.dreamDir,
  });

  if (dreamFound) {
    return { dream: dreamFound, outcome: 'found' };
  }

  // create new dream
  const date = toIsoDateStamp(new Date());
  const filename = `${date}.${input.findsert.name}.dream.md`;
  const dreamPath = path.join(input.findsert.dreamDir, filename);
  const content = 'dream = \n\n';

  await fs.writeFile(dreamPath, content, 'utf-8');

  const dreamCreated = new DreamArtifact({
    path: dreamPath,
    name: input.findsert.name,
    date,
    filename,
  });

  return { dream: dreamCreated, outcome: 'caught' };
};
```

---

### operation.6 = genDreamDir

idempotent folder creation with readme findsert.

```typescript
/**
 * .what = creates .dream/ folder if absent, findserts readme
 * .why = bootstraps dream folder on first use without friction
 */
const genDreamDir = async (
  input: { repoRoot: string },
): Promise<{ dreamDir: string; readmeCreated: boolean }> => {
  const dreamDir = path.join(input.repoRoot, '.dream');

  // create folder (idempotent)
  await fs.mkdir(dreamDir, { recursive: true });

  // findsert readme
  const readmePath = path.join(dreamDir, '.readme.md');
  const readmeCreated = !existsSync(readmePath);

  if (readmeCreated) {
    await fs.writeFile(readmePath, DREAM_README_TEMPLATE, 'utf-8');
  }

  return { dreamDir, readmeCreated };
};
```

---

### operation.7 = appendOntoDream

append content from one dream onto another (for fuzzy match recovery).

```typescript
/**
 * .what = appends content from one dream onto another
 * .why = enables typo recovery without data loss
 */
const appendOntoDream = async (
  input: {
    from: DreamArtifact;
    onto: DreamArtifact;
  },
): Promise<void> => {
  const separator = '\n\n---\n\n';
  const fromContent = await fs.readFile(input.from.path, 'utf-8');
  const ontoContent = await fs.readFile(input.onto.path, 'utf-8');
  const newContent = ontoContent + separator + fromContent;

  await fs.writeFile(input.onto.path, newContent, 'utf-8');
};
```

---

### operation.8 = deleteDream

remove a dream file (for fuzzy match recovery when new file is empty).

```typescript
/**
 * .what = deletes a dream file from disk
 * .why = enables cleanup in typo recovery flow
 */
const deleteDream = async (
  input: { dream: DreamArtifact },
): Promise<void> => {
  await fs.rm(input.dream.path!, { force: true });
};
```

---

## relationships

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        catch.dream CLI                       â”‚
â”‚                                                              â”‚
â”‚  input: --name, --open                                       â”‚
â”‚  output: { dream, outcome, candidates }                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     runCatchDream (composer)                    â”‚
â”‚                                                              â”‚
â”‚  1. normalizeDreamName(input.name)                          â”‚
â”‚  2. genDreamDir(repoRoot)                             â”‚
â”‚  3. setDream({ findsert: { name, dreamDir } })              â”‚
â”‚  4. openFileWithOpener(dream.path, opener)                  â”‚
â”‚  5. getAllDreamsBySimilarity(name, dreamDir)                        â”‚
â”‚  6. return { dream, outcome, candidates }                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â–¼                       â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ DreamArtifact â”‚       â”‚ DreamCandidate â”‚
      â”‚   (literal)   â”‚       â”‚   (literal)    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## treestruct

```
src/
â”œâ”€â”€ domain.objects/
â”‚   â””â”€â”€ dreamer/
â”‚       â”œâ”€â”€ DreamArtifact.ts       # literal: the dream artifact
â”‚       â””â”€â”€ DreamCandidate.ts      # literal: fuzzy match candidate
â”‚
â”œâ”€â”€ domain.operations/
â”‚   â””â”€â”€ dreamer/
â”‚       â”œâ”€â”€ dreams/                # dream artifact operations
â”‚       â”‚   â”œâ”€â”€ normalizeDreamName.ts    # pure transform
â”‚       â”‚   â”œâ”€â”€ getOneDreamByName.ts        # getOne by unique
â”‚       â”‚   â”œâ”€â”€ getAllDreamsFromPastWeek.ts # getAll filtered
â”‚       â”‚   â”œâ”€â”€ getAllDreamsBySimilarity.ts      # fuzzy search
â”‚       â”‚   â”œâ”€â”€ setDream.ts              # findsert operation
â”‚       â”‚   â”œâ”€â”€ genDreamDir.ts           # idempotent bootstrap
â”‚       â”‚   â”œâ”€â”€ appendOntoDream.ts       # content merge
â”‚       â”‚   â””â”€â”€ deleteDream.ts           # cleanup operation
â”‚       â”‚
â”‚       â””â”€â”€ catch/                 # catch.dream skill operations
â”‚           â””â”€â”€ runCatchDream.ts         # main composer
â”‚
â”œâ”€â”€ domain.roles/
â”‚   â””â”€â”€ dreamer/
â”‚       â””â”€â”€ skills/
â”‚           â””â”€â”€ catch.dream.sh     # shell dispatcher
â”‚
â””â”€â”€ contract/
    â””â”€â”€ cli/
        â””â”€â”€ catch.dream.ts         # CLI entry point
```

---

## composition flow

```
user invokes: npx rhachet run --skill catch.dream --name "Config Reload" --open codium

1. catch.dream.sh
   â””â”€ dispatches to cli.runCatchDream()

2. cli/catch.dream.ts
   â”œâ”€ getCliArgs() â†’ { name: "Config Reload", open: "codium" }
   â”œâ”€ validate --open has value if provided
   â””â”€ call runCatchDream({ name, open })

3. runCatchDream (composer)
   â”œâ”€ normalizeDreamName({ raw: "Config Reload" })
   â”‚   â””â”€ returns "config-reload"
   â”‚
   â”œâ”€ genDreamDir({ repoRoot })
   â”‚   â””â”€ creates .dream/ and findserts .readme.md
   â”‚
   â”œâ”€ setDream({ findsert: { name: "config-reload", dreamDir } })
   â”‚   â”œâ”€ getOneDreamByName() â†’ null (not found)
   â”‚   â””â”€ creates .dream/2026_01_27.config-reload.dream.md
   â”‚       â””â”€ returns { dream: DreamArtifact, outcome: 'caught' }
   â”‚
   â”œâ”€ openFileWithOpener({ opener: "codium", filePath })
   â”‚   â””â”€ opens editor (or catches OpenerUnavailableError)
   â”‚
   â”œâ”€ getAllDreamsBySimilarity({ name, dreamDir })
   â”‚   â””â”€ returns [] (no candidates)
   â”‚
   â””â”€ render output:
          ğŸŒ™ dream caught
             â”œâ”€ .dream/2026_01_27.config-reload.dream.md
             â””â”€ opened in codium
```

---

## dependencies

| operation | depends on |
| --- | --- |
| `runCatchDream` | `normalizeDreamName`, `genDreamDir`, `setDream`, `getAllDreamsBySimilarity`, `openFileWithOpener` |
| `setDream` | `getOneDreamByName`, `toIsoDateStamp` (from iso-time) |
| `getAllDreamsBySimilarity` | `getAllDreamsFromPastWeek`, `computeEditDistance` |
| `getAllDreamsFromPastWeek` | `parseIsoDate`, `extractDreamNameFromFilename` |
| `appendOntoDream` | (none) |
| `deleteDream` | (none) |
| `normalizeDreamName` | (none - pure) |
| `genDreamDir` | (inline readme template) |

---

## reuse vs new

| component | status | source |
| --- | --- | --- |
| `openFileWithOpener` | [REUSE] | `src/infra/shell/openFileWithOpener.ts` |
| `getCliArgs` | [REUSE] | `src/infra/cli/getCliArgs.ts` |
| `withEmojiSpaceShim` | [REUSE] | `src/infra/shell/withEmojiSpaceShim.ts` |
| `toIsoDateStamp` | [REUSE] | `iso-time` package |
| `BehaviorArtifact` pattern | [REUSE] | `src/domain.objects/BehaviorArtifact.ts` |
| `normalizeDreamName` | [NEW] | â€” |
| `getOneDreamByName` | [NEW] | â€” |
| `getAllDreamsFromPastWeek` | [NEW] | â€” |
| `getAllDreamsBySimilarity` | [NEW] | â€” |
| `setDream` | [EXTEND] | findsert pattern from `initBehaviorDir.ts` |
| `genDreamDir` | [EXTEND] | mkdir pattern from `initBehaviorDir.ts` |
| `appendOntoDream` | [NEW] | â€” |
| `deleteDream` | [NEW] | â€” |

---

ğŸŒ™
