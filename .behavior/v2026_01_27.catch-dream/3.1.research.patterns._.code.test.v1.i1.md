# research: test codepath patterns for catch.dream ðŸŒ™

## summary

the prior `init.behavior` test suite provides a complete template for the `catch.dream` skill tests. the test infrastructure is mature and can be reused directly, with only domain-specific test cases that need new implementation.

---

## pattern.1 = acceptance test structure with test-fns

**[REUSE]**

acceptance tests use `test-fns` for BDD-style given/when/then:

> citation [1]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:8`
> ```typescript
> import { given, then, useBeforeAll, when } from 'test-fns';
> ```

> citation [2]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:98-119`
> ```typescript
> given('[case1] consumer: fresh consumer repo on main branch', () => {
>   let consumer: ConsumerRepo;
>
>   beforeAll(() => {
>     consumer = genConsumerRepo({ prefix: 'init-behavior-test-' });
>   });
>
>   afterAll(() => {
>     consumer.cleanup();
>   });
>
>   when('[t0] init.behavior --name test-feature is invoked', () => {
>     then('rejects bind to main branch', () => {
>       const result = runInitBehaviorSkillViaRhachet({
>         behaviorName: 'test-feature',
>         repoDir: consumer.repoDir,
>       });
>
>       expect(result.exitCode).toBe(1);
>       expect(result.output).toContain('can not bind');
>       expect(result.output).toContain('main');
>     });
> ```

**for catch.dream:**
- create `blackbox/role=dreamer/skill.catch.dream.acceptance.test.ts`
- same given/when/then structure
- label cases `[case1]`, `[case2]`, etc.
- label events `[t0]`, `[t1]`, etc.

---

## pattern.2 = consumer repo generation

**[EXTEND]**

consumer repos simulate realistic consumer environments:

> citation [3]: `blackbox/.test/infra/genConsumerRepo.ts:22-29`
> ```typescript
> export const genConsumerRepo = (input?: {
>   prefix?: string;
>   withClaudeDir?: boolean;
> }): ConsumerRepo => {
>   // create base git repo
>   const { repoDir, cleanup } = genTestGitRepo({
>     prefix: input?.prefix ?? 'consumer-test-',
>   });
> ```

> citation [4]: `blackbox/.test/infra/genConsumerRepo.ts:82-90`
> ```typescript
> // link roles so skills are available
> execSync('npx rhachet roles link --repo bhuild --role behaver', {
>   cwd: repoDir,
>   stdio: 'pipe',
> });
> execSync('npx rhachet roles link --repo bhuild --role decomposer', {
>   cwd: repoDir,
>   stdio: 'pipe',
> });
> ```

**for catch.dream:**
- extend to link dreamer role: `npx rhachet roles link --repo bhuild --role dreamer`
- or create dedicated `genConsumerRepoWithDreamer()` helper

---

## pattern.3 = test git repo generation

**[REUSE]**

minimal git repos for isolated tests:

> citation [5]: `blackbox/.test/infra/genTestGitRepo.ts:16-23`
> ```typescript
> export const genTestGitRepo = (input?: {
>   prefix?: string;
>   branchName?: string;
>   copyFrom?: string; // copy fixture contents before git init
>   commitGlob?: string; // what to commit initially (defaults to '.')
> }): TestGitRepo => {
>   const prefix = input?.prefix ?? 'test-git-repo-';
>   const repoDir = fs.mkdtempSync(path.join(os.tmpdir(), prefix));
> ```

> citation [6]: `blackbox/.test/infra/genTestGitRepo.ts:33-46`
> ```typescript
> // init git repo with main branch to suppress git 3.0 warn
> execSync('git init -b main', { cwd: repoDir });
> execSync('git config user.email "test@test.com"', { cwd: repoDir });
> execSync('git config user.name "Test"', { cwd: repoDir });
>
> // create initial commit (required for branch operations)
> const commitGlob = input?.commitGlob ?? '.';
> execSync(`git add ${commitGlob}`, { cwd: repoDir });
> execSync('git commit -m "initial"', { cwd: repoDir });
>
> // checkout requested branch if different from main
> if (input?.branchName && input.branchName !== 'main') {
>   execSync(`git checkout -b "${input.branchName}"`, { cwd: repoDir });
> }
> ```

**for catch.dream:**
- direct reuse for test isolation
- use `copyFrom` option for dream fixture tests

---

## pattern.4 = rhachet skill invocation wrapper

**[REUSE]**

unified skill invocation via rhachet dispatch:

> citation [7]: `blackbox/.test/infra/runRhachetSkill.ts:14-28`
> ```typescript
> export const runRhachetSkill = (input: {
>   repo: string;
>   role?: string;
>   skill: string;
>   args?: string;
>   repoDir: string;
>   timeout?: number;
> }): SkillResult => {
>   const args = input.args ? `-- ${input.args}` : '';
>   const timeout = input.timeout ?? 60000;
>   const roleFlag = input.role ? `--role ${input.role}` : '';
>
>   try {
>     const stdout = execSync(
>       `npx rhachet run --repo ${input.repo} ${roleFlag} --skill ${input.skill} ${args}`,
> ```

> citation [8]: `blackbox/.test/infra/runRhachetSkill.ts:40-45`
> ```typescript
> return {
>   stdout: stdout.trim(),
>   stderr: '',
>   output: stdout.trim(),
>   exitCode: 0,
> };
> ```

**for catch.dream:**
- direct reuse of `runRhachetSkill()`
- create typed wrapper `runCatchDreamSkillViaRhachet()`

---

## pattern.5 = skill helper wrapper with typed args

**[REUSE]**

wrap `runRhachetSkill` with skill-specific typed input:

> citation [9]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:33-42`
> ```typescript
> const runInitBehaviorSkillViaRhachet = (input: {
>   behaviorName: string;
>   repoDir: string;
> }) =>
>   runRhachetSkill({
>     repo: 'bhuild',
>     skill: 'init.behavior',
>     args: `--name "${input.behaviorName}"`,
>     repoDir: input.repoDir,
>   });
> ```

**for catch.dream:**
```typescript
const runCatchDreamSkillViaRhachet = (input: {
  dreamName: string;
  open?: string;
  repoDir: string;
}) =>
  runRhachetSkill({
    repo: 'bhuild',
    role: 'dreamer',
    skill: 'catch.dream',
    args: `--name "${input.dreamName}"${input.open ? ` --open ${input.open}` : ''}`,
    repoDir: input.repoDir,
  });
```

---

## pattern.6 = direct bash shell invocation

**[REUSE]**

test shell command directly without rhachet dispatch:

> citation [10]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:48-81`
> ```typescript
> const runInitBehaviorSkillDirect = (input: {
>   args: string;
>   targetDir: string;
> }): { stdout: string; exitCode: number } => {
>   try {
>     const stdout = execSync(
>       `bash "${SKILL_PATH}" ${input.args} --dir "${input.targetDir}"`,
>       {
>         encoding: 'utf-8',
>         env: {
>           ...process.env,
>           PATH: process.env.PATH,
>         },
>       },
>     );
>     return { stdout: stdout.trim(), exitCode: 0 };
>   } catch (error: unknown) {
>     const execError = error as {
>       stdout?: string;
>       stderr?: string;
>       status?: number;
>     };
>     // ... capture stdout/stderr/exitCode
>   }
> };
> ```

**for catch.dream:**
- reuse pattern for `runCatchDreamSkillDirect()`
- tests shell command portability

---

## pattern.7 = file system verification

**[REUSE]**

verify file creation with `existsSync` and `readdirSync`:

> citation [11]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:131-151`
> ```typescript
> const behaviorRoot = path.join(consumer.repoDir, '.behavior');
> expect(fs.existsSync(behaviorRoot)).toBe(true);
>
> const behaviorDirs = fs.readdirSync(behaviorRoot);
> const scaffoldDir = behaviorDirs.find((d) =>
>   d.includes('scaffold-test'),
> );
> expect(scaffoldDir).toBeDefined();
>
> const behaviorPath = path.join(behaviorRoot, scaffoldDir!);
> expect(fs.existsSync(path.join(behaviorPath, '0.wish.md'))).toBe(true);
> expect(fs.existsSync(path.join(behaviorPath, '1.vision.md'))).toBe(
>   true,
> );
> ```

**for catch.dream:**
- verify `.dream/` folder creation
- verify `$isodate.$dreamname.dream.md` file creation
- verify `.dream/.readme.md` findsert

---

## pattern.8 = file content verification

**[REUSE]**

verify file contents with `readFileSync`:

> citation [12]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:294-299`
> ```typescript
> const flagContent = fs.readFileSync(
>   path.join(bindDir, flagFiles[0]!),
>   'utf-8',
> );
> expect(flagContent).toContain('branch: feature/auto-bind');
> expect(flagContent).toContain('bound_by: init.behavior skill');
> ```

**for catch.dream:**
- verify dream file contains `dream = ` template
- verify `.readme.md` contains dreamcatcher explanation

---

## pattern.9 = idempotency test

**[REUSE]**

test same invocation twice succeeds:

> citation [13]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:351-365`
> ```typescript
> then('second run succeeds (idempotent)', () => {
>   const firstResult = runInitBehaviorSkillDirect({
>     args: '--name same-behavior',
>     targetDir: testRepo.repoDir,
>   });
>   expect(firstResult.exitCode).toBe(0);
>   expect(firstResult.stdout).toContain('+ 0.wish.md');
>
>   const secondResult = runInitBehaviorSkillDirect({
>     args: '--name same-behavior',
>     targetDir: testRepo.repoDir,
>   });
>   expect(secondResult.exitCode).toBe(0);
>   expect(secondResult.stdout).toContain('âœ“ 0.wish.md');
> });
> ```

**for catch.dream:**
- test same dream name twice â†’ `ðŸŒ™ dream found` second time
- test new dream â†’ `ðŸŒ™ dream caught`

---

## pattern.10 = opener flag test with cat

**[REUSE]**

test `--open` flag with cat command (universal):

> citation [14]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:382-389`
> ```typescript
> then('cat command outputs wish file content', () => {
>   const result = runInitBehaviorSkillDirect({
>     args: '--name open-test --open cat',
>     targetDir: testRepo.repoDir,
>   });
>
>   expect(result.exitCode).toBe(0);
>   expect(result.stdout).toContain('wish =');
> });
> ```

**for catch.dream:**
- test `--open cat` outputs `dream = ` template
- verifies opener works without real editor

---

## pattern.11 = unavailable opener test

**[REUSE]**

test graceful failure when opener not found:

> citation [15]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:463-475`
> ```typescript
> then('warn is shown about opener unavailable', () => {
>   const freshRepo = createTestRepo({ branchName: 'feature/warn-test' });
>
>   try {
>     const result = runInitBehaviorSkillDirect({
>       args: '--name warn-test --open nonexistent-xyz-12345',
>       targetDir: freshRepo.repoDir,
>     });
>
>     expect(result.stdout).toContain('unavailable');
>   } finally {
>     freshRepo.cleanup();
>   }
> });
> ```

**for catch.dream:**
- test bad opener shows warn but file still created

---

## pattern.12 = emoji shim for terminal compat

**[REUSE]**

shim emoji output for cross-terminal compat:

> citation [16]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:21-22`
> ```typescript
> const shim = (message: string) =>
>   transformMessageForTerminal({ message, terminal: detectTerminalChoice() });
> ```

> citation [17]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:183`
> ```typescript
> expect(result.output).toContain(shim('ðŸ¦« oh, behave!'));
> ```

**for catch.dream:**
- use shim for `ðŸŒ™ dream caught` and `ðŸŒ™ dream found` assertions

---

## pattern.13 = useBeforeAll for shared setup

**[REUSE]**

share expensive setup across multiple `then()` blocks:

> citation [18]: `blackbox/role=behaver/skill.init.behavior.acceptance.test.ts:207-212`
> ```typescript
> const result = useBeforeAll(async () =>
>   runInitBehaviorSkillViaRhachet({
>     behaviorName: 'second-behavior',
>     repoDir: consumer.repoDir,
>   }),
> );
> ```

**for catch.dream:**
- use for fuzzy match tests where setup is shared
- invoke skill once, assert multiple outcomes

---

## new test patterns required

### pattern.new.1 = dream fixture generation

**[NEW]**

create dream fixtures for tests:

```typescript
const genDreamFixture = (input: {
  repoDir: string;
  dreamName: string;
  datePrefix?: string;
  content?: string;
}): { dreamPath: string } => {
  const datePrefix = input.datePrefix ?? '2026_01_25';
  const dreamDir = path.join(input.repoDir, '.dream');
  fs.mkdirSync(dreamDir, { recursive: true });

  const dreamPath = path.join(
    dreamDir,
    `${datePrefix}.${input.dreamName}.dream.md`,
  );
  fs.writeFileSync(dreamPath, input.content ?? 'dream = ');

  return { dreamPath };
};
```

---

### pattern.new.2 = prior dream test

**[NEW]**

test that prior dream is found (not duplicated):

```typescript
given('[case2] repo with prior dream', () => {
  const scene = useBeforeAll(async () => {
    const { repoDir } = genTestGitRepo({ prefix: 'catch-dream-prior-' });
    genDreamFixture({
      repoDir,
      dreamName: 'config-reload',
      datePrefix: '2026_01_20',
    });
    return { repoDir };
  });

  when('[t0] catch.dream --name "config-reload" invoked', () => {
    then('output shows "ðŸŒ™ dream found"', () => {
      const result = runCatchDreamSkillViaRhachet({
        dreamName: 'config-reload',
        repoDir: scene.repoDir,
      });
      expect(result.output).toContain(shim('ðŸŒ™ dream found'));
    });

    then('no new file is created', () => {
      const dreamDir = path.join(scene.repoDir, '.dream');
      const files = fs.readdirSync(dreamDir);
      expect(files.filter(f => f.includes('config-reload'))).toHaveLength(1);
    });
  });
});
```

---

### pattern.new.3 = fuzzy match test

**[NEW]**

test fuzzy match prompt for typos:

```typescript
given('[case3] repo with prior dream and typo input', () => {
  const scene = useBeforeAll(async () => {
    const { repoDir } = genTestGitRepo({ prefix: 'catch-dream-fuzzy-' });
    genDreamFixture({
      repoDir,
      dreamName: 'config-reload',
      datePrefix: computeIsodateForDaysAgo(2), // within past week
    });
    return { repoDir };
  });

  when('[t0] catch.dream --name "config-relod" invoked', () => {
    then('output shows "ðŸ’­ related dreams from past week"', () => {
      const result = runCatchDreamSkillDirect({
        args: '--name "config-relod"',
        targetDir: scene.repoDir,
      });
      expect(result.output).toContain('ðŸ’­ related dreams from past week');
    });
  });
});
```

---

### pattern.new.4 = normalization test

**[NEW]**

test input normalization to kebab-case:

```typescript
given('[case4] input with spaces and special chars', () => {
  when('[t0] catch.dream --name "Config Hot Reload" invoked', () => {
    then('file is created as config-hot-reload', () => {
      const { repoDir } = genTestGitRepo({ prefix: 'catch-dream-norm-' });
      runCatchDreamSkillDirect({
        args: '--name "Config Hot Reload"',
        targetDir: repoDir,
      });

      const dreamDir = path.join(repoDir, '.dream');
      const files = fs.readdirSync(dreamDir);
      expect(files.some(f => f.includes('config-hot-reload'))).toBe(true);
    });
  });
});
```

---

### pattern.new.5 = readme findsert test

**[NEW]**

test `.dream/.readme.md` is created on first use:

```typescript
given('[case5] repo with no .dream/ folder', () => {
  when('[t0] catch.dream invoked for first time', () => {
    then('.dream/.readme.md is created', () => {
      const { repoDir } = genTestGitRepo({ prefix: 'catch-dream-readme-' });
      runCatchDreamSkillDirect({
        args: '--name "first-idea"',
        targetDir: repoDir,
      });

      const readmePath = path.join(repoDir, '.dream', '.readme.md');
      expect(fs.existsSync(readmePath)).toBe(true);

      const content = fs.readFileSync(readmePath, 'utf-8');
      expect(content).toContain('ðŸŒ™');
      expect(content).toContain('catch.dream');
    });
  });
});
```

---

## summary table

| pattern                    | action   | source                                            |
| -------------------------- | -------- | ------------------------------------------------- |
| test-fns given/when/then   | [REUSE]  | skill.init.behavior.acceptance.test.ts:8,98-119   |
| consumer repo generation   | [EXTEND] | genConsumerRepo.ts:22-29,82-90                    |
| test git repo generation   | [REUSE]  | genTestGitRepo.ts:16-23,33-46                     |
| rhachet skill invocation   | [REUSE]  | runRhachetSkill.ts:14-28,40-45                    |
| skill helper wrapper       | [REUSE]  | skill.init.behavior.acceptance.test.ts:33-42      |
| direct bash invocation     | [REUSE]  | skill.init.behavior.acceptance.test.ts:48-81      |
| file system verification   | [REUSE]  | skill.init.behavior.acceptance.test.ts:131-151    |
| file content verification  | [REUSE]  | skill.init.behavior.acceptance.test.ts:294-299    |
| idempotency test           | [REUSE]  | skill.init.behavior.acceptance.test.ts:351-365    |
| opener flag test           | [REUSE]  | skill.init.behavior.acceptance.test.ts:382-389    |
| unavailable opener test    | [REUSE]  | skill.init.behavior.acceptance.test.ts:463-475    |
| emoji shim                 | [REUSE]  | skill.init.behavior.acceptance.test.ts:21-22,183  |
| useBeforeAll               | [REUSE]  | skill.init.behavior.acceptance.test.ts:207-212    |
| dream fixture generation   | [NEW]    | â€”                                                 |
| prior dream test           | [NEW]    | â€”                                                 |
| fuzzy match test           | [NEW]    | â€”                                                 |
| normalization test         | [NEW]    | â€”                                                 |
| readme findsert test       | [NEW]    | â€”                                                 |

---

ðŸŒ™
