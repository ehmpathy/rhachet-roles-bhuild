# usecase.1 = rule briefs are discoverable and organized

given('rule briefs for reviewing behavior artifacts')
  when('a reviewer searches for rules by artifact type')
    then('wish rules are found under .agent/**/practices/behavior.wish/rule.*.md')
      sothat('reviewers can apply wish-specific practices')
    then('criteria rules are found under .agent/**/practices/behavior.criteria/rule.*.md')
      sothat('reviewers can apply criteria-specific practices')
    then('blueprint rules are found under .agent/**/practices/behavior.blueprint/rule.*.md')
      sothat('reviewers can apply blueprint-specific practices')
    then('roadmap rules are found under .agent/**/practices/behavior.roadmap/rule.*.md')
      sothat('reviewers can apply roadmap-specific practices')


# usecase.2 = reviewing a wish document

given('a wish document exists at .behavior/v*/0.wish.md')
  when('reviewed with wish rules')
    then('feedback identifies whether desires are clearly stated')
      sothat('ambiguous wishes are caught before downstream work begins')
    then('feedback identifies whether scope is well-bounded')
      sothat('scope creep is prevented early')
    then('feedback is emitted to 0.wish.md.[feedback].v{N}.[given].by_robot.md')
      sothat('feedback is traceable and versioned')

given('a wish document has unclear desires')
  when('reviewed with wish rules')
    then('feedback flags the unclear sections as BLOCKER')
      sothat('builders dont proceed with ambiguous requirements')


# usecase.3 = reviewing a criteria document

given('a criteria document exists at .behavior/v*/2.criteria.md')
  when('reviewed with criteria rules')
    then('feedback verifies bdd format is used (given/when/then/sothat)')
      sothat('criteria are structured and testable')
    then('feedback verifies usecases are grouped logically')
      sothat('related behaviors are reviewed together')
    then('feedback verifies usecases are ordered by dependency')
      sothat('foundational behaviors are validated first')
    then('feedback is emitted to 2.criteria.md.[feedback].v{N}.[given].by_robot.md')

given('a criteria document uses prose instead of bdd format')
  when('reviewed with criteria rules')
    then('feedback flags format violation as BLOCKER')
      sothat('criteria remain machine-parseable and verifiable')

given('a criteria document has incomplete then() clauses')
  when('reviewed with criteria rules')
    then('feedback flags missing assertions as BLOCKER')
      sothat('every behavior has a verifiable outcome')


# usecase.4 = reviewing a blueprint document

given('a blueprint document exists at .behavior/v*/3.3.blueprint.*.md')
  when('reviewed with blueprint rules')
    then('feedback verifies unit test coverage is specified for all domain.logic')
      sothat('core logic is protected by fast, isolated tests')
    then('feedback verifies integration test coverage is specified for all boundaries')
      sothat('external system interactions are verified')
    then('feedback verifies acceptance test coverage is specified for behavioral contracts')
      sothat('user-facing behaviors are validated end-to-end')
    then('feedback verifies deterministic vs probabilistic parts are declared')
      sothat('testing strategies can be adapted accordingly')
    then('feedback verifies blueprint satisfies all criteria')
      sothat('no requirements are missed in implementation')
    then('feedback is emitted to 3.3.blueprint.*.md.[feedback].v{N}.[given].by_robot.md')

given('a blueprint omits test coverage specification')
  when('reviewed with blueprint rules')
    then('feedback flags missing test coverage as BLOCKER')
      sothat('untested code does not reach production')

given('a blueprint has probabilistic components without examples')
  when('reviewed with blueprint rules')
    then('feedback flags missing examples as NITPICK')
      sothat('non-deterministic logic has reference implementations')

given('a blueprint does not satisfy all criteria')
  when('reviewed with blueprint rules')
    then('feedback flags incomplete coverage as BLOCKER')
      sothat('all behaviors are implemented')


# usecase.5 = reviewing a roadmap document

given('a roadmap document exists at .behavior/v*/4.1.roadmap.*.md')
  when('reviewed with roadmap rules')
    then('feedback verifies phases are ordered by dependency')
      sothat('prerequisites are built before dependents')
    then('feedback verifies each phase has clear deliverables')
      sothat('progress is measurable')
    then('feedback is emitted to 4.1.roadmap.*.md.[feedback].v{N}.[given].by_robot.md')

given('a roadmap has circular dependencies between phases')
  when('reviewed with roadmap rules')
    then('feedback flags circular dependency as BLOCKER')
      sothat('execution order is determinable')


# usecase.6 = composite skill orchestrates full behavior review

given('a behavior directory exists at .behavior/v*_$name/')
  when('`npx rhachet run --repo bhuild --skill review.behavior --of $name` is invoked')
    then('the behavior directory is autodetected from --of $name')
      sothat('users dont need to specify full paths')
    then('wish document is reviewed with wish rules')
    then('criteria document is reviewed with criteria rules')
    then('blueprint document is reviewed with blueprint rules')
    then('roadmap document is reviewed with roadmap rules')
    then('all feedback files are emitted to respective locations')
      sothat('feedback is collocated with artifacts')

given('a behavior directory does not exist for --of $name')
  when('review.behavior skill is invoked')
    then('skill fails with clear error indicating behavior not found')
      sothat('typos and missing behaviors are caught immediately')

given('a behavior directory has no wish document')
  when('review.behavior skill is invoked')
    then('skill emits warning that wish is missing')
    then('skill continues reviewing other artifacts that exist')
      sothat('partial reviews are still valuable')


# usecase.7 = skill builds on existing bhrain review infrastructure

given('bhrain provides `npx rhachet run --repo bhrain --skill review`')
  when('review.behavior skill is executed')
    then('it invokes bhrain review skill with --rules and --paths')
      sothat('existing review infrastructure is reused')
    then('it passes --output for each artifact type')
      sothat('feedback is emitted to correct locations')

given('bhrain review skill is not available')
  when('review.behavior skill is invoked')
    then('skill fails with clear error indicating dependency missing')
      sothat('infrastructure issues are surfaced immediately')
