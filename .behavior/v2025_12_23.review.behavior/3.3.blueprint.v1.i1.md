# blueprint: review.behavior

## overview

this blueprint implements automated behavior artifact review via two deliverables:

1. **rule briefs** - practices for review of wish, criteria, blueprint, roadmap artifacts
2. **composite skill** - `review.behavior` that orchestrates bhrain review against these rules


---

## deliverable.1 = rule briefs

### structure

```
src/domain.roles/behaver/briefs/practices/
├── behavior.wish/
│   ├── rule.prefer.clear-desires.md
│   └── rule.prefer.bounded-scope.md
├── behavior.criteria/
│   ├── rule.require.bdd-format.md
│   ├── rule.prefer.usecase-groups.md
│   ├── rule.prefer.depth-groups.md
│   └── rule.prefer.dependency-order.md
├── behavior.blueprint/
│   ├── rule.require.test-coverage-specified.md
│   ├── rule.require.test-patterns-specified.md
│   ├── rule.require.determinism-declared.md
│   └── rule.require.criteria-satisfied.md
└── behavior.roadmap/
    ├── rule.prefer.dependency-order.md
    └── rule.prefer.clear-deliverables.md
```

### rule brief format

each rule file follows the established brief pattern:

```md
.rule = {action}.{name}

.what = one-line summary of the rule

.why = explanation of rationale (1-3 lines)

.how = how to evaluate compliance

.examples:
  .positive:
    - example of compliant artifact
  .negative:
    - example of non-compliant artifact

.severity = BLOCKER | NITPICK
```

### rule specifications

#### behavior.wish/

**rule.prefer.clear-desires.md**
- .what = wishes must clearly state what is desired
- .why = ambiguous wishes lead to misaligned implementations
- .how = check for explicit "wish =" statement with concrete desires
- .severity = BLOCKER when desires are unstated or vague

**rule.prefer.bounded-scope.md**
- .what = wishes should define boundaries of what is in/out of scope
- .why = unbounded scope leads to scope creep and unclear completion
- .how = check for explicit boundaries or constraints
- .severity = NITPICK

#### behavior.criteria/

**rule.require.bdd-format.md**
- .what = criteria must use given/when/then/sothat format
- .why = bdd format ensures criteria are testable and structured
- .how = verify each usecase has given(), when(), then() declarations
- .severity = BLOCKER when prose is used instead of bdd

**rule.prefer.usecase-groups.md**
- .what = criteria should be grouped by usecase with `# usecase.N = description`
- .why = usecase groups improve readability and navigation
- .how = check for usecase headers preceding related given blocks
- .severity = NITPICK

**rule.prefer.depth-groups.md**
- .what = criteria should be grouped by depth of abstraction (foundation → contract)
- .why = depth groups clarify the layer at which each behavior operates
- .how = check for depth progression from low-level to high-level usecases
- .severity = NITPICK

**rule.prefer.dependency-order.md**
- .what = usecases should be ordered by dependency (foundational first)
- .why = dependency order enables incremental verification and natural read flow
- .how = verify that referenced behaviors appear before dependents
- .severity = NITPICK

#### behavior.blueprint/

**rule.require.test-coverage-specified.md**
- .what = blueprints must specify test coverage for all components
- .why = untested code should never reach production
- .how = verify unit/integration/acceptance test specifications exist
- .severity = BLOCKER when test coverage is omitted

**rule.require.test-patterns-specified.md**
- .what = blueprints must specify test patterns for integration and acceptance tests
- .why = clear test patterns enable fast feedback loops and thorough verification
- .how = verify test patterns are articulated (e.g., given/when/then, fixtures, mocks vs real)
- .severity = BLOCKER when test patterns are omitted

**rule.require.determinism-declared.md**
- .what = blueprints must declare which parts are deterministic vs probabilistic
- .why = different test strategies apply to each
- .how = check for explicit determinism classification of components
- .severity = BLOCKER when undeclared, NITPICK when probabilistic lacks examples

**rule.require.criteria-satisfied.md**
- .what = blueprints must cover all declared criteria
- .why = ensures no requirements are missed in implementation
- .how = cross-reference blueprint sections against criteria usecases
- .severity = BLOCKER when criteria are not addressed

#### behavior.roadmap/

**rule.prefer.dependency-order.md**
- .what = roadmap phases should be ordered by dependency
- .why = dependency order enables correct execution sequence and parallel work identification
- .how = verify that phase prerequisites are listed before dependents
- .severity = BLOCKER when circular dependencies exist, NITPICK otherwise

**rule.prefer.clear-deliverables.md**
- .what = each phase should have clear, measurable deliverables
- .why = clear deliverables enable progress track and completion verification
- .how = check each phase has explicit deliverable statements
- .severity = NITPICK


---

## deliverable.2 = composite skill

### file location

```
src/domain.roles/behaver/skills/review.behavior.sh
```

### interface

```sh
# usage
npx rhachet run --repo bhuild --skill review.behavior \
  --of <behavior-name> \
  [--against wish,criteria,blueprint,roadmap] \
  [--interactive]

# examples
npx rhachet run --repo bhuild --skill review.behavior --of say-hello
npx rhachet run --repo bhuild --skill review.behavior --of say-hello --against criteria,blueprint
```

### behavior

1. **resolve behavior directory** from `--of` argument
   - search `.behavior/v*.$name/` for matching behavior
   - fail-fast if not found or ambiguous

2. **determine artifacts to review** from `--against` (default: all)
   - wish, criteria, blueprint, roadmap

3. **invoke bhrain review** for each artifact type
   ```sh
   npx rhachet run --repo bhrain --skill review \
     --rules .agent/**/practices/behavior.$type/rule.*.md \
     --paths .behavior/v*.$name/$file \
     --output .behavior/v*.$name/$file.[feedback].v{N}.[given].by_robot.md
   ```

4. **aggregate feedback** into single summary output
   - list all BLOCKERs and NITPICKs across artifact types
   - emit to `.behavior/v*.$name/7.2.review.behavior.[feedback].[given].by_robot.v{timestamp}.md`

### implementation pattern

follows `review.deliverable.sh` pattern:
- argument parse via named args
- behavior directory resolution via find
- spinner animation for non-interactive mode
- structured log output to `.log/bhuild/review.behavior/`
- tree-structured status output


---

## testing

### deterministic components
- argument parse
- behavior directory resolution
- artifact file resolution
- bhrain invocation command construction
- output file path generation

### probabilistic components
- bhrain review feedback content (llm-generated)
  - reference: bhrain already has examples of review output

### test coverage

**unit tests** (src/domain.roles/behaver/skills/review.behavior.test.ts)
- argument parse validates required args
- behavior directory resolution finds correct match
- ambiguous behavior name fails with clear error
- absent behavior fails with clear error
- artifact file resolution finds correct files
- bhrain command is constructed correctly

**integration tests** (src/domain.roles/behaver/skills/review.behavior.integration.test.ts)
- given valid behavior, review produces feedback files
- given absent criteria, review warns but continues
- given --against subset, only specified artifacts reviewed
- output follows expected format with blockers/nitpicks

**acceptance tests**
- npx rhachet run --repo bhuild --skill review.behavior --of valid-behavior
  - produces feedback files collocated with artifacts


---

## rollout

### phase 0: scaffolding
- create briefs/practices directory structure under src/domain.roles/behaver/briefs/practices/
- create empty rule files with headers

### phase 1: rule briefs
- implement behavior.wish rules
- implement behavior.criteria rules
- implement behavior.blueprint rules
- implement behavior.roadmap rules

### phase 2: composite skill
- implement review.behavior.sh following review.deliverable.sh pattern
- add unit tests
- add integration tests

### phase 3: symlinks
- update getBehaverRole.ts to include briefs directory
- verify briefs symlink resolves correctly at .agent/repo=bhuild/role=behaver/briefs/

### phase 4: validation
- run review.behavior against this behavior directory
- verify feedback is produced and accurate
